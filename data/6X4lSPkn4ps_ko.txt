- 강연에 오신 걸 환영합니다.당신에 대해 알아요, 제 생각엔
첫날 첫 공연.여기 오게 돼서 정말 좋아요.제가 가장 좋아하는 서비스 중 하나인 Amazon EventBridge에 대해 이야기하게 되어 정말 영광입니다.제 이름은 쉰 브리살스예요.
그리고 저는 서버리스 히어로예요.또한 이 소식을 공유하게 되어 기쁩니다.
저는 현재 AWS의 서버리스에 관한 책을 쓰고 있습니다.
동료 Luke와 함께요.내년 초로 예정되어 있습니다.이제 AWS re:Invent는 기술을 기념하는 행사이자 축하의 장이 되었습니다.
또한 서로 공유하고 배울 수 있는 기회이기도 합니다.그냥 호기심, 얼마나 많은지
EventBridge가 처음이고 이벤트 기반 아키텍처가 처음이신가요?용기를 내세요.완벽해요.이번 세션이 끝나셨으면 좋겠어요.
영감을 얻어 팀과 조직에 메시지를 전달하고 EventBridge를 사용하는 이벤트 기반 아키텍처를 구축하십시오.많은 안건이긴 하지만 걱정하지 마세요. 제가 부분별로 안내해 드리겠습니다.
점진적으로 말이죠.당신을 멈추고, 요약하고, 앞으로 나아가겠습니다.따라서 기본적으로 이벤트 기반 아키텍처의 기본 사항을 다루겠습니다.그런 다음 EventBridge가 등장하는 이유와 방법을 살펴보고 이벤트를 생각할 때의 몇 가지 모범 사례를 살펴보겠습니다.
먼저 몇 가지 사항을 자세히 살펴보겠습니다.
이벤트 기반 패턴.마지막으로 자주 묻는 질문 몇 가지로 마치겠습니다. 사람들이 자주 묻는 질문입니다.
EventBridge와 이벤트 기반 아키텍처를 언제 접했는지 물어보십시오.자, 앞으로 나아가기 전에
오래되지 않았으면 좋겠어요. 베르너가 언급한 작년의 re:Invent로 돌아가세요.
이 두 가지 중요한 점은 바로 비동기성과 이벤트 구동입니다.이에 대한 이해
오늘 강연에서 앞으로 나아가려면 두 가지가 매우 중요합니다.이제 두 가지 중요한 요소인 비동기식과 이벤트 중심을 살펴보겠습니다.비동기성을 이해하려면 동기식에 대한 이해가 필요하죠?따라서 여러분 대부분은 이런 종류의 심볼 패턴, 즉 애플리케이션 요청에 대해 잘 알고 있을 것입니다.
서비스라든가, 제품 가격을 알려주면 그 가격을 돌려주기도 하죠.앱을 사용하는 고객으로서 행복합니다.동기식 플로우입니다.이제 진행해 보죠.
여기 두 가지 서비스가 있습니다.이것들은, 아시다시피
서비스 간 통신.서비스 C 주문 처리를 예로 들어 보겠습니다.서비스 D는 결제입니다.그러니까 주문이 들어오기 전에
배송 시에는 이전에 승인된 결제 금액을 인출, 정산 또는 이체해야 합니다.따라서 일반적으로 서비스는
C, 몇 시간에 한 번, 또는 상황에 따라
알다시피, 소프트웨어 시스템 때문에 바빠서 많은 걸 보낼 거예요
수천 개의 결제 ID가 서비스 D에 전송되어 캡처를 할 수 있습니다.물론 서비스는 그렇지 않습니다.
몇 시간이 걸릴 수 있기 때문에 여기저기 돌아다닐 거예요
며칠, 어쩌면 몇 주.그래서 보내는 게 뭐냐면
어쩌면 배치 ID와 함께 확인이 돌아왔을 수도 있습니다.이제 문제가 생겼죠?왜냐하면 서비스는 어떻게 작동할까요?
C는 일괄 지급 진행 상황을 알고 있나요?그리고 여러 개를 제출할 수 있습니다.
낮에 한꺼번에 나눠요, 알겠죠?그래서 보통 서비스 D는
일종의 상태 풀이 있으면 API가 열립니다.
서비스 C가 폴링이나 쿼리를 할 수 있는 엔드포인트입니다.이제 괜찮아 보이지만,
서비스 C의 관점에서는 문제가 있습니다.폴링을 얼마나 빨리 시작해야 하는지, 얼마나 오래, 얼마나 자주 시작해야 하는지
계속 전화해야 돼요?일반적인 커맨드 쿼리 (CQRS) 패턴이 있는 상황이죠.이제 한 걸음 더 나아가 보죠.만약 서비스 C가 여러분이라면 어떨까요?
우리가 그랬던 것처럼 결제금을 제출합니다.서비스 C 대신
상태를 요청하면 D는 상태를 C에 이벤트로 푸시합니다.이제 우리는 이런 종류의 이벤트 중심 영역에 진입하고 있는 거죠?그러니까 기다리기 보다는,
결제 완료 여부, 결제 이벤트 진행 여부, 서비스 C가 이에 대응하여 주문 배송 등을 수행할 수 있는 모든 결제 금액을 전송합니다.마찬가지로 서비스가 메시지를 대기열에 푸시하고 다른 서비스가 소비하도록 하는 것도 일반적입니다.여기서 요점은, 마치 여러분입니다.
이러한 마이크로서비스의 느슨한 결합 또는 분리가 보이기 시작합니다.이것이 비동기식의 기본 요소 중 하나입니다.
이벤트 기반 아키텍처.그렇다면 EDA란 무엇일까요?건축학적 개념이죠.
이벤트가 통신하고 일종의 호출 및 구현 패턴을 비동기식으로 수행하는 곳이죠.이제 간단한 것을 살펴보죠.
이벤트 기반 아키텍처에는 네 가지 주요 요소가 있습니다.다음은 간단한 아키텍처입니다.서비스는 퍼블리싱입니다.
버스 또는 브로커에서 두 명 이상이 소비한 이벤트
소비자 또는 대상 서비스, 그리고 그들은, 알다시피, 원래 있던 것을 그대로 이어갑니다.
해야 할 일이지요.네 가지가 있는데요,
제작자 또는 출판사, 그리고 소비자가 있거나
이벤트의 대상.그리고 가장 중요한 두 단계는
하나는 브로커나 버스, 그리고 물론 이벤트입니다.한 마디로 말하면
제작자 또는 출판사, 일반적인 개념은
업계는 마치 제작자가 필요로 하는 것과 같습니다.
소비자에 구애받지 않는 태도를 취해야 합니다.몰라야죠.자, SaaS 플랫폼 같은 것을 가지고 있다면 그건 사실입니다.하지만 일반적으로 만약
동료 팀 중에는 소비자가 뒤에 앉아 있습니다. 분명히 그들은 알게 되겠죠, 그렇죠?따라서 소비자들의 이해와 영향을 받을 수 있을 것입니다.하지만 일반적으로는 불가지론적이어야 합니다.그리고 또 다른 중요한 점은
이벤트를 보낼 때 전체를 다 챙기지 마세요.
필요한 것만 공유하세요.이것은 최소한의 데이터 권한, 아니 아시다시피 보안 측면과 동일한 공유 원칙과 같습니다.이건 실수입니다, 여러분, 여러분.
알다시피, 보통 팀들이 그러잖아요.소비자의 관점에서는 그들에게도 책임이 있습니다.따라서 항상 기대할 수는 없습니다.
이벤트가 순서대로 도착할 예정입니다.따라서 그들은 대처할 수 있을 것입니다.
알다시피, 주문이 들어왔고, 미안, 이벤트가 다가오고 있어
순서가 다릅니다.그리고 가장 중요한 것은 아이템 효능입니다.보장할 수 있는 것은 없습니다.
이벤트가 한 번만 전달될 때마다같은 유형의 여러 이벤트가 다시 올 수도 있습니다.따라서 이러한 상황을 방지할 수 있어야 합니다.이제 다음 단계로 넘어가겠습니다. 이벤트 브로커,
캐리어 또는 버스.바로 이 부분이 바로 이벤트브리지가 필요한 이유입니다.그리고 종종, 아시다시피
여러 프로듀서 또는 퍼블리셔로부터 이벤트를 인제스트한 다음 다른 쪽의 여러 타겟에 안전하게 전달할 수 있도록 지원합니다.중간에 둘 수도 있습니다.
규칙, 변환 기능을 제공합니다.
및 기타 기능.이제 이벤트브리지로 안내해 드리겠습니다.일반적으로 어떤 사람이 서버리스로 새로 시작하면 실험부터 시작하죠. 모든 것이 새롭기 때문이죠.
일종의 실험이 필요해요. 괜찮아요.그래서 계속 추가되는 것 같아요.
Lambda 함수부터 시작해 보세요. 아시다시피 계속 성장하고 있습니다.
서버리스 문제죠.하지만 문제는 헷갈린다는 거예요.SQS 대기열이 생기는 순간 동료는 이렇게 말할 것입니다. “안녕하세요,
이제 DLQ, 즉 데드 레터 대기열이 필요합니다.
모든 오류를 캡처하세요.”그래서 DLQ를 추가하죠.DLQ가 있으면
다른 사람이 “오, 오류 대기열에 오는 메시지는 누가 처리하겠어요?” 라고 말할 것입니다.이를 위한 메커니즘이 필요해요, 알겠죠?그래서 Lambda를 추가하는 거죠.
이 문제를 해결할 수 있는 함수입니다.이제 혼란스러우실 텐데요, 어떻게 해야 할까요?이벤트를 넣어야 할까요?
원래 대기열로 돌아갈까요 아니면 다른 대기열로 보내야 할까요?
데스티네이션 이벤트브리지?그래서 보통 이렇게 하죠.
아키텍처가 커집니다.갑자기 삼각형 모양의 이벤트 기반 아키텍처가 눈앞에 보입니다.여러분의 아키텍처는 “안녕하세요, 마이크로서비스, 아세요?” 라고 말할 것입니다.바로 이 점을 염두에 두셔야 합니다.좋아요, 마이크로서비스를 해봅시다.그런 다음 경계를 정하고 모든 서비스를 푸시합니다.
주변을 돌아다니다 보면 행복해집니다.하지만 문제는 당신이 노력한다는 것입니다.
하나의 마이크로서비스를 배포하면 다른 모든 것이 배포됩니다.그래서 우리가 가진 것은 긴밀하게 연결된 것입니다.
서비스 아키텍처.바로 이 부분이 바로 이벤트브리지가 필요한 이유입니다.따라서 마이크로서비스가 거의 없을 때는 모두 이벤트를 생성합니다.
각각의 경계 내에서 리소스를 넘나들며 이벤트를 공유하는 경우가 항상 있는 것은 아닙니다.
이벤트브리지, 이벤트 버스.그리고 이벤트는 다음과 같이 할 수 있습니다.
버스와 전체 사이를 오가는 길
상황이 크고 조화로워요.마이크로서비스는
독립적으로 배포할 수 있고, 아시다시피, 각각
따로따로, 다 괜찮아요.자, 이벤트브리지란 무엇일까요?그러니 익숙하지 않으시다면
그냥 이벤트 버스일 뿐인데 쉽게 갈 수 있어요.
이벤트가 발생하는 애플리케이션과 연결하세요.
퍼블리셔부터 타겟까지 말이죠.그렇죠, 그럼 EventBridge를 만드는 이유는 무엇일까요?핵심에는 세 부분이 있습니다.첫 번째는, 주요 부분인데요, 이벤트 버스죠.만약 여러분이 완전히 이해한다면
EventBridge를 처음 사용하는 경우, 돌아가서 AWS 콘솔을 확인해 보십시오.거기서 기본 이벤트 버스를 찾을 수 있습니다.이것이 바로 AWS 이벤트 버스입니다.모든 AWS 서비스는 푸시합니다.
이벤트는 기본 버스로 이동합니다.그런 다음 맨 위에 다음을 생성할 수 있습니다.
나만의 커스텀 이벤트 버스.그러면 AWS도 지원합니다.
파트너 이벤트 버스도 마찬가지입니다.그리고 한쪽에서는 메시지를 푸시하거나
이벤트는 이벤트 버스로 전달됩니다.다른 한편으로는 이러한 이벤트를 받는 소비자도 있습니다.하지만 제가 평소에 말씀드렸듯이 EventBridge의 성능은 그 사이에 있습니다.필터링 규칙과 라우팅 규칙, 바로 여기서 마법이 일어납니다.그곳이 바로 여러분이 식별할 수 있는 곳입니다.
좋아요, 이 목표물들을 찾아가서 공연을 하려면 이 이벤트가 필요해요.
이런 종류의 변환이나 로직 같은 것들이요.그러니까 일종의 거죠.
이벤트브리지의 핵심이죠.하지만 맨 위에는 몇 가지가 있습니다.
오피스 기능도 마찬가지죠.좋아요, 이제 살펴보죠.
이벤트 기반 아키텍처의 네 번째 주요 요소인 이벤트를 살펴보겠습니다.따라서 모든 이벤트는 그래야 합니다.
고유한 아이덴티티를 갖고, 앞서 말씀드린 것처럼 데이터만 가지고 다니세요.하지만 누군가가 이벤트 기반 아키텍처를 처음 접하는 경우에는 어렵습니다.
이벤트를 개념화하는 것.그렇기 때문에 이벤트를 디자인하는 데 시간을 할애해야 합니다. 그 중 일부는
여기서 팀들은 실수를 저지릅니다.이제 보통 이벤트 스토밍 세션에 갔을 때 가장 먼저 듣는 소리가 들립니다.
(불명료하게) “얘들아, 이벤트할 때는 과거형을 생각해 봐.”그런 건 상상하기 어렵지만, 그게 전부예요. 왜냐하면
과거에 무슨 일이 있었던 것 같아요.자, 이제 보시면
EventBridge 이벤트 스키마 패턴, 그러니까 여기까지입니다.그래서 이것에는 많은 것들이 있습니다.
그리고 가장 중요한 부분은 디테일 속성입니다.그래서 페이로드가 바로 그곳입니다.
데이터까지 들어갈 수 있죠, 알겠죠?그리고 어떤 것이든 제공할 수 있어요
거기에 유효한 JSON이 있습니다.하지만 시간이 좀 걸리면
구조조정을 생각하면 훨씬 쉬워질 거예요.원하는 대로 전부 또는 무엇이든 그냥 버리는 것보다는
팀 전체의 구조를 고려하거나
팀과 조직.그래서 나눠서 메타데이터와
데이터.메타데이터란 무엇일까요?메타데이터에서는
고유한 이벤트 ID, 고유한 이벤트 스키마 버전을 가지고 다니세요.어떤 도메인에서 내보내는 이벤트가 무엇인지, 어떤 서비스에서 오는지 말할 수 있습니다.
어떤 유형의 이벤트인가요?또한 TTL, 이벤트 기간을 지정할 수도 있습니다.
소비자가 보관해야 합니다.아시다시피, 상상력은 여러분의 것입니다.
여러분은 여러분의 조직입니다.그렇게 생각해 보세요. 그리고 나서
무언가, 구조가 어떻게 작용하는지 알잖아요.그리고 데이터 섹션은 기본적으로
데이터의 인스턴스.그러니까 특정 결제나 특정 주문, 보험 같은 것들이 여기에 들어가는 거죠.이제 두 가지 방법이 있습니다.
보통 이벤트를 분류하죠.논쟁의 여지가 있다는 건 알지만
하지만 기억해둘 만한 가치가 있어요.
필요에 맞게 조정하세요.카테고리의 경우 도메인 이벤트는 순수한 형태의 이벤트입니다.다음과 같은 이벤트가 바로 여러분에게 주어집니다.
내 도메인을 넘어 다른 도메인에서도 공유하세요
제한된 연락처 경계.아시다시피 이런 이벤트는 여러분에게 있어 좋은 이벤트입니다.그리고 운영 이벤트도 있습니다.이런 이벤트들은 이렇게 말하죠. “아, 이 제3자는
시스템이 가동 중이거나 다운됐어요. 지금 이 서비스는
경보를 울리거나 (불명료하게).”이런 종류의 내부적인
당신의 경계 안에서 조치를 취할 수 있도록 말이죠.그리고 물론
로컬 내부 이벤트는, 아시다시피 그냥 내부로 흘러가는 거죠.절대 경계를 벗어나지 않아요.그리고 변신,
변환된 이벤트는 소스 이벤트가 EventBridge로 들어오는 것처럼 익명성이 높은 이벤트와 같습니다.그리고 이벤트브리지는
이벤트 규칙의 일부로, 변화를 줄 수 있습니다.그러니까 보내는 것보다
데이터에서 나온 모든 것, 그러니까 그냥 이게 이벤트에서 나온 전부라고 하면
그냥 이게 데이터라고 말하는거죠. 왜냐면 아시잖아요
이 특정 대상에는 메타데이터가 필요하지 않습니다.이것이 바로 변환된 것입니다.
제 말로는 이벤트 말이지요.그리고 물론 당신도
AWS 이벤트도 있고요.따라서 AWS 이벤트를 제외하고
일반적으로 사용자 지정 이벤트로 호출하는 기타 모든 이벤트
이런 이벤트들이 저희 이벤트이기 때문에 저희는 대부분 생성하고 푸시합니다.
커스텀 이벤트 버스로.유형에 대해서는 다시 한 번 말씀드리지만
어떻게 분류하느냐에 달렸죠.데이터로 표시할 수 있습니다.
이벤트 또는 쿼리입니다.알다시피, 다시 돌아오게 되죠.
대답 아니면 답이요다시 말씀드리지만, 여기에는 딱히 정해진 규칙이 없습니다.어떻게 할지는 여러분에게 달렸습니다.
아시다시피 팀이 구조를 제대로 갖추는 데 도움이 됩니다.좋아요, 자, 간단히 요약해 볼게요.그래서 동시성과 이벤트 중심을 살펴보았고, 이벤트 기반 아키텍처인 요소들을 살펴봤습니다.
EventBridge가 제공하는 기능 및 구성 방법
이벤트도 다 괜찮아, 알겠지?다음 단계로 넘어가죠.그럼 기어를 바꿔서 살펴보죠.
이벤트 기반 패턴을 살펴봅시다.패턴에 관해서는
저는 이 인용문이 정말 마음에 들어요.왜냐하면 당신이 잘 알고 있다면
네 가지 디자인 패턴으로 구성된 오래된 갱단이나
그레고르 패턴, 밥스 패턴, 마이크로서비스 패턴,
수많은 패턴 북이 출시되고 있습니다.하지만 현대 건축의 핵심은 함께 작업할 때
서버리스 및 클라우드.많은 패턴이 숨겨져 있습니다.
여러분의 아키텍처 안에서 말이죠.예를 들어, 우리 대부분이 매번 사용하는 Amazon API Gateway를 예로 들어 보겠습니다. 그렇죠?API 게이트웨이를 아시나요?
그 자체가 패턴인가요?마찬가지로, 데드레터 큐인 DLQ도 사실 하나의 패턴입니다.
하지만 항상 사용하는 서비스가 있습니다.그리고 우리한테는 그렇지 않아요.
이걸 하나의 패턴으로 보세요.바깥쪽이 보입니다.
건축 패턴 맞죠?그래서 제가 계속 지켜야 할 이 코드가 마음에 드는 이유죠.
서버리스에서 패턴을 사용할 때는 염두에 두세요.다음 중 하나부터 시작해 보겠습니다.
기본 심볼 패턴, 안무, 쌍둥이예요.이것의 반대편은
하나는 오케스트레이션입니다.둘은 쌍둥이긴 하지만
완전히 달라요.그래서 그들은 서로 다른 일을 하죠.하지만 안무를 할 때
오케스트레이션은 하나로 합쳐지죠. 나중에 보시죠.
서버리스를 사용하면 놀라운 일을 할 수 있습니다.맞아요, 그래서 이름은 이런 안무 이벤트에서 유래한 거예요.그래서 안무를 할 때,
무용수가 한 명 또는 여러 명 있으면 언제 무엇을 해야 하는지 알고 있습니다.
곡이나 음악이 재생됩니다.지시할 필요 없어요.각각은 다음과 같이 작동합니다.
수행해야 할 단계.이제 예를 들어보겠습니다.주방 용품을 구입하셨으니 등록하고 싶으시다면
그리고 등록하면 로열티 포인트가 거의 안 나옵니다.
또한 다음 구매 시 할인을 제공합니다.그리고 알다시피, 그들은 고객에게 정보를 알려야 합니다.
모든 문제에 대해 서비스를 제공하고 제조업체에 알리십시오.단순하고 순차적인 것 같네요하지만 사물이 전부는 아닙니다.
이럴 필요가 있어요.로열티 포인트를 적립하려면 제품을 등록해야 하기 때문에 의존성도 있습니다.누군가 이메일을 보내려면 할인 코드가 필요해요, 알겠죠?그리고 동시에, 거기도
동시에 일어날 수 있는 일들도 있습니다. 충성심 같은 것들이죠.
포인트 계산 또는 할인 코드 생성
병렬로 일어날 수도 있고, 또 어떤 것들은
다른 것들도요.그렇다면 안무가 적용된 이벤트 기반 아키텍처에서는 이를 어떻게 확인할 수 있을까요?
이벤트브리지를 사용한다면?한 번 봅시다.그래서 앱이 하나 생겼습니다.이런 종류의 상호작용은 제품 등록 서비스와 상호작용합니다.그리고 제품 등록
서비스는 제품이 등록되었음을 알리는 이벤트를 발생시킵니다.갑자기 다른 점이 생겼습니다.
서비스가 활기를 띠고 있습니다.“아, 그렇게 하고 싶어요, 뭔가 하고 싶어요, 할 게 있어요
그 이벤트와 함께요.”이것이 바로 이벤트 중심의 방식입니다.
아키텍처는 현실입니다.그리고 EventBridge 타겟은 이러한 이벤트를 다른 서비스로 보냅니다.그런 다음 프로모션이 계산되고 나면 할인으로 생성된 이벤트가 나타납니다. 그러면 누군가가 나타납니다.
고객에게 보내는 데 관심이 있는 다른 사람
또는 고객에게 이메일을 보내세요.물론 당신도 있겠죠
아시다시피, 제조 시스템, 타사 애플리케이션
그것도 보내야 호출이 가능하죠.
특정 세부 사항을 포함해서요.그래서 그것도 할 수 있어요.
이벤트브리지 규칙을 사용해서 말이죠.그래서 여기서 할 수 있는 일은
API 목적지에 대해서는 나중에 설명하겠습니다.자, 이것은 간단합니다.
안무로 짜여진, 아시다시피, 이벤트 중심의 아키텍처죠.
아마존 이벤트브리지와 함께요.좋아요, 기억해 주셔서 감사합니다.이건 마치 코디네이션 같아요.각자에게 무엇을 하라고 지시하는 컨트롤러가 없는 것은 아닙니다.그리고 나서 그것을 분리시키죠.
디커플링을 할 수 있게 해주죠.그리고 원한다면 내일도
새로운 마이크로서비스를 생각해 보세요. 아주 쉽게 돌릴 수 있어요.
새로운 마이크로서비스를 개발하여 전체 에코시스템의 일부로 만드세요.그리고 아이템 효능, 그리고
앞서 말씀드렸듯이, 추적력을 추가하는 것이 관찰성에 중요하죠.
속성, 즉 값을 추적하고 값을 모두 가져오는 거죠.
통과하는 과정이 매우 중요합니다.좋아요, 이제 가세요
개발자 컨퍼런스가 열리면 “코드는 책임이야.” 라고 말하겠죠.거기 있는 건지 궁금하네요.이해가 안 돼요, 전
금전적 책임은 알지만 법규란 바로 책임입니다.다음 세션으로 넘어가면 사람들은 이렇게 말합니다. “여러분이 작성한 코드는 내일의 유산입니다.”여러분은 이렇게 생각하실 겁니다. “좋아, 됐어.내 일은 끝났어. 왜냐면 난
아무것도 프로그래밍할 수 없어요.”그리고 마지막 세션에 가면 베르너 같은 사람에게 이렇게 말할 거예요. “지금까지 작성한 코드는
비즈니스 로직이죠.”그게 전부라고 생각하시겠죠.비즈니스맨, 이해관계자
인수인계로 제 일은 끝났어요꼭 그렇지는 않아요.이것이 의미하는 바는, 하지 말라는 것입니다.
불필요한 프로그래밍이나 구현을 하세요, 알겠죠?왜요?쓰기 함수를 줄이면 많은 이점이 있습니다.따라서 코드가 적고 보안이 약해집니다.
걱정과 걱정이 많지만 디버깅의 번거로움과 온갖 종류의 것들이 도움이 됩니다. 아시다시피
아마도 비용이 많이 들 수도 있습니다.그래서 여기가 바로
다음 패턴은 기능이 없는 통합 패턴입니다.지금은 로우코드, 코드리스, 이런 용어로도 알려져 있지만 개념은 같습니다.즉, 필요 없을 때는 불필요한 사용자 지정 함수를 작성하지 않아도 됩니다.그렇죠, 그럼 함수가 없는 것은 무엇일까요?그러기 위해서는 이해가 필요합니다.
완전한 기능이란 무엇입니까?분명 만나보신 게 틀림없어요
이 패턴 아키텍처는 둘 다 수백 번 반복되었죠.이제 Lambda 함수를 보면 그 역할이 무엇인지 알 수 있을 것입니다.비즈니스 로직을 수행하고 있는 건가요, 아니면 변화를 일으키고 있는 걸까요?
API 페이로드의 데이터가 대기열로 전송되나요?데이터를 그냥 옮기는 것이라면
그렇다면 이건 강점이 아니죠.Lambda 함수는 컴퓨팅입니다.구현 등을 위해서는 로직이 필요합니다.그러니까 이 부분이 무함수가 될 수 있는지 생각해봐야 할 부분이죠.그러니까 하는 것보다는
함수를 만들면 “아, 네이티브 통합을 사용해서 같은 결과를 얻을 수 있을까?” 라고 생각하시겠죠.그리고 이것이 여러분이 함수없는 사고의 출발점이라고 할 수 있습니다.이제 API Gateway를 생각해 보면 여러 AWS 서비스를 통해 40개 이상의 통합을 지원합니다.그리고 죄송해요. 그리고
단계 기능은 특히 SDK 통합을 통해 필요 없이 서비스와 직접 상호 작용할 수 있는 많은 기회를 제공합니다.
Lambda 함수를 작성하기 위해서입니다.그리고 작년 re:Invent에서는 이벤트브리지 파이프가 발표되었습니다.다시 말씀드리지만, 일종의
변환을 수행하고 대상과 연결할 수 있는 일대일 파이프라인입니다.
대부분의 경우 글을 쓰지 않고도 서비스를 이용할 수 있습니다.
Lambda 함수, 알겠죠?이제 예를 들어보죠.등록하는 사람
예를 들어 온라인 시스템 계정을 만들면 개인 데이터를 추가하고 결제 세부 정보를 제공합니다.그리고 요즘에는 여러분도
동의서를 캡처해야 합니다.이메일을 통해 연락할 수 있는지 여부, 홍보를 받을 수 있나요?
물건 등등.그래서 대부분의 비즈니스는
그들의 강점이 아니기 때문에 그들은 보통 a를 사용합니다.
타사 응용 프로그램은 다음과 같은 경우에만 데이터를 전송합니다.
반드시 세부 정보를 쿼리하고 다시 가져옵니다.그리고 보통은
호출할 수 있는 API가 있으면 데이터를 보내기만 하면 됩니다.다른 건 기대하지 않으실 겁니다.이것은 고객이 등록할 때 발생할 필요가 없기 때문에 비동기식 호출입니다.알다시피, 배후에서 일어날 수 있는 일이죠.그리고 API도 제공되었죠.
할당량도 있고, 할당량도 다를 수 있습니다.
인증 메커니즘, 공개 인증 또는 기타 메커니즘.따라서 구현을 생각할 때
이것은 아키텍처이므로 간단한 API를 사용할 수 있습니다.
게이트웨이는 아시다시피 승인으로 돌아옵니다.
뒤로 돌아가서 세부 정보를 대기열에 푸시한 다음
파이프가 있을 수도 있습니다.그리고 논리적으로 말하자면,
스텝 함수라고 해봅시다.따라서 단계 함수 워크플로에는 사물에 따라 단계가 달라집니다.그리고 Lambda도 있습니다.
다음을 수행하는 데 전념하는 함수입니다.
타사 애플리케이션.다 괜찮아 보여요.
여기선 아무 문제 없어요.자, 이제 어떤 일이 벌어질까요?
어느 날, 시스템이 다운되었거나 네트워크 연결이 불안정합니다.따라서 이 문제를 해결하려면 이제 아키텍처가 필요합니다.
데드 레터 대기열이 제자리에 있습니다.대기열이 생기면 어떻게 처리해야 하는지도 알아야죠, 알겠죠?그래서 복잡성이 더 커지죠.
아키텍처에 적용하세요.자, 아시다시피 이곳이 바로 기본 통합 기능 중 하나입니다.
이벤트브리지가 등장하는데, 이것이 바로 API 목적지입니다.이벤트 버스에 이벤트를 보내면 이벤트 버스에는 대상 규칙이 있고 여기서 대상은
타사 시스템의 엔드포인트에 도달하는 API 대상.이제 API 목적지란 무엇일까요?이제 API 데스티네이션, 그리고
죄송합니다. 이 Lambda 함수에 대해 살펴보도록 하겠습니다. 함수가 없는 함수의 관점에서
개념에 대해 방금 논의했습니다.뭘 할 수 있겠어요?
이 Lambda 함수는 단계 함수를 사용하여 변환을 수행하는 경우에만 수행합니다.
내장 함수, 뭐 그런 거?그러면 다음을 얻을 수 있을지도 모릅니다.
Lambda 함수를 완전히 없애고 그냥 단계적으로 이벤트를 버스로 내보내세요.다시 말씀드리지만, 이건 일종의
미세 조정이나 아키텍처, 꼭 사용하세요
구축에 따른 최적의 접근 방식 또는 패턴
서버리스 애플리케이션.이제 API 목적지란 무엇일까요?API 목적지는
기본적으로 대상이 되는 HTTP 엔드포인트입니다.
이벤트브리지 규칙.그리고 이를 사용하여 다음을 수행할 수 있습니다.
송신 또는 작업 방식이 무용지물입니다.
당신의 외부 목표물이죠.따라서 일반적으로 고객이 등록한 이벤트는 이벤트 버스로 들어옵니다.필터를 통해 알 수 있는 필터가 있습니다. 자, 이 고객이 바로 이 고객이죠.
알다시피, 등록된 이벤트.그래서 뭔가 해야겠네요.어쩌면 당신은 하고 있을지도 모릅니다.
이벤트 변신 같은 건, 아시다시피
API 데스티네이션에 전달하죠.따라서 API 데스티네이션은 두 부분으로 구성되어 있으므로 연결이 필요합니다.여기서 모든 인증, 자격 증명 등이 이루어집니다.그리고 분명히 모든 헤더가 포함된 엔드포인트가 있습니다.
그리고 모든 종류의 것들도요.그리고 그게 가능하죠, 알다시피,
최종 목표, 즉 외부 애플리케이션 또는 다른 서비스에 도달합니다.
다른 도메인에서이제 구조를 보여드리면
API 데스티네이션의 연결과 비슷합니다.
그리고 대상 HTTP 엔드포인트.그리고 연결을 살펴보면 EventBridge는 이 세 가지 형식을 지원합니다.있는 사람이 있는지 잘 모르겠습니다.
여전히 기본 인증을 사용하고 있지만, 이미 있습니다.그리고 API 키 메커니즘, 그리고 물론 OAuth
EventBridge가 보이지 않는 곳에서 처리할 수 있도록 토큰 자격 증명을 제공할 수 있는 곳입니다.그리고 엔드포인트 측에서는
모든 고객 엔드포인트와 EventBridge에 연결할 수 있습니다.
파트너 엔드포인트도 마찬가지입니다.정말 멋지네요. 만약
함께 일하는 파트너 중 한 명이 EventBridge, 목적지 파트너 제도의 일원입니다.
정말 간단하고 쉬워집니다.자, 이게 API 데스티네이션입니다.중요한 점 중 하나는
목적지는 자격 증명이며, EventBridge는 다음을 보관합니다.
자격 증명은 시크릿 매니저에 있습니다.시크릿을 들을 때
매니저, 아마 “아, 비용이 많이 들 것 같아요.” 라고 생각할 수도 있습니다. 왜냐하면 모든 비밀은
한 달에 40센트, 그다음에 API 호출
비용 등등.좋은 소식은, 어쨌든
이 기도가 몇 번이나 있었는지 모르겠지만
수백만 번, 수십억 번
이벤트브리지는 비용을 소모합니다.따라서 우리는 비용을 지불하지 않습니다.
시크릿 매니저는 스스로 비용을 지불합니다.이벤트브리지에서 모두 소모됩니다.그런 다음 요금을 추가할 수 있습니다.
제한 및 재시도를 지원합니다.기억해야 할 또 다른 사항은 제한 시간이 5초라는 점입니다.목표물이 오래 걸리면 목표물은 떨어지죠.
재시도 모드로 들어가세요.그리고 얼마 전에 블로그를 작성했었죠.그 내용은 바로 당신에 관한 것입니다.
우리가 이걸 어떻게 할 수 있는지 좀 자세히 설명해 드리죠.좋아요, 그럼 다음으로 넘어가죠.신뢰할 수 있는 애플리케이션을 생각하면 복원력이 떠오릅니다.
고가용성, 모든 종류의 것들이요.이는 다음과 같은 경우에 매우 중요합니다.
서버리스 및 이벤트 기반 아키텍처, 특히 분산형 아키텍처의 경우
마이크로서비스와 사물.그리고 우리가 할 수 있는 다양한 방법이 있습니다.그리고 왜 이 모든 것들이 필요할까요?왜냐하면 방금 보여드린 것처럼
이전 사례에서는 네트워크 연결이 불안정할 수 있습니다.그리고 시스템이 다운될 수도 있습니다.
유지보수를 위해서든 뭐든그러면 교통 패턴이 다양해져서 모든 사람을 완전히 억압하고 전체를 무너뜨릴 수 있습니다.그러니까 이 모든 것이 궁극적인 것이죠.
제작 환경은 거의 매일.이것이 바로 우리가 모든 기능을 다음과 같이 구축해야 하는 이유입니다.
이러한 솔루션을 설계할 때 아키텍처의 일부입니다.패턴 중 하나는
우리가 사용할 수 있는 아주 일반적인 패턴은
이벤트 브로커 패턴.하지만 제가 여기서 할 일은
이벤트 브로커에 대해 설명해 주세요. 죄송합니다. 이벤트 브레이커 패턴을 설명해 주세요.또한 어떻게 할 수 있는지 추가하겠습니다.
재시도 메커니즘을 사용하여 실패를 해결할 수도 있습니다.따라서 회로 차단기를 처음 접한다면 전기 회로에서 나온 개념일 뿐입니다.그러니까 회로는 닫힐 때
모든 게 순조롭게 진행되죠.자, 여기 초록색이
화살표는 닫혔고, 모든 것이 만족스럽고, 200 괜찮다는 뜻입니다. 클라이언트까지 가는 거죠.동기식 호출이네요. 만족합니다.그러니까 개방회로 상황에서는
같은 종류의 패턴인데 문제가 있습니다.
목표에 도달하는 거죠.목표물이 쓰러졌거나 무슨 일이 생겨서 목표물에 도달할 수 없죠.이제 회로가 열려 있는 것으로 표시되었으니, 그렇지 않다는 뜻입니다.
목표에 도달하려고 하지만 실패 또는 오류 응답을 클라이언트나 소비자에게 반환합니다.그러니까 이건 마치
두 가지 공통점이 더 있습니다.그리고 반은 열려 있는 것도 있지만, 단순하게 하기 위해 당분간은 그대로두자.자, 자, 서킷 브레이커,
저는 보통 이걸 매니저라고 부르는데, 왜냐면
우리의 구현에서 매니저의 책임은 회로를 언제 선언해야 하는지를 아는 것입니다.
열린 상태로, 언제 닫아야 하는지, 왜 닫아야 하는지, 왜냐하면 응용 프로그램은
요청으로 무엇을 할지 결정하기 전에 이 상태를 참고하세요.아주 간단하게 할 수 있는 일은 상태를 저장할 수 있다는 것입니다.
알다시피, 대상 시스템의 엔드포인트에 저장한 다음 상황에 따라 조치를 취하거나 대응합니다.예를 들어, 세 번째 코드를 호출하기 전에 먼저 를 확인합니다.
당사자는 상태를 확인합니다.그래, 문을 닫았으면 가도 돼좋아요, 전화할게요.그리고
그러면 끝입니다.그리고 또 다른 요청이 들어왔고, 괜찮은지 확인하면
하지만 맞히려고 하면 처리되지 않는다는 걸 알 수 있죠.회로는, 왜냐하면
어째서인지, 열려 있어요.그래서 무슨 일이 일어나냐면 업데이트를 하게 되죠.
스테이터스 저장소에서 “아, 잠깐만요, 문제가 생겼어요.” 라고 말하죠.그럼 이걸 언제 이렇게 선언해야 하는지 알 수 있는 논리가 있잖아요.
아시다시피, 개방 회로죠.즉, 오류 응답이 되돌아가서 시스템이 그런 것들을 알아서 처리해 준다는 뜻이죠.넌 그런 사람이 아니야, 넌
알다시피, 목표물이 살아 돌아오길 기다리다 보면, 대기 시간이 길어지는 거죠.
요청이나 그런 것들 말이에요.따라서 애플리케이션이나 로직이 언제 폐쇄형 또는 개방형으로 선언할지 결정할 때는 보통 특정한 사항을 기반으로 합니다.아마도 다음과 같이 선언하지는 않을 것입니다.
아, 알다시피, 요청이 들어오자마자 회로가 폐쇄되는 거죠.시도해 보는 것이 좋을 수도 있습니다.
짧은 기간 내에 5건 또는 10건의 요청을 처리하세요.자, 이것은 여러분의 일부분인데요.
서킷 매니저의 로직.그러니까 일종의
보통 여러분이 설정하는 기준이지요.이것이 간단한 방법입니다.이제 한 단계 더 나아가면 이것을 서비스로 구축할 수도 있습니다.예를 들어, 많은 시스템에서 사용하는 중요한 타사 또는 외부 애플리케이션이 있습니다.
이때 사용할 수 있는 일은 전용 상태 검사기를 설정하는 것입니다.따라서 간단한 스케줄러를 한 번에 실행할 수 있습니다.
글쎄요, 잘 모르겠지만, 1~2분에 한 번씩, 하트비트를 재생하는 식이죠.
외부 응용 프로그램을 사용하여 상태를 설정합니다.
예를 들어 Dynamo DTB 테이블을 들 수 있습니다.그리고 업데이트가 발생할 때마다
테이블은 이벤트, 스트림 이벤트를 내보냅니다. 핸들러가 있는데 이걸 찾고 있거나
앞으로 이 모든 것을 캡처할 예정입니다.그리고 이 사람은 기본적으로 매니저입니다. 왜냐하면 이 사람이 지위를 받기 때문이죠.
업데이트되는 대로 업데이트됩니다.그러면 언제 하는지를 결정할 수 있습니다.
상태를 변경하려면, 예를 들어, 제가
아까 말씀드렸죠.혜택은 동일한 관리자에게 제공됩니다.
다른 장소를 업데이트할 수 있습니다.예를 들어 SSM 파라미터 스토어 속성에 항목을 보관할 수도 있습니다.따라서 경계 내에 있는 경우 서비스에서 SSM을 확인할 수 있습니다.
파라미터로 상태를 확인할 수 있습니다.아니면, 다른 마이크로서비스나 다른 애플리케이션이라면
이벤트를 내보낼 수 있습니다. 아시다시피 운영 이벤트는
앞서 말씀드린 이벤트입니다.소비할 수 있게 말이죠.
다양한 애플리케이션에서 상태 세부 정보를 다시 얻을 수 있습니다.물론 다음과 같은 방법도 가능합니다.
Dynamo 테이블에서 관련 필드를 간단히 쿼리할 수 있는 API 게이트웨이 엔드포인트를 연결하고
상태를 다시 보고하세요.이것은 단순한 서킷 브레이커 구현을 발전시키는 것과 같습니다.물론 다음과 같은 것들이 있습니다.
방법은 다양하지만 이건 뭔가, 당신
알다시피, 이런 종류가 있다면 실험해 볼 가치가 있습니다.
사용 사례가 마련되어 있습니다.자, 말씀드렸듯이
소비 당사자마다 다른 방법이 있습니다. 특히 자신의 계정 내에서, 한정된 상황 내에서 말이죠.
특정 물건들을 사용할 수 있습니다.외부에 있는 것이라면,
이벤트나 API를 통해 진행되므로 모든 것이 단순하고 깔끔해집니다.자, 흔하게 볼 수 있는 것 중 하나는
회로 차단기가 있으면 빨리 고장날 수 있습니다.그러니까 회로를 만든다면
열려 있으면 갈 수 없어요. 바로 실패하죠.그건 당신이 아니란 뜻이에요
리소스를 계속 사용하다 보면 지연 시간이 늘어납니다.이를 위해 간단한 서비스 확인, 서비스 상태,
그리고 무엇을 할지 결정하세요.그러니까 그냥 오류로 되돌아가는 거죠.단순하고 가장 흔한 것이죠.
찾으실 수 있는 케이스입니다.그리고 대부분의 경우 괜찮습니다.하지만 문제는 처리하느냐, 고객의 물건이냐에 있습니다.
주문을 직접 하고 나서 그냥 뒤로 물러나서 “미안해요, 아무것도 할 수 없어요.” 라고 말할 수는 없습니다.알다시피, 데이터를 가지고 다운스트림에 다시 제출해야 합니다.
고객이 주문을 받을 수 있도록 신청서를 제출하세요.
배송 등등.그래서 여기가 바로 우리가
먼저 실패하는 게 아니라 리플레이 매커니즘을 제대로 갖춰야 한다는 것을 생각해야 합니다.그럼 이 경우에는 어떤 일이 벌어질까요?
마치 실패했을 때 반대편으로 갈 수 없을 때 어딘가에 글을 쓰는 것과 같습니다.
실패 요청을 작성하면 회로가
돌아왔으니 다시 플레이할 수 있습니다.세 가지 일반적인 방법, 이 기능을 구현할 수 있는 가장 일반적인 두 가지 방법은 다음과 같습니다.
하나는 SQS 대기열을 사용하는 것이고, 다른 하나는 DynamoDB 테이블 기반입니다.
쿼리 요구 사항 및 액세스 패턴 등을 기반으로 합니다.이제 사용할 수 있는 세 번째 옵션은 EventBridge 아카이브 및 리플레이입니다. 알겠죠?네, 제 곁에 있어주세요.아카이브와 플레이가 처음이라면 조금 더 까다로울 거예요.이제 EventBridge 아카이브 앤 플레이란 무엇일까요?필터를 설정하는 방법처럼 간단하지만 이벤트 패턴을 식별한 다음 “이러한 이벤트를 EventBridge 아카이브에 보관하고 싶습니다.” 라고 말하기만 하면 됩니다.그래서 그들은 이 아카이브로 가서 얼마나 오래 걸리는지 여러분이 결정합니다.
아카이브에 보관해야 합니다.그러면 다시 플레이할 수 있습니다.
아카이브의 이벤트, 특정 이벤트, 당신은
알다시피, 이 시간부터 이 시간까지의 기간 동안요.좋아요, 어서, 이 특정 아카이브의 이벤트를 다시 재생해 보세요.그러니까 이건 간단한 메커니즘이에요.
하지만 정말 유용하고 여러 상황에서 도움이 되죠.자, 아시다시피, 간단하죠.
뭐랄까, 상태 점검을 하고 나서 뭘 해야 할지 생각하게 되죠.그래서 가끔은 유용할 때가 있습니다. 특히 이벤트 작업을 할 때 이런 기능이 있으면 더욱 그렇습니다.
특정 항목의 상태를 이벤트에 반영하세요.예를 들어, 성공한
제출 또는 호출은 200입니다. 좋아요, 좋아요.
아무도 질문하지 않을거야.하지만 데이터 때문에 오류가 난다면
문제, 검증 문제, 이를 하드 오류로 분류할 수 있습니다.하지만 상황은
여러 번 다시 제출해도 처리되지 않을 것입니다.
그건 네 문제니까 데이터에 문제가 있는 거잖아세 번째 유형은 복구 가능한 상태입니다.그래서 제 3자가 다운되거나 500 서비스 제공자가 생기면
등등.수집이 필요해요.
그런 것들 하고 다시 시도하세요.그러니까 이런 걸 할 수 있다면 유용하겠죠.
이벤트를 분류하세요.아시다시피, 다음과 같이 하면 도움이 됩니다.
리플레이 아카이브 매커니즘이죠.그러니까 이건 좀 간단하죠.
제가 말씀드린 메타데이터입니다.그럼 현황과 함께 보여드릴게요.이제 상태를 기반으로 EventBridge에서 규칙을 설정할 수 있습니다.따라서 이벤트브리지는 다음과 같이 할 수 있습니다.
검색 가능한 상태 이벤트를 캡처하여 아카이브에 푸시하는 규칙이 있습니다.이 규칙은 일반적인 필터링된 규칙과 같습니다.물론 상황은 다양하겠지만 이런 종류의 기본적인 것은요.이제 아카이브 생성은 간단합니다.여러분에게 필요한 것은, 알다시피, 많은 구름이 형성되는 것뿐입니다.
스크립트, 아니, 다른 방법들
필터 패턴으로 말이죠.그게 설정되는 방식이죠.이제 아카이브에서 이벤트를 재생하고 있으니 이제 내용을 가져왔습니다.이제 네 상태가 네 신분이 됐어
이제 시스템이 돌아왔어요.그러니까 당신에겐 일종의 방법이 있습니다.
이벤트들이 계속 흐르고 있어요.로직 구현자와 Lambda 핸들러를 사용할 수 있습니다.
알다시피, 알다시피, 이게
지금은 이 특정 아카이브에서 다시 재생해 봐야겠네요
이 모든 게 설정 방식의 일부이기 때문이죠.그러면 이렇게 말할 거예요. “좋아요,
지난번에 다운됐었죠.제 말은, 이 지점이 여기 있으니 다시 플레이해 봐야겠네요.
이 시점부터 이 시점까지의 사건들.”그럼 이벤트브리지는
해당 이벤트를 재생하고 해당 이벤트를 다시 동일한 버스로 푸시하면 핸들러가 이벤트를 처리하도록 할 수 있습니다.여기서 한 가지 눈치채셨을 텐데요.
강조 표시된 것은 리플레이 이름입니다.이벤트 구조의 일부가 아니었다고 생각하실 수도 있습니다.따라서 AWS는 이유가 있는 이벤트를 재생할 때 이 속성을 이벤트에 추가하므로 차별화할 수 있습니다.
원래 이벤트의 리플레이 이벤트 및
이런 주기적 이벤트 진행을 피하세요.이는 매우 중요하며 다음과 같은 작업을 수행할 수 있습니다.
일종의 리플레이 이름을 설정해서 다음과 같이 설정할 수 있게 하는 거죠.
그에 따라 패턴을 필터링하세요.네, 그럼 핵심 포인트는
현재로서는 EventBridge와 마찬가지로 주문 보장이 없습니다.그리고 속도는 없습니다.
속도를 조절하는 방법.다시 플레이할 때는 그냥 친절하게
알다시피, 모든 걸 밀어붙이는 거죠.따라서 이를 충족하기 위해서는 다운스트림에 버퍼링이나 큐잉 메커니즘이 있어야 합니다.지금은 보통 추천하고 싶은 게 많아요.
세분화된 아카이브.전 세계로 진출하지 마세요.
아카이브하고, 모든 걸 버리세요.하나의 아카이브를 보관하기만 하면 됩니다.
그 특정한 목적이 도움이 되잖아요.
우리가 아카이브를 관리하고 관리하는 데에는 많은 부분이 필요하죠.또 다른 중요한 점은 아카이브를 푸시한 마지막 이벤트 사이에 지연이 있다는 것입니다.
다시 재생해 볼 수 있습니다.보통은 그렇죠.
최신 이벤트가 시작되기 5분 이상 남은 시간
아카이브에 저장된 내용을 다시 재생할 수 있습니다.그러니 이 점을 명심하세요. 사용 사례가 괜찮다면
그렇게 하는 것이 가장 좋은 방법입니다.다시 말씀드리지만, 저는 이 모든 것들을 자세히 설명하고 살펴보는 블로그를 운영하고 있습니다.좋아요, 다음 중 하나로 넘어가죠.
또 다른 눈에 띄는 패턴은 오케스트레이션입니다.이것이 바로 이 곡입니다.
(불명료) 제가 말씀드렸어요.이제 오케스트레이션을 활용하면
다시 말씀드리면, 아시다시피 이 이름은 오케스트라에서 따온 것입니다.컨트롤러는 항상 있잖아요, 그렇죠?무엇을 해야 하는지, 오케스트라의 어느 부분을 맡아야 하는지 등을 지시하는 거죠.여기에도 비슷한 개념이 있습니다.그래서 보통 오케스트레이션이라고 하면 바로 AWS Step Functions라고 하죠.
한 가지 예를 들어보죠. 일종의
국가 선교 오케스트레이션.제가 보통 얘기하는 건
오케스트레이션에는 세 가지 유형이 있습니다.유지가 전부입니다
단순하고 깔끔한 것: 서비스 내 오케스트레이션,
크로스 서비스 및 분산.분산 및 크로스 서비스
비슷한 점이 있습니다.제가 어떻게 차별화하는지 보여드릴게요.현직 근무는 간단합니다.도메인이 있다고 가정해 봅시다.
마이크로서비스가 있고 단계 함수도 있습니다.도메인 수준에서 유지해 봅시다.경계 컨텍스트로 넘어가지 마세요.괜찮아, API야, 알다시피
step 함수를 호출합니다.몇 가지 로직을 수행합니다.여기 보면 모든 게 다 있어요
그 마이크로서비스 안에서 말이죠.상자 밖으로 나가는 화살은 없습니다.그러니까 이건 현재 진행 중인 이벤트입니다.완벽하고 간단한 양식입니다.의존성은 없어요.
하드 와이어링 등은 필요 없습니다.따라서 크로스 서비스 측면에서 보면 이벤트, 오케스트레이션의 범위를 약간 넓히고 있습니다.자, 여기 비슷한 서비스가 있긴 하지만 아직 도달해야 할 부분이 있습니다.
도메인 내의 다른 마이크로서비스나 다른 도메인에도 적용할 수 있습니다.그래서 주로 API 호출을 통해 도달하는 거죠.따라서 일반적으로 다음과 같은 상황이 발생합니다.
Lambda 함수가 이 작업을 수행합니다.하지만 최근 마지막 날
그래서 Step Functions와 같은 새로운 기능이나 발표가 있습니다. 이제 HTTP 타겟에 직접 도달할 수 있습니다.다시 한 번 말씀드리지만
쓸모없는 삶은 단순하고 쉽습니다.맞아요, 이건 크로스 서비스 같아요.다음으로 넘어가겠습니다. 바로 분산 오케스트레이션입니다.이제 개념을 설명하기 위해 세 가지 영역을 소개하겠습니다.계속 말씀드리죠. 아마 이거겠죠.
헷갈릴 수도 있겠지만, 저를 따라오세요.도메인이 세 개이고 각 도메인이 있다고 가정해 봅시다.
세 개의 마이크로서비스.예를 들어, 도메인 A는
컨트롤러 또는 기본 오케스트레이션의 일종입니다.예를 들어, 잘 모르겠지만, 보험 청구 처리를 생각해 보세요. 왜냐하면 거기 있기 때문이죠.
법조인이 들어오거나 자동차 딜러나 제조업체 등등.그러니까 일종의 방법이 될 수 있겠죠.
복잡한 과정이죠.이제 여기서 작업 2에 필요한 것이 있다고 가정해 봅시다.
서비스 B에서 작업을 수행하므로 완료하는 데 몇 시간이 걸릴 수 있습니다.그리고 다른 한편으로는
기본 오케스트레이터에서는 다른 서비스에 연결하는 다른 작업이 있습니다.완료하는 데 몇 주가 걸릴 수 있습니다.따라서 이제 메인 오케스트레이터는 답을 얻을 때까지 기다려야 합니다.
아시다시피 이런 다양한 서비스를 통해서 말이죠.그냥 오케스트레이션 워크플로우로 보여드리는 것일 수도 있지만, 그럴 수도 있겠죠.
다른 구현도 마찬가지죠.이제 어떻게 할 수 있을까요?이것이 바로 오케스트레이션과 안무가 함께 어우러지는 곳입니다.그래서 할 수 있는 방법은
A2가 스텝 함수의 태스크 토큰인 태스크 토큰으로 이벤트를 푸시하는 것과 같습니다.즉, 안에 있는 토큰은
이벤트는 서비스로 이동합니다.마찬가지로, 다른 패널 알람에 있는 다른 서비스의 경우 다른 이벤트가 진행됩니다.
다른 토큰을 가지고 나가세요.그리고 이 작업들은 각각의 토큰이 나올 때까지 기다려야 합니다.
step 함수로 돌아오세요.그러면 토큰이 다시 돌아옵니다.명확성을 위해 여기서는 이벤트 버스나 EventBridge의 종류를 보여드리는 게 아닙니다.그럼 이벤트가 다시 돌아오죠.
그리고 과제는 앞으로 나아갑니다.그때까지는 그냥 그 자리에 있을 거예요.이해를 돕기 위해 조금 더 자세히 설명하겠습니다.따라서 태스크는 토큰과 함께 이벤트를 내보내고 EventBridge로 이동합니다.
그리고 마이크로서비스 C라는 소비자가 있습니다. 그리고 마이크로서비스 C가 소비한다는 건 알다시피
좋아요, 이벤트가 있어요. 토큰이 있어요.
토큰을 보관하고 EventBridge로 돌아가는 제 응답에 토큰을 다시 보내기 위해서죠.그리고 EventBridge, 이 마이크로서비스 CA는 해당 이벤트를 토큰과 함께 사용합니다.따라서 해당 이벤트를 처리하는 핸들러가 있고 핸들러는 다음을 제출합니다.
단계 함수에 토큰을 보내면 단계 함수가 계속 실행됩니다.그럼 대략 다음과 같습니다.
태스크 토큰 메커니즘은 정말 강력합니다.아직 시도하지 않으셨다면 제가 해봤을 거예요
한 번 시도해 보는 것이 좋습니다.정말 멋져요.표준 상태 머신에서만 지원되기 때문에 스텝은 현재 작동합니다.자, 이제 괜찮습니다.자, 이제 이벤트를 어떻게 추가할까요?
버스에 토큰을 달고?정말 간단해요.업무의 일부로서
WaitForTaskToken이라는 것이 있습니다.그러니까, 당신 같은 거네요
당신이 내뿜는 걸음걸이는 그대로 남아 있을 거예요
토큰이 돌아올 때까지.그런 다음 토큰을 주입할 수 있습니다.
태스크 토큰을 호출해서 말이죠.그러니까, 뭐, 당신은
스텝 함수는 구조체죠.어떤 속성에든 첨부할 수 있습니다.꼭 그럴 필요는 없습니다.
태스크 토큰 속성.어떤 속성이든 호출할 수 있어 소비자가 이 속성에 토큰이 포함되어 있다는 것을 알 수 있습니다.영광스럽게 생각하고 돌아와야겠네요네, 그럼 핵심 포인트는
배포 측면에서요.따라서 여러 태스크 토큰을 사용할 수 있습니다.모두 고유합니다.아시다시피, 사용할 수 있습니다.
SQS나 SNS 등등.예를 들어, 다른 서비스의 단계 함수를 보여드렸는데
하지만 무엇이든 될 수 있습니다.그리고 타임아웃, 심장 박동
이해는 중요합니다.배출을 하면 어떤 일이 벌어지나요?
토큰, 타이머를 설정하세요.예를 들어 20시간을 기다리고 싶어요.만약 토큰이 없다면
20년이 지난 후에 다시 돌아오세요. 작업 시간이 만료될 거예요.바로 이 부분에서 앞서 언급한 재시도 상태 메시지가 도움이 됩니다.
그러면 토큰 핸들러가 하트비트를 이해하고 증가시킬 수 있기 때문입니다.따라서 시간이 안 걸리고 더 오래 기다려서 시간이 남습니다.
다른 서비스가 완료되고 토큰이 다시 돌아와야 그 다음 단계로 넘어갈 수 있습니다.따라서 성공 또는 실패를 말할 수도 있고, 앞서 말씀드린 것처럼 연장할 수도 있습니다.
타임아웃도 마찬가지죠.다시 말씀드리지만,
관심이 있다면 팔로우할 수 있는 블로그입니다.그리고 마지막 하나는 한정되어 있습니다.
우리 모두 알고 있는 상황이죠, 그렇죠?도메인 기반 설계 경계 컨텍스트.이제 우리 중 API처럼 이벤트의 경계를 존중하는 사람이 얼마나 될까요?API에는 페이로드 계약, 보안 등 모든 종류의 것들이 있습니다.
등등.하지만 만약
이벤트, 우린 너무 느긋해요.그냥 여기저기서 이벤트를 보내죠.이것이 바로 우리가 사용할 수 있는 패턴입니다. 저는 이것을 게이트키퍼 패턴이라고 부릅니다.그래서 이것은 일종의 방법입니다.
도메인이나 제한된 컨텍스트 경계를 보호하는 거죠.설명을 드리자면, 예를 들어 마이크로서비스가 많이 있는 결제 처리 시스템이 있습니다.내부 버스가 있는데
모든 이벤트가 유입되긴 하지만 언젠가는 이런 일이 필요하죠.
특정 세부 정보 및 호출을 외부로 보내기
대상 또는 애플리케이션.따라서 금융 영역에는
도메인 이벤트를 예로 들 수 있습니다.그리고 나면
일부 데이터 전송을 요청하는 타사 애플리케이션.그리고 나면
결제 한도에서도 특정 이벤트에 관심이 있을 수 있는 제한된 컨텍스트를 확인해 보세요.따라서 버스 한 대로도 이러한 상황을 간단하게 관리할 수 있습니다.그래서 여기가 바로
제가 보통 추천하는 다른 사고 과정은
팀은 외부 커뮤니케이션을 분리하는 것입니다.
제한된 컨텍스트 내에서 다른 이벤트 버스를 사용하면
저는 이것을 게이트키퍼 버스라고 부르거나 외부 버스라고 부를 수 있습니다.자, 여기서 말씀드리자면
내부 이벤트 버스, 그건 아무 상관없어요
크로스 계정이나 외부 소비자가 누구인지에 대해서요그 초점은 순전히 내부에 있습니다.
마이크로서비스를 다루는 한정된 맥락
이벤트, 모든 종류의 이벤트반면 외부 또는 게이트키퍼 버스는 도메인만 처리합니다.
종료해야 하는 이벤트 또는 교차 계정 규칙
이를 통해 다른 도메인과 이벤트를 공유할 수 있습니다.
기타 경계 컨텍스트.그냥 분리해서 단순하게 만드는 방법일 뿐이에요. 그게 전부예요.자, 말씀드렸듯이
일종의 메커니즘으로, 알다시피, 문제를 해결할 수 있는 일종의 메커니즘이죠.
사실, 구현을 단순하게 하세요.제가 말씀드린 것처럼,
게이트키퍼 버스는 모든 규칙과 것들을 갖춘 버스예요.자, 요점은
EventBridge를 사용하면 복잡성이 줄어들지만, 그러기 위해서는
아시다시피, 모든 주문 문제를 놓고 생각해 보세요.
이벤트브리지 등을 사용해서 말이죠.따라서 일반적인 것과 같을 수 있습니다.
부패 방지 레이어.따라서 게이트키퍼 버스와 함께 사용할 마이크로서비스를 쉽게 설정하고 모든 기능을 사용할 수 있습니다.
변환 로직이 거기 있어요.예를 들어 소비자가 이벤트를 변환하도록 요구하는 경우를 예로 들 수 있습니다.
클라우드 이벤트로 사용할 수 있는 이벤트는 다음과 같습니다.
모든 내용도 다루었습니다.그래, 그럼 이제
패턴 문제는 끝입니다.그럼 세 가지 일반적인 질문 중 몇 가지를 살펴보죠.
저는 매번 질문을 받습니다.사람들이 가장 먼저 묻는 질문은 “이벤트 버스를 몇 대 가져야 할까요?엔터프라이즈급 버스, 도메인 버스 또는 바운드 컨텍스트 버스를 사용할 수 있습니까?그러니까, 다음과 같이 할 수 있습니다.
이런 것들의 조합이죠.문제는 엔터프라이즈 버스에 있습니다. 분명히 다양한 이벤트가 벌어지고 있다고 생각하시면 됩니다.그러니까 다음이 필요해요.
EventBridge를 기반으로 일종의 거버넌스가 구축되었습니다.예를 들어, 어떻게 할 수 있을까요?
자동으로 온보딩, 오프보드 프로듀서, 소비자를 온보딩할 수 있나요?아시다시피 이런 것들을 염두에 두셔야 합니다.그렇게 간단하지 않아요. 왜냐하면
도메인과 이벤트가 다르면 이벤트를 푸시하세요.
및 소비자 이벤트.따라서 도메인 레벨 이벤트 버스는 약간 단순하지만 여전히 복잡합니다.
비즈니스 도메인의 설정에 따라 다릅니다.하지만 다시 말씀드리지만, 이러한 종류의 거버넌스와 스키마 검증이 있으면 유용할 것입니다.
등등, 제자리에요.도메인, 죄송합니다, 경계 컨텍스트
버스는 두 팀으로 구성된 팀 경계 내에 있기 때문에 좀 더 편합니다.따라서 게이트키퍼 버스로 이벤트 공유 방법 등을 결정하세요.다음으로 자주 묻는 질문은 “이벤트브리지와 키네시스를 사용해야 하나요?키네시스를 이벤트브리지로 대체할 수 있나요?”제가 말씀드리자면, Kinesis에는 목적이 있습니다.클라우드 스케일을 위한 것입니다.
이벤트 통합 또는 스트리밍저는 스트리머라고 부르지만
제 생각엔 이벤트브리지가 좀 더 세련된 것 같아요, 당신
마이크로서비스나 애플리케이션의 처리 메커니즘까지도 말이죠.그냥 덤프하는 게 아니에요.
모든 것을 이벤트브리지에 담았습니다.그러니까 안무가에 가깝죠.물론 있긴 하죠.
페이로드 크기와 이벤트를 보관할 수 있는 기간에는 차이가 있습니다.그리고 이런 것들이 있습니다.
물론 서비스마다 서비스가 다르긴 하지만 그 점을 염두에 두세요.유효한 사용 사례가 없다면 Kinesis에 가장 적합한 것은 Kinesis에 맡기고 EventBridge 이벤트를 그런 방식으로 처리하는 데 가장 적합한 방법을 사용하십시오.맞아요.마지막으로, 다시 한 번 자주 묻는 질문입니다.“세 가지 서비스가 있는데 어떤 서비스를 사용해야 할까요?”다시 말씀드리지만 공통점도 있습니다. 물론 모두 비동기식입니다.에는 공통점이 있습니다.
목적과 사물의 측면에서 말이죠.SQS는 큐잉, 버퍼링에 사용됩니다.SNS는 전형적인 펍입니다.
주제가 있는 서브 모델.이벤트브리지는 브로커이자 일종의 안무입니다.
당신의 서비스, 코디네이터.그 다음은 메시지 흐름입니다.경우에 따라 SQS를 사용하여 특성을 조정하고 조정할 수 있습니다.반면 이벤트브리지에서는
현재로선 방법이 없습니다.줄을 서거나
소비의 반대편에서 속도를 늦추기 위한 무언가 말이죠.FIFO는 또 다른 차별화 요소입니다.현재로서는 이벤트브리지가
FIFO는 지원하지 않습니다. 아시다시피 정렬된 이벤트는 지원하지 않습니다.그 다음은 일괄 처리입니다.따라서 SQS를 사용하면 처리할 때 한 번에 하나 또는 최대 10,000개의 메시지를 가져와서 처리할 수 있습니다.그런 건 없습니다.
알다시피, 현재 이벤트브리지를 사용할 수 있는 능력이죠.그러니까 이것들은 일종의
기본적인 개념과 차별화 요소, 유사점을 염두에 두어야 할 수도 있습니다.그게 전부입니다.정말 고마워요
들어주셔서 정말 감사합니다.정말 고마워요.그리고
설문조사를 완료해 주세요.감사합니다.
(관객들의 박수 갈채)