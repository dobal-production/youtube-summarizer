- 좋아요, 여기로 갑시다.안녕하세요 여러분, 잘 지내시길 바랍니다.
지금까지 멋진 re:Invent를 만들고 있어요.좋아요.제 이름은 란지스 라만이고 AWS에서 솔루션스 아키텍트로 일하고 있습니다.그리고 저와 함께한 데이브 로버츠는 솔루션스 아키텍트이기도 합니다.그래서 데이브와 저는 끝났습니다.
지난 몇 년 동안 우리는 AWS를 기반으로 SaaS를 구축하는 많은 고객과 함께 일해 왔습니다. 그렇죠?대화를 하면서 멀티테넌시를 어떻게 구현할 것인지에 대해 이야기를 나누었습니다.
전체 스택에서 고객 또는 테넌트의 온보딩 프로세스를 청구, 미터링에 최적화하는 방법에 대해 알아보세요.
메트릭, 테넌트당 비용 및 비용 속성
멀티테넌트 환경은
꽤 많이 떠오릅니다.지금까지 꽤 많이 제기되고 있는 주제 중 하나는 고객들이 우리에게 어떻게 구현할지, 어떻게 구현할지, 어떤 것들이 있는지 물어본다는 것입니다.
모범 사례 및 패턴, 멀티테넌트 데이터 및 스토리지와 같은 몇 가지 지침을 제공합니다.이것이 바로 이 부분 특정 세션에서 이러한 모범 사례와 패턴에 대해 자세히 알아보고 기본적으로 다루고자 하는 동기가 되었습니다.
멀티테넌트 데이터의 스케일링, 보안, 튜닝.이것은 300 레벨의 세션입니다. 즉, 이제 진행하겠습니다.
몇 가지 아키텍처 및 아키텍처 다이어그램에 대해 알아보고 자세히 살펴보도록 하겠습니다.
일부 AWS 서비스도 마찬가지지만 ID를 열거나 검토를 시작하는 것만큼 쉽지는 않을 것입니다.
코드나 그와 비슷한 것.그럼 일치하길 바래요
여러분의 기대에 부응하겠습니다.그럼 이제 시작해 보죠.건물을 짓고 있다고 가정해 봅시다.
SaaS 애플리케이션 맞죠?아주 높은 수준에서 보면 이렇게 보일 수도 있겠죠?일종의 웹 계층이 있는데, 일종의 진입점이죠. 서비스를 이용할 수 있습니다.
정적 서비스를 제공하는 Amazon CloudFront처럼
S3 버킷의 콘텐츠.그러면 일종의 API 관리 계층이 생길 수도 있겠죠?그런 다음 요청이 이동합니다.
그리고 코그니토를 거쳐갑니다. 마치 필요한 것처럼
요청을 인증하면 일종의 승인을 받을 수 있습니다.
또한 제자리에 있습니다.그리고 마지막으로 요청하세요.
애플리케이션 계층, 서비스 계층에 도달하면
일종의 컴퓨팅과 일종의 컴퓨터 같은 것이 있을 것입니다.
데이터베이스나 스토리지 맞죠?그리고 반론을 제기할 수도 있겠죠.
여기서 볼 수 있는 모든 레이어는 그 결과를 가져온다는 것입니다.
일종의 SaaS 관점과 요구 사항, 고려 사항.그리고 당신 말이 맞을 거예요. 예를 들어 수백 개 정도 될 수 있으니까요.
그리고 시스템에 들어오는 수천 개의 메시지도 있죠.예를 들어 이 모든 것을 어떻게 관리하고 해당 요청이 올바른 테넌트와 올바른 테넌트 사용자로부터 오는지 어떻게 식별할 수 있을까요?그런 다음 어떻게 인증하고 요청을 제한해야 할 수도 있는 방법은 다음과 같습니다.
SaaS 솔루션 내에는 여러 플랜 또는 티어가 포함되어 있습니다.따라서 스로틀링은 고객으로부터 상당히 많이 접하는 중요한 측면입니다.그리고 마지막으로, 여러분은
컴퓨팅 레이어에서도 고려해야 할 사항이 있습니다.
스케일링과 파티셔닝 같은 것,
시끄러운 이웃 상황은 꽤 자주 발생합니다.하지만 이 강연의 초점은 여기서 다루지 않겠습니다.우리의 초점은
데이터 레이어에 집중하세요.따라서 대부분의 경우 Amazon Aurora 또는 관계형 데이터베이스 측면에서 이루어질 것입니다.하지만 여기서 다루도록 하겠습니다.
다음과 같은 S3와 DynamoDB 패턴에 대해 알아보겠습니다.
어디에서든 말이 되죠.그리고 여길 따라가면서 말이죠.자, 그럼 훌륭한 SaaS를 만드는 요소에는 어떤 것들이 있을까요?
스토리지 아키텍처요?그리고 첫 번째는 거의
항상 보안이 중요하죠.그리고 분명히 있습니다.
적용해야 할 기본 보안 원칙
AWS 환경에서.하지만 SaaS 솔루션이나 SaaS 환경에 대해 이야기할 때 보안은 정말 완벽합니다.
테넌트 또는 워크로드의 렌즈는
테넌트가 그 시스템에서 실행되고 있잖아요, 그렇죠?다음은 확장성입니다.SaaS 제공업체로서
시스템에 모든 테넌트가 들어올 때 어떻게 확장할 수 있을지 생각해 보셔야 할 겁니다.그러니까, 제 말은, 제가 받을 때
이렇게 급증하는 트래픽을 제 시스템이 처리할 수 있을까요?
그 모든 트래픽, 그렇죠?그러니까 확장성이 중요하죠.
이 또한 매우 중요합니다.하지만 확장성에 있어 훨씬 더 중요한 것은 팀의 수동 작업이나 개입 없이 확장할 수 있다는 사실입니다.그리고 마지막은 효율성입니다.다시 말씀드리지만, SaaS 제공업체로서 어떻게 혜택을 받을 수 있을지 생각해 보셔야 합니다.
데이터베이스와 스토리지 엔진을 최대한 활용하고 있죠?그리고 로우 터치 오퍼레이션과 같은 것들을 어떻게 구현할 수 있을까요?그리고 효율성은 그렇지 않습니다.
성능 또는 운영 관점에서만 볼 수 있습니다.비용 측면에서도 마찬가지죠. 비용 측면에서도요.예를 들어 테넌트별 수준에서 낭비를 방지하는 방법도 마찬가지입니다.모든 것이 테넌트에 있는 것처럼 SaaS에서는 이 점이 중요합니다.
레벨 또는 고객 레벨그렇다면 낭비를 어떻게 방지할 수 있을까요?어떻게 하면 주변에 있는 시스템들을 막을 수 있을까요?
아무것도 안 한다고요?게으른 거야?그러니까 네가 할 수 있는 게 바로 그거야
또한 생각해 보셔야 합니다.그럼 통과하기 전에
이 섹션의 나머지 부분에서는 몇 가지 기본 사항부터 시작하겠습니다.그리고 먼저 말씀드리고 싶은 것은
배포 모델, 그리고 이건 뭔가
가보셨다면 이미 잘 아실 수도 있는 것들이죠.
AWS SaaS 팩터 팀이 제공한 몇 가지 내용을 살펴보았습니다.
수년에 걸쳐 제작해 왔습니다.하지만 우리는 여전히 이 문제를 빠르게 다루고 싶습니다.첫 번째는 사일로 배포 모델이라는 개념입니다. 즉, 할당해야 한다는 뜻입니다.
모두를 위한 전용 데이터베이스 또는 인프라처럼
시스템의 단일 테넌트.그리고 여러 테넌트가 공통 리소스 세트를 공유하는 풀 모델도 있습니다.그 다음은 브리지 모델입니다.
그 사이에 있는 뭔가가 있잖아요
사일로와 수영장이 섞여 있는 곳이죠.이제 아키텍처처럼 사일로 모델을 보면 경향이 있습니다.
조금 더 간단하게 설명하자면 모든 테넌트에 전용 인스턴스와 리소스가 있기 때문입니다.따라서 몇 가지 자연스러운 부분이 있습니다.
이러한 인스턴스에 대한 보안 경계는 있지만 효율성에 기인합니다.
관점에서는 이러한 모든 기능을 갖추고 있기 때문에 그다지 훌륭하지는 않습니다.
시스템들이 여기저기 널려 있어요.예를 들어, 규모를 늘리면 수백 개가 됩니다.
수천 명의 테넌트가 있으면 수백 명이 됩니다.
그리고 수천 개의 시스템.따라서 관리 관점에서 볼 때 유지 관리 및 운영은
사일로 모델처럼 조금 더 어려운 경향이 있습니다.하지만 앞으로 나아가다 보면
맞아요, 풀 모델은 효율성의 관점에서 볼 때 상황이 조금씩 나아지기 시작합니다. 왜냐하면 공유하기 때문이죠.
공통 리소스 집합이지만 아키텍처 자체는
약간 복잡해질 수 있습니다.그러니까 고립된 상태에서
그리고 보안 관점에서는, 예를 들어 여러 테넌트가 동일한 리소스 세트를 공유하는 경우 조금 더 어려워질 수 있습니다.하지만 이해해야 할 것은
이러한 배포 모델은 매우 중요합니다. 왜냐하면 어떻게 보면
모든 SaaS 환경, 테넌트 온보딩은
이 중요한 기능입니다.SaaS 관리자인데 요청이 무엇으로 전달된다고 가정해 봅시다.
우리는 SaaS 컨트롤 플레인이라고 부릅니다.컨트롤 플레인은 다음과 같습니다.
온보딩과 같은 작업을 수행하는 SaaS 앱 내 계층
테넌트와 사용자 ID를 설정합니다.워크플로의 어느 시점에서는 프로비저닝 서비스, 즉 테넌트 프로비저닝 서비스라고 부르게 됩니다.그리고 이 프로비저닝은
서비스는 “좋아요, 제 시스템에 엔터프라이즈 티어 테넌트 또는 고객이 있습니다”라고 말하는 서비스입니다.“아마도 사일로화된 데이터베이스를 가동해야 할 것 같습니다.” 또는 사일로화된 컴퓨팅 또는
인프라 장애.“내 엔터프라이즈 티어 고객을 위해.”프리 티어 테넌트가 있을 수도 있습니다.그리고 그들에게는 이득이 될 수도 있습니다.
그냥 자원을 공유하는 게 합리적이죠.말이 안 될 수도 있잖아요
전용 데이터베이스 또는 스토리지를 가동하는 것 같은
프리 티어 테넌트는 아직 비용을 지불하지 않았거나 고객에게 아직 비용을 지불하지 않았으므로 다음과 같이 할 수 있습니다.
풀 모델에 있는 것들이죠.하지만 배포 모델이 이미 의사 결정과 테넌트 온보딩에 어떤 영향을 미치는지 알 수 있습니다.
전체 프로세스는 테넌트 온보딩 프로세스, 해당 워크플로 중에 이루어집니다.이제 또 다른 문제는 테넌트별로 데이터베이스 같은 배포 모델이 서로 다를 때입니다.
또는 데이터베이스 인스턴스, 테넌트별 클러스터, 또는 공유 스키마를 사용하는 경우 유지해야 할 중요한 사항은
애플리케이션의 라우팅 방식이나 운영 방식을 염두에 두세요.
서로 다른 배포 모델 간에 요청을 라우팅할 예정입니다.따라서 일반적으로
리소스 맵이라고 하거나 테넌트 컨텍스트를 전달하는 매핑 서비스와 같은 것입니다.그럼 테넌트 컨텍스트는
요청을 받을 수 있습니다.따라서 모든 요청에는 다음이 포함되어야 합니다.
일종의 테넌트 컨텍스트 (예: 테넌트 ID).그리고 이 테넌트 ID를 사용하면 이 매핑 서비스를 이용할 수 있습니다.그 다음은 매핑 서비스입니다.
사용할 연결 세부 정보를 반환합니다.
이 경우에는 올바른 대상 또는 올바른 데이터베이스로 이동합니다.자, 이게 있단 말이에요
흔한 오해로, 특정한 방식으로 배포하거나 파티션을 나누면
데이터베이스를 특정 방식으로 사용하면 자동으로 격리됩니다.하지만 항상 그런 것은 아닙니다. 이 예를 보면 각 테넌트에 고유한 특성이 있기 때문입니다.
이 경우에는 자체 데이터베이스 인스턴스 또는 클러스터입니다.하지만 마이크로서비스는 켜져 있습니다.
애플리케이션 계층은 여러 테넌트 간에 공유됩니다.따라서 필요한 것은 서비스 계층의 문제나 버그뿐입니다. 예를 들어 누군가를 예로 들어 보겠습니다.
그들은 디버깅 세션 중에 가서 테넌트 ID를 다루었죠?그래서 여러분이 얻게 되는 것은 모든 것과 같습니다.
시스템의 다른 테넌트는 어려운 상황을 보게 될 것입니다.
쿼터 테넌트 데이터.그래서 여러분이 이상적으로 필요로 하는 것은
이런 식이죠.추가 분류가 필요해요
추가 보호 계층으로, 이를 격리 컨텍스트라고 합니다. 여기서 IAM을 사용하여 정책을 적용하거나 다른 정책이 있습니다.
추가 제어 또는 보호 계층을 제공하는 곳에서 사용할 수 있는 엔진입니다.하지만 누군가가 테넌트 ID를 하드 코딩하는 시나리오에서도 요청이 데이터베이스로 전송되지 않도록 해야 합니다. 그렇지 않으면 오류가 발생할 수밖에 없겠죠?따라서 이것이 가장 필요한 것입니다.따라서 파티션을 배포하면
특정 방식으로는 그렇지 않은 무언가
찾고 계신 분리를 자동으로 보장해 드립니다.컨텍스트를 설정하고 몇 가지 기본 사항을 다룬 것 같아요.그래서 우리가 할 수 있는 일은
나머지 세션은 앞서 소개한 세 가지 영역 또는 주제에 대한 내용입니다. 몇 가지를 살펴보도록 하겠습니다.
구체적인 고려 사항 (예: 특정 주제)바로 여기가 바로 여기입니다.
이제 남은 세션에 대해 알아보도록 하겠습니다.먼저 보안부터 시작하겠습니다. 먼저 액세스 패턴과 액세스 패턴에 대해 알아보겠습니다.
격리를 달성하는 데 도움이 되죠, 그렇죠?따라서 데이터베이스 측에서 보안을 강화하기 위해 할 수 있는 일이나 할 수 있는 일이 많이 있습니다.
격리와 파티셔닝은 중요하지만 액세스 패턴은 중요합니다. 왜냐하면 어떻게 해야 할까요?
특정 사용자가 특정 데이터베이스에 액세스할 수 있다는 것을 알고 계신가요?마치 그들이 가지고 있는 것처럼
적절한 정책이 마련되어 있나요?그들에게도 권리가 있나요?
권한이 있나요?그래서 그게 중요하죠, 그렇죠?그래서 여러분은 여러 가지 일을 할 수 있습니다.
데이터베이스 쪽에서는 해야겠지만, 데이터베이스에 접근하는 방법은
잘 다루고 있기도 하죠.그래서 사일로가 있는 첫 번째 모델을 살펴보겠습니다.
사일로 컴퓨팅이 포함된 스토리지.따라서 이 모델에서는 전용 Amazon을 할당하거나 할당합니다.
모든 단일 테넌트에 Aurora 인스턴스 또는 클러스터를 적용하죠?그리고 컴퓨팅 레이어에서는
람다 함수가 있습니다.따라서 테넌트가 요청하면
람다 함수에 들어오면 실행이 발생합니다.
역할에는 정책이 있습니다. 정책을 살펴보면 특정 테넌트에만 해당됩니다.그리고 이 정책은 함수에서 사용하는 임시 보안 자격 증명을 반환합니다.
데이터베이스에 액세스할 것이고, 테넌트는 데이터베이스를 원합니다.테넌트 2도 마찬가지죠?따라서 테넌트 2는 고유한 람다 실행 역할을 갖게 됩니다. 자체 정책을 사용하여 자격 증명을 받고 액세스할 수 있습니다.
그들의 데이터베이스 맞죠?그래서 이 모델에서는 확실히 더 나은 격리를 얻을 수 있습니다. 왜냐하면 일종의 자연스러운 보안 경계가 있기 때문이죠.
이 모델에서는 그렇죠?그리고 우리는 사용하고 있습니다.
AWS IAM 인증은 훌륭하게 작동합니다.찾고 있는 임시 자격 증명을 제공합니다.게다가 효과도 훌륭합니다.
네트워킹 수준, 네트워크 세분화 관점에서 말이죠.하나의 Aurora 인스턴스를 하나의 특정 네트워크 세그먼트에 배치하고 다른 하나를 하나의 네트워크 세그먼트에 배치할 수 있습니다.
네트워크 세그먼트가 다르지만, 어느 시점에서는
이 모델의 문제점은 한도가 부족하다는 것입니다.그러니까 수백 개 정도 가지고 있다면
그리고 수천 명의 세입자들, 다시 말씀드리지만, 앞서 말씀드렸듯이, 여러분은 관리해야 할 것입니다.
이 모든 다른 시스템들.그래서 조금 어려울 수도 있습니다.이제 데이터베이스를 단일 데이터베이스 인스턴스로 전환하면 어떻게 될까요?자, 이것 말고 이걸 가지고 계신 거죠?격리 특성은 이전 모델과 매우 비슷하지만 이제는 할 수 있었던 네트워크 세분화를 놓치게 되죠. 그렇죠?이전 모델에서는 앞서 말씀드린 것처럼 데이터베이스 인스턴스를 자체 네트워크 세그먼트에 배치할 수 있었지만 이 모델에서는 불가능합니다.하지만 컴퓨팅 측면에서는 여전히 AWS IAM 인증을 사용하고 데이터를 수신하거나 검색할 수 있습니다.
임시 보안 자격 증명을 사용하고 이를 사용하면
올바른 데이터베이스에 액세스하세요.따라서 컴퓨팅 관점에서는 괜찮지만 이 모델에서는 네트워크 수준 세분화가 일부 손실됩니다.자, 이제 이 문제에 대해 말씀드렸죠.
AWS IAM 인증은 사일로화된 환경에서도 잘 작동합니다. 낮은 수준이면 말이죠.
동시 사용자 수.하지만 이사를 시작하면
풀링된 환경에서는 AWS IAM 인증에 대해 정의된 상한선이 몇 가지 있습니다. 그렇죠?예를 들어 초당 인증 요청 수를 예로 들 수 있습니다.
단일 데이터베이스에 만들 수 있나요?이게 바로 이런 이유죠.
모델은 AWS IAM 인증을 대체할 예정입니다.
시크릿 매니저와 함께 말이죠.그리고 보시면, 저는
아주 비슷한 패턴을 의미하는데요, AWS IAM 인증 대신
시크릿 매니저와 시크릿 매니저가 있습니다.
이 특별한 경우에는 테넌트당 비밀이 하나씩 있어야 합니다.정책을 보면 분명히 Secrets Manager가 비밀 값을 가져올 때 작업을 요청하고 있다는 뜻입니다. 하지만 우리는 특정 테넌트에 대해 조치를 취하고 있습니다.그리고 시크릿 매니저는 무엇인가요?
Secrets Manager가 사용하기 때문에 장기 자격 증명을 반환할 것입니다.
비밀번호 인증.그리고 이걸 사용해서
이 경우 Lambda 함수가 올바른 데이터베이스에 액세스하고 테넌트 2에서도 매우 유사한 접근 방식을 사용할 수 있습니다.따라서 아이디어는 사일로화된 접근 방식에서 통합 접근 방식으로 전환한다는 것입니다.
자격 증명 관리 목적으로 Secrets Manager를 사용하는 것을 고려해 보세요.좋아요, 그럼 지금까지는
전용 람다 함수와 같은 전용 컴퓨팅이 있었습니다.
모든 단일 테넌트에 적용되었습니다.하지만 만약 있다면,
단일 Lambda 함수.따라서 여기서 어떤 테넌트가 호출을 하는지 확인해야 합니다.예를 들어 런타임 시 테넌트가 누구인지 알 수 있죠?여기서 우리가 토큰 자판기라고 부르는 것을 사용할 수 있습니다.자, 이 모듈은
빌드해야 하고 다음을 검색할 수 있습니다.
TVM, AWS 만족스럽고 몇 가지 예를 찾을 수 있을 것입니다.
이를 구현하는 방법에 대해 알아보겠습니다.따라서 토큰 벤딩 머신의 기본 개념은 여러분에게 단일 역할이 있고 그 역할에는 테넌트 ID에 대한 자리 표시자가 있는 정책이 있다는 것입니다.맨 아래를 보면 자리 표시자가 생기는 것과 같습니다.
테넌트 ID의 경우, 런타임 시 교체됩니다.그럼 돌아올 수 있는 거고, 뭐
Lambda 함수가 돌려받는 건 스코프 자격 증명이죠?따라서 이 자격 증명은 해당 테넌트에 맞게 범위가 지정되는 자격 증명입니다.
그 사람이 요청을 하는 거죠.그리고 한번은 Lambda 함수가
범위가 지정된 자격 증명이 있으면 비밀 관리자로 이동할 수 있습니다.
올바른 비밀을 검색한 다음 데이터베이스에 액세스하세요.자, 이 모델에서는 무엇이 다른가요?우리는 시스템의 모든 단일 테넌트에 대해 단일 데이터베이스를 가지고 있습니다.그렇다면 이것이 상황을 어떻게 변화시킬까요?그래서 우리는 여전히 전체 토큰 벤딩 머신 프로세스를 거치고 스코프 자격 증명을 검색할 수 있습니다.
Lambda 함수를 사용하는 모든 단일 테넌트에 대해
데이터베이스에 액세스할 수 있습니다.하지만 시스템에 테넌트가 많거나 데이터베이스 측에서 보유할 수 있는 사용자 수에 제한이 있는 시점이 되면 말이죠.예를 들어, 이러한 문제에 직면했을 때, Lambda 함수가 있는 곳에서 이 작업을 수행할 수 있을 때처럼요.시크릿 매니저로 가세요.
단 하나의 비밀 또는 데이터베이스 자격 증명이 있습니다.
다시 반환됩니다.이걸 사용하면 람다 함수가 데이터베이스에 액세스할 수 있겠죠?따라서 이 모델에서는
코드 리뷰 프로세스에서 더 많은 제어 기능을 적용해야 하고, 그렇게 해야 할 겁니다.
거기에는 좋은 프로세스가 있습니다.다음과 같은 종류의 필터가 있는지 확인해야 합니다.
애플리케이션 코드의 일부 또는 애플리케이션 코드가 아닌 경우, like를 사용하는 경우
스토어 프로시저 사용 (예: 다음과 같이)
데이터베이스 쪽에 있는 것 말이에요.일종의 필터죠.이것이 바로 액세스 패턴이었습니다.이제 Dave에게 넘겨 설명해 드리겠습니다.
여정 섹션이 여기 있어요. - 훌륭해요, 고마워요 란지스.그래서 이 모든 토대를 살펴보고 스토리지를 만드세요.
그걸로 아키텍처를 만들죠.이건 시작에 불과합니다.왜냐하면 당신이 가지고 있기 때문이지요.
스토리지 아키텍처가 있다고 해서 게임이 끝난 것은 아닙니다.다음을 수행할 수 있어야 합니다.
SaaS 애플리케이션의 성장을 따라잡으세요.점점 더 많은 테넌트가 들어옴에 따라 스토리지 아키텍처도 달라집니다.
요구 사항을 충족하기 위해 확장 및 확장해야 합니다.
해당 세입자에게 서비스를 제공합니다.다시 우리 집으로 돌아가면
예제 애플리케이션은 다음과 같이 만들었습니다.
애플리케이션, 출시가 끝났어요. 이제 막 만들어지기 시작했어요.
탑승한 첫 고객.그리고 점점 더 많아질수록
우리 시스템의 테넌트가 있으면 애플리케이션 확장을 시작해야 합니다.다행스럽게도 우리는 사용하고 있습니다.
우리를 대신해 스케일링을 처리하는 일부 관리형 컴퓨팅 서비스죠.인생은 멋지고 쉬워요.그래서 우리가 더 많이 얻으면
더 많은 테넌트가 합류하면서 컴퓨팅도 계속 성장하고 있습니다.그리고 규모가 커질수록 데이터도 커집니다.
스토리지에 대한 요구 사항.테넌트가 많을수록 트랜잭션이 많아지고 결국 스토리지는 “아니요”라고 말합니다.그렇죠?병목 현상이 되죠.이제 생각해 볼 필요가 있습니다.
스토리지 확장에 대해 말씀드리죠.그리고 우리가 얘기할 때
스토리지 확장에는 세 가지가 있습니다.
생각해 볼 필요가 있습니다.수직적 스케일링이 있죠.
따라서 스토리지 인스턴스에 리소스를 더 추가하는 거죠.연결 관리 기능이 있습니다.그래서 그 스토리지 인스턴스는
처리할 수 있는 연결 수가 한정되어 있습니다.따라서 다음 사항을 확인해야 합니다.
점점 더 많은 연결을 처리할 수 있도록 확장할 수 있다는 것이죠.마지막으로 수평적 확장도 가능하죠.그래서 더 많은 스토리지 인스턴스를 추가하는 거죠.
논리적 데이터 세트에그리고 이러한 각각의 스케일링 메커니즘은 복잡성을 가져올 것입니다.
스토리지 아키텍처에 적용되었습니다.그래서 저희가 확인하고자 하는 것은
새 메커니즘을 구현하기 전에 기존 아키텍처를 최대한 확장할 수 있습니다.그리고 스케일링을 시작하면
수직 스케일링부터 시작하세요. 쉽기 때문이죠?그냥 깡통을 좀 더 던져 볼게요.병목 현상에 가까워지면 인스턴트가 늘어납니다.
규모를 키우고, 리소스를 더 추가하고, 테넌트 기반을 계속 확장해 나가세요.그리고 이건 정말 잘 작동하죠.우리는 계속 성장하고 성장하며 점점 더 많은 세입자에게 서비스를 제공할 수 있습니다.자, 이 접근법의 단점은 한계가 있다는 것입니다.
단일 스토리지 인스턴스를 확장할 수 있는 범위를 제한하십시오.따라서 그 시점에 이르렀을 때 어떤 조치를 취할지 염두에 두어야 합니다.그리고 동시에
수직적으로 확장하고 있는데 효율성에 대해 생각해 보고 싶습니다. 효율성이란 동일한 스토리지 리소스에서 더 많은 트랜잭션을 처리할 수 있다는 의미이기 때문입니다.그리고 이것은 정말 중요합니다.
SaaS에서는 SaaS가 확장되고 SaaS가 이러한 효율성을 확장할 것이기 때문입니다.우리가 얻을 수 있는 모든 효율성 향상은 숫자에 따라 늘어날 것입니다.
우리가 보유한 테넌트의 수.한 사람의 개선은 다음과 같습니다.
모두를 위한 개선이죠.그러니 혁신에 투자하세요
효율성에 대한 포인트가 이를 상쇄하는 데 도움이 될 것입니다.
규모 조정 요구 사항을 충족하고 이를 확장할 수 있습니다.
스토리지 아키텍처는 더 많은 테넌트에게 더 많은 서비스를 제공합니다.그리고 더 중요한 것은 SaaS입니다.
낭비를 줄일 수 있을 거예요그러니까 처음 배포할 때는
SaaS 애플리케이션은 그냥 시도하는 것뿐입니다.
제품을 구해서 그 안에 넣으려고 노력하세요.
고객의 손.가장 효율적인 스토리지 아키텍처를 만들 생각은 없으시겠지만, 이미 몇 가지가 있을 수 있습니다.
낭비적인 액세스 패턴.여러분이 성장하고 성장하기 시작하면서 이러한 액세스 패턴은
이러한 낭비 역시 확대할 예정입니다.그리고 이것이 영향을 미칠 것입니다.
규모를 확장할 수 있는 능력도 있지만
수익에 영향을 미치세요.이는 수익성 간의 차이를 의미할 수 있습니다.따라서 효율성에 초점을 맞춥니다.
일어나는 것에 대해 이야기할 때는 정말 중요합니다.
SaaS 여정의 고성장 단계에 들어서세요.효율성에 대해 이야기할 때는 두 가지 영역에 초점을 맞춥니다.하나는 최적화하는 것입니다.
쿼리의 효율성.마이크로 배칭 권한 같은 것들이요. 자주 사용하는 경우
작은 권한 요청은 일괄적으로 처리하면 좀 더 효율적일 수 있습니다.그리고 다른 하나는
물리 디스크의 효율성 향상
해당 쿼리를 제공합니다.즉, 배열을 하는 것과 같은 것들이요.
모든 테넌트 데이터를 동일한 디스크 세트에 저장하므로 쿼리가 필요 없습니다.
여러 디스크에 걸쳐 사용하거나 일종의 집계 쿼리를 해야 할 경우 데이터를 미리 집계하는 식입니다.그리고 구현하는 한 가지 방법도 있습니다.
물리적인 개선은 테이블 파티셔닝입니다.그럼 간단한 쿼리를 보세요.특정 테넌트에 속한 모든 항목을 반환하고 싶을 뿐입니다.이제 해결해야 할 과제가 있습니다.
여기 여러 테넌트가 공유하는 테이블이 있습니다.따라서 해당 테이블에 있는 모든 항목을 전체적으로 검사하여 일치하는지 확인해야 합니다.
그 테넌트한테 물어볼지 말지이는 상당히 비효율적일 수 있습니다. 특히 세입자가 많으면 말이죠.풀 데이터베이스가 크면 매번 전체 스캔을 수행하고, 여기에 다른 모든 테넌트가 동시에 같은 작업을 수행하는 것을 곱하면 큰 낭비가 됩니다.다행스럽게도 대부분의 스토리지 엔진은 어떤 형태로든 지원할 것입니다.
테이블 파티셔닝에 대해 말하자면
이 테이블을 각각 고유한 디스크 세트를 가진 더 작은 물리적 파티션으로 나눌 수 있습니다.파티셔닝을 할 때
파티션 키로 이 작업을 수행합니다.그리고 우리는 SaaS를 사용하고 있기 때문에
멀티 테넌시를 사용하고 있는데, 훌륭한 파티션 키는 테넌트 ID입니다.그래야 할 수 있기 때문이죠.
특정 테넌트를 선택하여 자체 파티션에 배치하세요.자체 디스크 세트를 사용하므로 성능이 약간 향상됩니다.
고립도 마찬가지죠.그리고 우리는 여전히 우리의 뿌리를 지키고 있습니다
데이터베이스 내에 있는 테이블이지만 이제는 테이블이 책임질 뿐입니다.
애플리케이션에서 오는 요청을 라우팅하기 위해
오른쪽 파티션으로.테넌트별 쿼리 성능이 개선되었고 애플리케이션 코드를 변경할 필요가 없었기 때문에 이 기능이 훌륭합니다.그리고 이것은 풀 모델을 확장하는 데 정말 유용할 수 있습니다.테넌트가 많을 경우 이 기능을 사용하여 다음을 수행할 수 있습니다.
시끄러운 이웃을 막으세요.하지만 대가가 따르죠?운영상의 오버헤드가 있습니다.이제 파티션이 더 많아졌습니다.
관리해야 할 부분이죠.그래서 생각해 볼 필요가 있어요.
이러한 혜택이 운영 오버헤드에 영향을 주는지 여부.그리고 점점 더 많은 테넌트를 수용하면서 수직적으로 확장해 나감에 따라 쿼리의 효율성이 향상되고 더 많은 테넌트가 참여하게 되어 다음 병목 지점까지 도달하게 될 것입니다.이것이 바로 연결 관리입니다.애플리케이션이 스토리지와 통신해야 할 때마다 해당 스토리지를 통해 물리적으로 연결해야 하기 때문입니다.그리고 우리가 실행 중이기 때문이죠.
멀티 테넌트 애플리케이션은 테넌트별로 이 작업을 수행할 것입니다.따라서 점점 더 많은 테넌트에서 들어오는 사용자가 늘어남에 따라 이러한 사용자는 데이터를 소비하고 있습니다.
스토리지가 지원할 수 있는 연결 수는 한정되어 있습니다.그리고 결국에는
연결 풀이 고갈되어 더 이상 연결을 할 수 없게 되는 지경에 이르게 될 것입니다.이건 나쁜 점이에요, 우리
더 이상 쿼리를 제공할 수 없으므로 이러한 연결을 처리할 메커니즘을 구현해야 합니다.이제 한 가지 방법은 일종의 연결 관리를 구축하는 것입니다.
애플리케이션에 넣어도 괜찮습니다.하지만 그건 당신이 쓰는 돈이에요.
당신의 혁신 포인트, 무언가를 만드는 것
제품을 더 좋게 만드는 것보다는 고객 연결을 처리하는 것이 좋습니다. 그래서 저희는 관리형 제품을 찾고 있는데 바로 이 부분에서 RDS 프록시가 유용할 수 있습니다.따라서 RDS 프록시는 스토리지와 애플리케이션 사이에 위치하게 됩니다.이제 애플리케이션이 완성되었습니다.
RDS 프록시에 연결됩니다.그리고 RDS 프록시는 연결을 만들 것입니다.
스토리지로 연결되지만 여러 세션에서 해당 연결을 재사용합니다.정말 좋아요.더 많이 확장할 수 있어요
RDS 프록시를 통한 연결수평적으로 확장할 수 있습니다.
RDS 프록시는 인스턴스가 많을수록 더 많은 테넌트를 수용할 수 있고 스토리지 아키텍처를 한 단계 더 발전시킬 수 있습니다.하지만 RDS 프록시 및 세션 변수에는 문제가 있으며 몇 가지 문제가 있습니다.
예를 들어 다음과 같이 필요할 수 있는 몇 가지 사용 사례
SaaS 아키텍처 내에서 세션 변수를 사용하세요.자, 이 간단한 웨어 조항을 보세요.이건 몇 가지 기본적인 내용입니다.
테넌트 격리, 그렇죠?이건 그냥 그 세입자의 물건들을 돌려준다는 뜻이에요. 하지만 우리는 지금 하고 있어요.
애플리케이션 코드 내부.애플리케이션 코드는 다음과 같습니다.
오류가 발생할 수도 있고, 깨질 수도 있고, 누군가 바꿀 수도 있습니다.좀 더 보안을 강화해서 내부에서 해보려고 합니다.
저희 스토리지 엔진.이에 대한 한 가지 접근법은
Postgres와 함께 행 수준 보안을 사용하는 것입니다.행 수준 보안에서는 모든 항목을 할당합니다.
특정 테넌트에게.그래서 이 경우에는
거기 테넌트 ID가 있어요.이를 구현하는 한 가지 방법은 테넌트별 사용자를 생성하고 테넌트별 사용자 자격 증명을 사용하여 해당 데이터베이스에 액세스하는 것입니다.그런 다음 Postgres가 출시될 예정입니다.
해당 테넌트의 항목에만 한정하는 방법을 알아야 합니다.하지만 Postgres 내에서 생성할 수 있는 사용자 수는 한정되어 있습니다.따라서 또 다른 옵션이 있습니다. 즉, 테넌트 ID를 전달하고 현재 테넌트를 설정할 수 있습니다.
세션 변수를 사용하는 건 좋은 접근법이죠.비슷한 작업을 할 수 있습니다.
저장 프로시저를 사용하여 접근하세요.자, 여기서는 웨어 조항을 가져와 저장 프로시저 안에 넣었습니다.저장 프로시저를 실행하면 해당 테넌트를 통과하게 됩니다.
세션 변수로서의 ID.몇 가지 좋은 접근법을 사용해봤어요
테넌트 격리를 좀 더 강력하게 만들었습니다.하지만 뭐가 문제일까요?
RDS 프록시에 세션 변수가 있는 거죠?이걸 왜 사용할 수 없나요?음, RDS 프록시가 세션 변수로 연결을 생성하면
우리를 고유한 연결로 간주하므로 이러한 연결은 재사용할 수 없습니다.
다른 세션 간의 연결.이제는 이를 연결 피닝이라고 합니다.자, 이제 다시 본론으로 돌아오겠습니다.
예전에 우리가 지쳤던 곳과 같은 곳
우리의 커넥션 풀RDS 프록시가 있긴 하지만 실제로는 그렇지 않습니다.
거기서 우리에게 정말 많은 것을 주고 있어요.그래서 우리는 다음에 대해 생각해 볼 필요가 있습니다.
이 문제를 해결할 수 있는 또 다른 방법이죠.이것이 바로 RDS 데이터입니다.
API가 들어와서 도움을 줄 수 있습니다.따라서 데이터 API는 Aurora의 기능이며 이를 활성화하면 Aurora 클러스터에 HTTP API 인터페이스를 제공합니다.따라서 이전과 동일한 방식으로 SDK 통합 작업을 수행할 수 있습니다.
DynamoDB를 사용해 작업하세요.SQL 쿼리를 수행하고 거기에 세션 변수를 설정할 수 있습니다.이제 우리는 이것들을 만들고 있습니다.
HTTP 요청을 통과했지만 아직 들어오고 있습니다.
연결 피닝 맞죠?세션 변수를 설정하고 있는데 여전히 연결 피닝이 발생하지만 이제 데이터 API가 관리 중입니다.
그런 연결들이 우리를 위해 말이죠.우리가 달리고 있다는 걸 알게 되면 그 둘을 끊을 수 있어요.
위험에 빠졌다가 다시 사용하세요.그리고 이건 정말 좋아요.우리에겐 메커니즘이 있어요
점점 더 많은 테넌트를 처리하고 세션 변수를 사용할 수 있도록 연결을 확장하는 것
동시에 말이죠.지금이 정말 좋은 시간이에요
SaaS 아키텍처를 구축하는 저희 툴킷에는 안전하게 구축할 수 있는 많은 도구가 있습니다.
확장 가능한 아키텍처.그리고 계속 성장하고 성장하다 결국 단일 스토리지 인스턴스가 한계에 다다랐다는 문제에 봉착하게 됩니다.
얼마나 클 수 있는지 말이죠.그래서 우리는 가서 다른 일을 해야 합니다.한 가지 방법은 조각하는 것입니다.
데이터의 하위 집합을 잘라서 제 자리로 옮기세요.
용도에 맞게 설계된 스토리지.또 다른 옵션은 추가하는 것입니다.
더 많은 스토리지 인스턴스.그리고 당면 과제는
이게 복잡성을 유발할까요?
우리 아키텍처에 말이죠.이제 테넌트 라우팅이 필요합니다.애플리케이션은 테넌트 요청을 보낼 위치를 알아야 합니다.
적절한 스토리지로게다가 운영 오버헤드도 더 커집니다.더 많은 인스턴스가 있습니다.
관리해야 할 부분이죠.수평적 확장을 고려할 때 가장 먼저 시작할 수 있는 것은 읽기 전용 복제본으로 확장하는 것입니다.따라서 읽기 전용 복제본은
데이터의 복사본일 뿐이죠.애플리케이션은 읽기를 전송할 수 있습니다.
해당 읽기 노트에 대한 요청이제 이러한 읽기 요청은 그렇지 않습니다.
원하는 인스턴스로 이동합니다.따라서 컴퓨팅에 미치는 영향이 줄어듭니다.더 확장할 수 있습니다.
더 많은 테넌트가 훌륭합니다.그리고 책읽기가 무겁다면
작업량, 훌륭합니다.Aurora를 사용하는 경우 최대 15개의 읽기 전용 복제본을 포함할 수 있습니다.그 중 일부는 그럴 수도 있습니다.
심지어 서버리스일 수도 있습니다.그러니까 전부 그런 건 아니에요.
0으로 축소하여 효율성을 높일 수 있습니다.
부하를 맞추는 데 도움이 됩니다.그리고 이러한 접근 방식은 우리에게 많은 도움이 될 수 있습니다.무슨 짓을 했는지, 얼마나 나아갔는지 살펴보면 중앙 인스턴스를 확장했고, 쿼리를 더 효율적으로 만들고, 연결 관리 문제를 해결하고, 읽기 전용 복제본으로 확장했습니다.그리고 이것은 정말 많은 작업입니다.보시다시피 정말 많은 양입니다.
추가해야 할 복잡성이 많습니다.이제 이걸 다음과 비교해보면
예를 들어 DynamoDB를 사용하면 Dynamo는
우리의 스케일링을 대신 처리해주면, 우리의 몫이 될 거예요.
우리의 경우 연결 관리가 우리의 몫이 될 것입니다.
자동으로 파티셔닝을 하기 때문에 쿼리를 효율적으로 작성하기만 하면 됩니다.쉬운 부분이죠, 그렇죠?하지만 문제는, 좋아요, 만약 우리가 가야 한다면?
더 나아가서 무엇을 더 할 수 있을까요?그리고 그 이야기를 계속하기 위해 란지스의 이야기를 들려주고 싶어요. - 고마워요 데이브.좋아요, 데이브가 다른 곳을 안내해 줬어요
관계형 데이터베이스 환경에 적용할 수 있는 확장 옵션 및 솔루션.하지만 한 가지 중요한 점이 있습니다.
아직 다루지 않았는데, 어떻게 글을 쓰냐는 거죠.
쓰기 트랜잭션.그래서 샤딩이 필요한 거죠. 그렇죠?그래서 샤딩은 기본적으로 데이터를 분할하는 방식입니다.
다양한 샤드.따라서 이 경우 서로 다른 샤드는 다음과 같이 표시됩니다.
아마존 오로라 클러스터.샤딩을 구현하는 방법은 다음을 식별하는 것입니다.
분할하려는 테이블 내의 열.이 경우에는 다음을 예로 들어 보겠습니다.
상단에 보이는 테넌트 테이블의 예
왼쪽 또는 오른쪽 상단, 왼쪽 상단그리고 테넌트 ID는 샤드 키가 될 것입니다.테넌트 ID는 이 특별한 경우에 최대한의 카디널리티를 제공하는 열이기 때문입니다.그럼 어떻게 하시겠어요?
단축키, 이 경우에는 테넌트 ID를 전달하세요.
해시 함수를 통과하면 해시 맵과 같은 결과를 얻을 수 있겠죠?그러면 해시를 매핑할 수 있겠죠.
특정 파티션이나 특정 파티션 ID에.그런 다음 파티션은 기본적으로 다른 샤드에 배치됩니다.다시 말씀드리지만, 샤드는
아마존 오로라 클러스터.이제 이것은 어떻게 보일지 보여주는 일종의 표현입니다.자, 이제 진행하셨군요.
파티셔닝 작업을 하고 나면 파티션을 여러 샤드에 분산시킬 수 있습니다.이제 샤드와 파티션이 생겼습니다.하지만 다시 말씀드리지만, 문제는 이것이 기본으로 돌아가는 것입니다.제가 본 슬라이드 중 하나는
앞서 말씀드린 것처럼 파티션이 다르거나 파티션이 다를 때
배포 모델이란 요청을 적절한 위치로 라우팅하는 것이 애플리케이션 이후입니다.이 경우에는 다음과 같이 해보겠습니다.
테넌트 요청이 애플리케이션에 들어온다고 가정하면 애플리케이션은 테넌트 컨텍스트를 사용합니다.이 경우 테넌트 ID가 그 일부라고 가정해 보겠습니다.
요청이 들어오고 있습니다.그리고 먼저
파티션 ID를 검색하고 파티션을 사용하려면
ID를 입력하면 샤드 ID가 반환됩니다.그리고 나서 만들어야 할 거예요
오른쪽 샤드에 대한 요청.하지만 이게 점점 어려워지고 있다는 걸 알 수 있죠.전체 과정은
조금 복잡해지고 있어요.애플리케이션 위치를 쿼리할 때 가장 먼저 해결해야 할 과제는
이제 특정 데이터가 어디에 있는지 파악한 다음 해당 특정 데이터로 요청을 보내야 합니다.그리고 시나리오가 있다면
여러 샤드로 이동해야 하는 경우 이제 애플리케이션은 모든 결과를 집계하고 조인하고 전송해야 합니다.
그걸 다시 클라이언트에 보내죠.그러니까 제 말은, 이게 뭔가요?
차라리 관계 데이터베이스가 있으면 좋겠죠.
직접 해보기 위해서요.그리고 일관성 있는 관점에서 말하자면, 예를 들어 다음과 같이
샤딩된 환경은 수동으로 샤딩된 데이터베이스이므로 일관성이 보장되지 않습니다.자산 규정 준수는 없습니다.
또는 특정 모델의 자산 거래.그리고 운영 및 유지 관리 관점에서도 업그레이드, 백업 수행과 같이 백업을 의미하는데, 특히 그렇지 않을 때는 더욱 그렇습니다.
일관성이 보장되다니, 그건 어려울 거예요.디버깅과 최적화 적용은 정말 어려운 일이죠.그래서 이 모든 난관을 극복하기 위해 우리가 해야 할 일은 바로 이것입니다.
무한한 데이터베이스, 특히
Postgres 데이터베이스 엔진에서는 이렇게 다양한 샤드를 모두 관리하거나 생성할 필요가 없습니다. 여러분이 해야 할 일은
예를 들어 단일 엔드포인트 또는 단일 인터페이스에 도달하면
Postgres는 데이터베이스를 무제한으로 사용할 수 있어 수평적 스케일링이 자동으로 수행됩니다.즉, 매니지드 서비스라고 할 수 있습니다.
그게 바로 당신을 위해 해줄게요.그리고 무한한 데이터베이스죠.
초당 수백만 건의 쓰기 트랜잭션까지 확장할 수 있고, 페타바이트 규모의 데이터를 저장할 수 있으며, 다음과 같은 작업을 수행할 수 있습니다.
운영 관점에서 보면, 아시다시피, 아주 원활하게 할 수 있습니다.무제한 데이터베이스를 통해 트랜잭션의 일관성을 보장할 수 있습니다.그리고 가장 중요한 점은 복잡성을 관리하거나 처리할 필요가 없다는 것입니다.
이 작업을 혼자서 하거나 샤딩을 혼자서 하는 방법이죠.정말 무한한 데이터베이스
대신 처리해 드립니다.핵심 개념 중 몇 가지를 말씀드리자면
제한된 데이터베이스 내에서 Aurora의 무제한 데이터베이스는
샤드 그룹에 대한 이 개념은 바로 이 컬렉션입니다.
라우터와 샤드.그리고 라우터는 기본적으로 Aurora입니다.
수신하거나 가로채는 노드 또는 Aurora 인스턴스
이 경우 다른 클라이언트에서 들어오는 요청은
의 다른 테넌트와 해당 사용자여야 합니다.
멀티테넌트 SaaS 환경이므로 요청을 받습니다.그리고 라우터에는 메타데이터가 있습니다.
모든 데이터 액세스 샤드에 대해 요청을 어디로 라우팅할지 알 수 있습니다.그게 바로 라우터가 하는 일이죠, 그렇죠?샤드는 데이터가 있는 곳이거나 데이터의 일부가 있는 곳입니다.예를 들어보자면, 이것은 일종의
전자상거래를 단순하게 표현한 것입니다.
스토어프론트 SaaS 애플리케이션으로, 테넌트에 대한 개념이 있고 주문 테이블이 있고 그 다음 테이블이 있습니다.
도시, 주, 국가에 대한 모든 세금 세부 정보를 거의 조회 테이블처럼 저장합니다.그리고 보시면
세입자와 감사 테이블은, 그러니까 우리가 가지고 있는
거기에서 테넌트 ID를 위반했어요왜냐하면 샤딩 사이에
수동으로 해본 솔루션과 관리형 샤딩
데이터베이스가 무궁무진한 솔루션인데 아직도 한 가지 공통점이 있습니다.샤드 키라는 개념인데, 여전히 열을 식별하고 이를 샤드로 만들어야 합니다.
무제한 데이터베이스를 위한 키입니다.그리고 그 샤드 키를 사용해서
무한한 데이터베이스가 파티셔닝을 수행하는 방식입니다.이걸 좀 더 확장해 보면
특정 예를 들어, 주문 테이블은
이 특별한 경우에는 주문 테이블의 데이터를 여러 부분으로 나누어야 합니다.
다양한 샤드.따라서 샤드 키를 생성하거나 해당 테넌트를 식별할 때
무제한 데이터베이스와 같은 샤드 키로서의 아이디어
데이터 또는 데이터 조각을 전체에 배치할 것입니다.
여기 세 개의 다른 샤드가 있습니다.테넌트 테이블도 마찬가지입니다. 왜냐하면 테넌트 테이블에는
분명히 테넌트 ID가 있습니다.다시 말씀드리지만, 원하시는건
이건 파티셔닝해야 합니다.그래서 데이터베이스는 무궁무진합니다.
파티션을 서로 다른 샤드에 배치할 것입니다.우리가 이것을 배치된 테이블이라고 부르는 것을 볼 수 있습니다.따라서 코로케이티드 테이블은 동일한 샤드를 공유하는 두 개의 샤딩된 테이블입니다.이것의 장점은 동일한 샤드 키 값에 대한 모든 데이터가 동일한 샤드로 전송된다는 것입니다. 즉, 멀티 테넌트 환경에서 이 기능이 얼마나 유용한지 알 수 있습니다.따라서 격리가 가능합니다.
그리고 여러분이 찾고 있는 데이터의 분리.그리고 공연에서 말이죠.
관점에서 볼 때, 이것은 훌륭하게 작동합니다.왜냐하면 관련된 데이터이기 때문이죠.
특정 테넌트의 경우 동일한 샤드에 있습니다.그리고 전체적으로 볼 때 없으신 것 같아요.
이 모든 것을 혼자서 할 수 있는 건 무제한의 데이터베이스가 알아서 해준다는 거죠.마지막으로 세율입니다.그래서 우리는 이것을 참조라고 부릅니다.
무제한 데이터베이스 내의 테이블.이것은 룩업 테이블, 무한 데이터베이스이므로
그냥 전체 참조 테이블의 전체 복사본을 생성하기만 하면 됩니다.
모두 다른 샤드들이죠.이건 퍼포먼스 향상에 도움이 되죠. 네, 주로 퍼포먼스 향상에 도움이 되죠.이제 그게 전부였어요.
개념적인 측면에서는 예를 들어 테이블 생성 모드를 사용하여 세션 변수를 샤딩된 상태로 설정하는 것입니다.그리고 제가 말씀드린 것처럼 여러분은
샤드 키라는 컬럼을 찾을 수 있을 겁니다. 이 칼럼에서
이 경우 테넌트 ID가 됩니다.따라서 테넌트 테이블을 생성할 때 샤드 키를 지정합니다.그런 다음 배치된 주문 테이블에 대해서도 동일한 작업을 수행합니다.
뭐, 하지만 이렇게 말하겠죠. “이봐, 우린 함께 배치하고 싶어.
이것은 테넌트 테이블과 함께 “그래야 두 테이블의 데이터가 함께 배치될 것입니다.
같은 샤드 내에.”그리고 마침내 우리는
룩업 테이블인 tax_rate 테이블이 있어요.
또는 참조 테이블.따라서 다음과 같이 설정하실 수 있습니다.
세션 변수가 호출되어 테이블 모듈 참조를 생성하고 tax_rate 테이블을 생성합니다.따라서 샤딩을 계획하고 있고 Postgres 환경을 사용하고 있다면 반드시 고려해 보십시오.
이를 위한 Aurora의 무제한 데이터베이스 대신
혼자서 수동으로 샤딩을 해야 하는 번거로움을 해결하세요.좋아요, 이제 갈래요?- 멋지네요, 멋지네요.이제 막 이런 것들이 많이 나왔다는 걸 알 수 있죠.
작년 혹은 1년 반.그래서 리미트리스와 같은 것들은
데이터베이스 또는 데이터 API는 확장 가능한 멀티테넌트 스토리지 아키텍처를 만드는 데 정말 유용합니다.그리고 우리가 만드는 동안
우리의 아키텍처도 생각해야 합니다.
백업 같은 것에 대해서요.백업은 모든 스토리지 아키텍처의 표준 요구 사항이며 다행스럽게도 우리에게는 해결된 문제입니다.대부분의 스토리지 엔진은
백업 작업을 수행할 수 있는 기본 도구가 제공될 것입니다.
효율적인 방법으로 복원하세요.하지만 당면 과제는
SaaS 환경에 있는 우리 회사는 이를 보완하고 있다는 것입니다.
디스크 레이어에서 백업을 하세요.이제 훌륭하고 효율적입니다. 보통은 아무 것도 없습니다.
백업을 할 때 성능에 어느 정도 영향이 있긴 하지만, 만약 백업이 있다면
브리지 또는 풀 배포와 같은 공유 배포 모델은 다시 돌아가 보겠습니다.
모든 테넌트를 동시에 업그레이드하세요.그리고 이것은 우리가
그 백업을 복원하면 우리 전부를 복원할 거예요
동시에 세입자도 마찬가지죠.자, 만약 그게 우리의 모습이라면
노력은 괜찮아요. 하지만 우리가 원한다면 어떻게 될까요?
단일 테넌트를 복원하고 싶으세요?이제 테넌트 데이터를 분리하는 메커니즘을 도입해야 합니다.
공유 백업에서 나온 거죠.그리고 여기서 해결해야 할 과제는
우리의 기본 도구가 테넌트 파티셔닝과 같은 방식으로 작동하지 않을 수 있다는 것입니다.따라서 테넌트별 스키마 또는 테넌트별 데이터베이스를 구성한다면
브리지 모델 내에서는 다음과 같이 작동할 수 있습니다.
PG 덤프 같은 것들이죠.하지만 만약 우리가 이렇게 되면 어떻게 될까요?
공유 테이블이 있나요?뭐, 그냥 이렇게 말할 수는 없어요. “이봐, 이걸 바탕으로 추출해봐.
테넌트 ID, 작동하지 않을거야.”그래서 생성해야 할 수도 있습니다.
스스로 해결책을 찾아내세요.이로 인해 백업 및 복원 프로세스가 복잡해질 것입니다.이러한 복잡성이 도입되면 백업 중에 도입할지 아니면 도입할지 선택할 수 있습니다.
복원 중에 말이죠.일반적으로 사람들이 복원 중에 이를 도입하는 모습을 볼 수 있습니다.그 이유는 간단합니다. 간단한 백업 프로세스를 유지하고, 기본 백업 도구를 사용할 수 있고, AWS와 같은 것을 사용할 수 있기 때문입니다.
백업을 통해 대규모로 관리할 수 있습니다.이렇게 하면 백업 프로세스가 간편하고 쉬워지므로 복원 프로세스 중에만 복잡성이 발생합니다.그리고 우리는 일반적으로 훨씬 더 많은 작업을 수행합니다.
복구보다 백업이 더 중요하죠.사일로 상태에서는 이 작업을 어떻게 해낼 수 있을지 보더라도 아무런 변화가 없습니다.그냥 그 도구들을 사용할 수 있습니다.
백업 및 복원을 위해서요.하지만 브리지 모델에서는
테넌트별 스키마 또는 테넌트별 데이터베이스가 있습니다.
백업을 수행하면 모든 테넌트가
한 번에 백업됩니다.그래서 우리가 원할 때
이 백업에서 복원하면 임시 데이터베이스 또는 임시 저장소 엔진으로 복원됩니다. 그러면
모든 테넌트와 크기가 같습니다.그러니까 꽤 큰 규모가 될 수 있겠죠.
복원이 필요한 대규모 임시 데이터베이스.그러려면 비용이 많이 들 수 있습니다.그리고 나서 해야 할 일이 있어요
테넌트 데이터를 복원 데이터베이스에서 분리하세요.따라서 이것은 테넌트별 데이터베이스 또는 테넌트별 스키마이기 때문에
몇 가지 기본 도구를 사용하여 효율성을 높이고 동일한 도구를 사용하여 다시 가져올 수 있습니다.
라이브 데이터 세트로 말이죠.하지만 풀 모델을 보면 좀 더 복잡해집니다. 이제 복원을 할 때 효과적으로 해야 하기 때문이죠.
모든 테이블을 스캔하고 모든 항목을 전체 스캔하여 해당 테넌트에 속한 항목을 확인하십시오.풀 데이터베이스가 크면 시간이 오래 걸릴 수도 있습니다.심지어 스캔하는 데 며칠이 걸리는 것을 봤는데 이제 데이터를 추출했으니 다시 가져와야 합니다.
라이브 데이터 세트에 포함시키면 성능에 영향을 미칠 수 있습니다.권리를 소진하고 있습니다.
그 스토리지 엔진에서 말이에요.해야 할 수도 있습니다.
입력하기 전에 기존 데이터를 일부 삭제하세요.그리고 그것이 어떤 영향을 미칠지 생각해 보셔야 합니다.
다른 세입자들한테도 마찬가지고요.따라서 속도를 조절해야 할 수도 있습니다.
복원 프로세스에는 다음과 같은 몇 가지 단점이 있습니다.
거기에서 해내야 합니다.하지만 일반적으로
제가 본 대부분의 고객이 선호하는 접근 방식은 계속 사용할 수 있기 때문입니다.
이미 사용하고 있는 백업 프로세스를 수행하고 있으며 방금 도입했습니다.
복원 과정에서의 복잡성.하지만 몇 가지 이유가 있을 수 있습니다.
백업 시에도 분리가 가능합니다.따라서 사일로를 들여다보면 아무것도 바뀌지 않습니다.단순성은 떨어지지만 효율성은 떨어지지만 브리지 모델 안에서는 이제 이전과 동일한 분리 메커니즘을 사용할 수 있습니다. 하지만 지금은 하고 있습니다.
백업 단계에서 말이죠.자, 여기서 문제가 되는 것은 우리가 예전에 그랬을 때였습니다.
네이티브 툴을 사용해서 물리 계층에서 작업을 하고 있었습니다.따라서 성능에는 영향을 미치지 않았습니다.Dynamo나 Aurora 같은 것을 보면 프로덕션 데이터베이스의 성능에 전혀 영향을 주지 않습니다.하지만 이제는 소비해야 합니다.
권리, 아, 미안해, 읽었어읽은 걸 소비해야 돼요
우리 스토리지 엔진에서 보자면, 이건
성능에 영향을 미칩니다.하지만 이제는 테넌트당 백업이 제공됩니다.그리고 이건 정말 좋은 일이죠. 왜냐하면
복원을 할 때 복원 데이터베이스의 크기는 적당합니다. 단지 크기 그대로입니다.
복원을 시도하고 있습니다.물론 우리는 할 수 있어요
가서 이 데이터를 라이브 데이터 세트로 다시 가져오세요.그리고 주요 이점은
백업 시 분리 작업을 수행하면 모든 테넌트가 작업을 수행할 수 있습니다.
자체 백업을 확보하는 것이죠.그리고 이건 정말 유용할 수 있어요
준수해야 할 규정 또는 규정이 있는 경우아니면 글을 쓰신 적이 있을 수도 있습니다.
이제 테넌트 데이터를 하나의 논리적 단위로 사용할 수 있기 때문에 잊어버릴 수 있는 법입니다.백업 내에서도 운영 방식으로 작업할 수 있습니다.오프보딩 같은 것도 생각해 보세요.테넌트가 플랫폼을 떠나는 경우 해당 테넌트를 모두 삭제하고 싶을 것입니다.
데이터 (백업 포함)상상해 보세요.
규정 준수를 위한 보존 정책이 7년이고 임차인이 퇴사하고
백업을 공유하셨군요, 정말 가실 건가요?
그 모든 백업을 다 살펴보고 공유 백업에서 지워버리세요?아마 아닐 거예요.넌 그냥 끝날 거야
그들의 데이터에 대한 대가를 치르고 있음에도 불구하고
더 이상 돈 안 갚아요.그러니까 숙청할 수 있는 능력은
단일 테넌트의 데이터가 정말 유용할 수 있습니다.하지만 우리는 분리를 볼 수 있습니다.
백업과 복원은 모두 장단점이 있기 때문에 어떤 것을 할지 결정하는 것은 작업 내용에 따라 달라집니다.
비즈니스 요구 사항은 다음과 같습니다.따라서 이 점을 살펴보셔야 합니다.
결정을 내리기 전에그리고 우리에게 필요한 게 하나 더 있어요.
생각해 봐야 할 것은 공정성입니다.공정함이란 그냥
유료 고객으로서 제가 지불한 만큼의 보상을 받을 수 있다는 거죠.그래서 이게 프리 티어라면
뭐, 최선의 노력을 기울이실 수도 있겠지만 제가 실제로 돈을 준다면 성과가 있을 것으로 기대합니다.
그 비용은 제가 지불하고 있어요.저한테는 꽤 공평하죠, 그렇죠?하지만 한편으로는 SaaS 공급자로서 제 자신을 보호할 수 있다는 것도 공평합니다.
스토리지 인프라.한 명의 임차인이 다른 임차인의 삶을 나쁘게 만들 수는 없습니다. 우리는 시끄러운 이웃을 원하지 않습니다.따라서 이러한 공정성을 구현할 수 있는 메커니즘에 대해 생각해 볼 필요가 있습니다.그리고 이것은 꽤 괜찮을 수 있습니다.
아래로 내려가기엔 복잡한 토끼굴이네공정성을 발휘할 수 있는 방법은 많지만 자세히 알아보지는 않겠습니다.
오늘은 그 중 많은 부분에 대해 알아보겠습니다. 끝이 없으니까요.하지만 애플리케이션의 업스트림 속도 제한부터 시작하는 것이 좋습니다. 제한을 설정할 수 있기 때문입니다.
애플리케이션으로 들어오는 요청의 수와 그에 따른 결과에 따르면
스토리지로 들어오는 요청 수의 제한.그리고 아주 간단한 방법이 하나 있습니다.
이를 위해서는 사용 계획과 함께 API 게이트웨이를 사용하는 것입니다.그러니까 이게 총계라고 말씀하셨잖아요.
초당 요청 수 또는 동시 요청 수, 괜찮은 결과를 얻을 수 있습니다.
속도 제한 방식을 사용하여 시간을 줄일 수 있습니다.
스토리지 아키텍처를 한 단계 더 발전시켰습니다.공정성을 위한 또 다른 메커니즘도 있습니다.
이주가 될 겁니다.테넌트를 한 곳에서 옮기는 거죠.
스토리지 인스턴스를 다른 인스턴스로 옮기는데, 이 작업을 하고 있을 수도 있습니다.
시끄러운 이웃이거나 VIP 고객이 되었기 때문에 규모가 너무 커져서 자체 데이터베이스에 저장하게 되었습니다.또는 기본 등급에서 프리미엄 등급으로 상향 판매하여 자체 스토리지를 확보할 수도 있습니다.그러니까 요금 제한 업스트림
그리고 마이그레이션은 흔히 사용되는 두 가지 도구입니다.
공정성 패턴은 상당히 일찍 시작해야 합니다.그리고 우리가 많은 것들을 다뤘다는 걸 알아요. 그리고 당신은 정말 관심이 많으시다는 걸 알아요.
이 방에서 벗어나 호텔로 돌아가서 다음 스토리지 아키텍처 설계를 시작하세요.하지만 시작하기 전에
무엇이든 구현하는 것에 대해 생각해 보셨으면 좋겠어요
아키텍처를 위한 데이터 모델 만들기자, 이건 아무것도 아니에요
이는 SaaS에만 있는 일이죠.데이터 모델 설계는 잘 문서화되어 있습니다. DynamoDB 페이지를 살펴보면 훌륭한 지침이 있습니다.하지만 데이터 모델 내에 존재하는 항목, 항목 간의 관계 및 액세스 패턴을 매핑하는 것을 고려해 보십시오.좋은 데이터 모델을 만들면 성능이 뛰어나고 효율적이며 나중에 확장할 수 있기 때문입니다.
향후 액세스 패턴이 나타날 때를 대비해서 말이죠.그리고 몇 가지 사항이 있습니다.
SaaS 관점에서 생각해보고 싶은 것은
데이터 모델을 설계할 때첫 번째는
세입자의 물건들을 보관하고 있다는 것이죠.따라서 테넌트 ID를 이러한 모든 항목과 연결해야 하기 때문에 다음과 같은 방법이 필요하기 때문입니다.
해당 항목의 소유자가 누구인지 알려주세요.그 데이터를 테넌트 격리와 같은 용도로 사용할 것이기 때문입니다.
백업이나 마이그레이션도 마찬가지죠.따라서 테넌트가 소유해야 하고 테넌트가 소유해야 하는 방식도 마찬가지입니다.
메커니즘을 사용할 수 있습니다.우리는 효율성을 목표로 삼고 싶습니다.SaaS는 효율성을 높여줄 것입니다.그러니 효율성을 확실히 하세요.
이 데이터 모델을 만들 때 염두에 두어야 할 핵심입니다.따라서 동일한 스토리지 인스턴스 세트 또는 동일한 디스크 세트에 데이터를 함께 배치하는 등의 작업이 효율성을 높이는 데 도움이 될 것입니다.또 다른 한 가지는
스토리지와 병목 현상에 대해 이야기할 때
일반적으로 컴퓨팅이 병목 현상입니다.스토리지 인스턴스가 없어서 “이봐, 스토리지 인스턴스를 확장할 수 없어”라고 말하는 사람을 자주 볼 수 없습니다.
디스크 공간을 더 주세요.”보통은 컴퓨팅입니다.그리고 저장 공간이 컴퓨팅보다 저렴합니다.그래서 우리는 우리의 상황을 생각해 볼 수 있습니다.
일반적인 액세스 패턴, 일부 데이터 및 보조 인덱스나 뷰 같은 항목을 복제하여 이러한 기능을 제공할 수 있도록 함
액세스 패턴이 더 효율적입니다.시간이 좀 걸릴 것입니다.
컴퓨팅 요구 사항, 컴퓨팅 외부그걸 만들게 될 거예요
쿼리가 더 효율적입니다.그래야 우리가 할 수 있는 범위를 확장할 수 있죠.
스토리지 아키텍처가 한 단계 발전하면서 테넌트별 쿼리 성능이 향상되고 있습니다.제 말은, 두 배라는 뜻이죠.
이겨요.정말 멋져요.그리고 동시에 우리는
우리의 데이터 모델을 보면, 지금이 바로 여러분이
업스트림을 어떻게 설정할지 생각해 보고 싶으신가요?
애플리케이션의 제한.그러니까, 이건 그 일부가 아니에요.
데이터 모델 설계 그 자체지만, 서비스 팀과 이야기를 나눠보면 다음과 같은 메시지가 나타납니다.
“고객과 대화할 때 “업스트림 한도를 어떻게 설정할지”에 대해 생각해 보라고 말해달라는 말을 끊임없이 듣습니다.왜냐하면 일단 저장소가 없어서 스토리지가 다운되면
이러한 한도는 이미 늦었고 고객도 영향을 받을 수 있습니다.그리고 오늘은 많은 내용을 다루었습니다.우리는 정말 많은 것들과 많은 것들을 훑어봤어요.
아직 다루지 못했어요.콘텐츠가 훨씬 더 많아서 만족스러운 팀이 콘텐츠를 만들고 있습니다.내부 팀들이 무언가를 만들고 있어요.SaaS를 위한 데이터가 있습니다.
AWS 샘플의 패턴 리포지토리인 GitHub에 있습니다.관심이 있으시다면
더 자세히 살펴보자면, 거기에 예가 있습니다.
베스트 프랙티스가 있어요.에 대한 데이터를 생성했습니다.
SaaS 유튜브 동영상 시리즈.링크를 따라 가서 보고 몇 가지를 살펴보세요.
이러한 개념들 중 더 자세히 설명해 드리겠습니다.더 좋은 점은 GitHub 리포지토리이기 때문에 이슈를 생성할 수 있다는 것입니다.어떤 것을 보고 싶은지 알려주세요.저희가 여러분을 위해 콘텐츠를 만드는 모습입니다.그러니 피드백을 보내주세요.보고 싶은 패턴과 당면 과제를 알려주세요.그리고 그것이 우리를 다음 방향으로 이끌고 있습니다.
세션이 끝났습니다.그리고 우리가 시사하는 점을 생각해보면, 여러분께 말씀드리고 싶은 것이 있습니다.
이 세션에서 배운 점, 기억하세요
SaaS는 규모를 확장하고 낭비를 늘리고 효율성을 확장할 것입니다.그리고 그 효율성은
수익을 창출하느냐 못하느냐의 차이일 수 있습니다.따라서 효율성이 좋아야 합니다.
스토리지 아키텍처에 대해 이야기할 때 일등공신이라고 할 수 있습니다.
그 성장 단계에 있는 거죠.이 세 가지를 기억하세요.
스케일링 호스맨 맞죠?수직적 스케일링이 있어요.
연결 관리, 수평적 스케일링.구현하기 전에 가능한 한 많이 사용하세요.
샤딩과 같은 것은 단방향 결정일 수 있기 때문에 차세대 스케일링 접근 방식입니다.샤딩을 한 번 구현하면 아키텍처에 큰 변화가 생겨 되돌리기가 매우 어렵습니다.그러니 좀 더 확장해 보세요.
가능한 한 많이 보관하세요.해당 테넌트를 함께 배치하세요
테넌트 ID가 포함된 데이터, 항목이 다음과 같은지 확인하십시오.
해당 테넌트가 소유합니다.테넌트 ID와 관련된 테넌트 데이터이므로 권한이 없어야 합니다.함께 배치하여 사용할 수 있습니다.
운영상의 이유도 마찬가지입니다.삶을 더 편하게 만드세요
테넌트 데이터를 백업에서도 사용할 수 있는 논리적 단위로 사용함으로써 가능합니다.공정성에 대해 생각해 보세요.
업스트림 속도 제한, 일부 마이그레이션 프로세스 구현.다음과 같은 것들이 있습니다.
사업을 확장하고 확장할 때 필요하게 될 것입니다.
스토리지 아키텍처.자, 여기 계신다면
월요일 이맘때면 분명 피곤하실 거예요. 하지만 SaaS가 정말 마음에 드실 거예요.그리고 이번 주 re:Invent에서는 많은 SaaS 세션이 준비되어 있습니다.그러니 나가서 그 중 몇 가지를 살펴보는 것이 좋습니다.테넌트 격리에 관심이 있거나 문제가 있다면 좋은 세션이 준비되어 있습니다.
내일은 SaaS 312와 함께할 예정입니다.자, 초크 토크에 오셔서 패턴을 좀 보세요.많은 워크숍이 진행 중이에요.그러니 참여하고 싶으시다면
구현을 좀 하고, 직접 코드를 작성하고, 나가서 서포터들과 이야기를 나눠보세요.그들은 일하고 있는 사람들이에요.
SaaS를 통해 매일 많은 고객과 함께합니다.문제를 제기하고 상담하세요
얘들아, 정말 좋은 기회야빌더 세션이 몇 개 있어요.re:Invent에서 처음
빌더 세션용.그러니 나가서 어떤 내용인지 확인해 보세요.거기서 즐거운 시간을 보내세요.설문조사가 있어요.모두 알고 계실 거라 확신합니다
지금쯤이면 설문조사에 대해서요. 하지만 이건 정말 중요하죠.첫째, 우리에게 중요한 것은
우리가 잘했는지 아닌지를 아는 것, 하지만 더 중요한 것은, 지금이 바로 여러분이 원하는 것에 대해 피드백을 줄 수 있는 기회라는 것입니다.
콘텐츠 측면에서 보세요.뭘 보고 싶으세요?
내년에 제작할 거예요?뭘 보고 싶으세요?
내년엔 re:Invent에서?그럼 그 메커니즘을 사용하세요.
피드백을 보내주세요.어떤 문제가 있으세요?어떻게 도와드릴까요?
SaaS를 더 확장하고 싶으신가요?이게 성공했으면 좋겠어요.
좋은 학습 경험이었어요. 오늘 좋은 세션이었어요.란지스와 저를 대신해서
오늘 시간을 내어 주셔서 감사드리며 좋은 시간 되시길 바랍니다.
re:Invent는 앞으로도 계속 발전해 나갈 것입니다.정말 고마워요.
- 정말 고마워요.(관중들의 박수 갈채)