- 안녕하세요.리인벤트 2024에 오신 것을 환영합니다.오늘 저희 세 명이 “실패하지 않는 실패: AWS에서 힘들게 배운 교훈”에 대해 이야기하기 위해 모였습니다.제 이름은 알렉 피터슨입니다.저는
AWS의 레질리언스 담당 부사장입니다.저는 복원력 외에도 Route 53을 소유하고 있습니다. 많은 분들이 이 서비스를 사용해 주셨으면 좋겠습니다.부사장 겸 저명한 엔지니어인 베키 와이스 (Becky Weiss) 도 합류했습니다.그녀는 현재 IAM 팀에 소속되어 있지만, 여러 곳을 둘러본 경험이 있습니다.
제 생각에는 S3, EC2, DNS, 프로페셔널 서비스에서 근무하고 있는 것 같아요. - [베키] 네. - 선임 책임자인 Mike Furr도 합류했습니다.
EC2 팀의 엔지니어.자, 이 강연은 사실
우리 셋이 작년에 했던 세션을 토대로 삼아 진행했는데, 그 세션은 “파이브”라고 불렸어요.
대규모 레질리언스에 대해 모두가 알았으면 하는 것들.”올해에는 기본적으로 더 많은 것들이 있습니다.하지만 이 세션의 목표는 같습니다. 여러분이 레질리언스가 규모와 적용 시기에 어떻게 다르게 보일 수 있는지에 대한 뻔하지 않은 교훈을 얻으셨으면 좋겠습니다.
조금 더 작을 수도 있습니다.오늘 다룰 주제는 지속적인 연결에 관한 것입니다.
제가 말씀드리려고 하는데요.베키가 우리랑 얘기할 거예요
안정적인 스케일링에 대해 말하자면 마이크가 우리한테 얘기할 거예요
병목 현상 측정에 대해서요.그래서 저는 레질리언스를 선택했습니다.
그리고 지속적인 연결은 패턴이기 때문이죠.
제가 본 것은 대규모에서만 볼 수 있는 것이 아닙니다.
AWS의 분산 시스템이긴 하지만, 제가 본 바로는
많은 고객들도 마찬가지죠.충분히 자주 봐서 그만한 가치가 있다고 생각해요
지속적 연결이 잠재적으로 부정적인 영향을 미칠 수 있는 이유에 대한 첫 번째 원칙을 이해하는 것에 대해 진지하게 이야기하고 있습니다.
레질리언스에 미치는 영향.자, 먼저 레벨을 설정해 볼게요.이것은 300레벨 세션입니다.아마 다들 알고 계실 겁니다.
하지만 몇 가지 마이크로서비스에 대해 이야기할 것이고 저는 그 용어에 대해서만 말씀드리고 싶습니다.
우리가 사용하게 될 겁니다.그래서 제가 생각하고 있는 건
마이크로서비스에 대해 이야기할 때는 수평적 분산 시스템이죠.따라서 이것은 여러 개의 개별 구성 요소로 구성된 논리적 서비스입니다.인스턴스일 수도 있고, 작업일 수도 있고,
컨테이너일 수도 있습니다.다음과 같은 경우 시스템이 확장됩니다.
용량이 더 필요할 때, 용량이 더 적게 필요할 때는 규모를 축소합니다.따라서 해당 레벨이 설정되면
이러한 분산 시스템에서는 일반적으로 문제가 발생할 것으로 예상합니다.여기서 사용할 모델은
이 논의의 경우 마이크로서비스를 제공하는 프런트엔드 서비스가 포함된 아주 간단한 설명입니다. 그러면 이 프런트엔드 서비스는 인증 서비스를 사용하여 요청을 보호하는 데 도움이 됩니다.따라서 각 프런트 엔드 서비스, 즉 인스턴스가 해당 프런트 엔드에 있게 됩니다.
서비스, 해당 인스턴스의 각 인스턴스에 연결
인증 서비스.이러한 연결은 다음과 같습니다.
로드 밸런서, 아마도 DNS 계층 같은 것에 의해 조정됩니다.
그건 중요하지 않아요.그러니까 인증 중 하나가 되면 어떤 일이 벌어질까요?
서비스에 문제가 생기면 프런트 엔드는 중간 메커니즘을 통해 프런트 엔드 서비스가 중지됨을 감지합니다.
해당 세 번째 서비스와 대화하고 있습니다.이제 그들은 대화만 합니다.
둘은 멋지고 단순합니다.하지만 이 사진에서 빠진 게 있어요.이건, 말씀드렸듯이, 이건
지나치게 단순화되었습니다.실제 내용이 누락되었습니다.
메시지 그 자체.서비스가 누락됐어요
실제로 뭔가를 하고 있네요.그럼 두 번 클릭해 보죠.실제로, 이건
좀 더 복잡하죠.언제 처음 건물을 지을 수 있을까요?
이런 종류의 프론트엔드를 갖춘 마이크로서비스 아키텍처와
인증 아키텍처, 하나는 두 가지일 것입니다.
마이크로서비스의 경우 프런트 엔드 서비스에 메시지가 있을 것입니다.인증 서비스에 문의해야겠다고들 하시겠죠.연결을 할 수 있을 거예요.그걸 보내면 될 거예요
인증 서비스의 서비스를 통해 메시지를 보내면 인증 서비스가 이에 응답합니다.멋지고 간단하죠?대규모로 봤을 때를 제외하면
좀 비싸다는 거죠.연결 오버헤드, TCP 지연 시간 오버헤드가 발생합니다.
TLS 핸드셰이크 오버헤드는 우리 모두가 암호화하고 있기 때문입니다.
이제 우리 연결이 됐죠?멋지네요.이로 인해 비용과 지연 시간이 늘어납니다.따라서 서비스가 시작되면
규모를 확장하려면 비용을 개선할 수 있는 기회가 있다는 것을 알 수 있습니다.그러면 다음을 수행할 수 있습니다.
지속적인 연결.따라서 모든 사용자를 위해 TCP와 TLS 연결을 만드는 대신
요청을 하면 다음을 위해 해당 연결을 만들 수 있습니다.
첫 번째 요청이 들어오거나, 첫 번째 요청이 들어올 때
서비스를 반송한 후 엔드 서비스가 먼저 시작됩니다.그러면 여러 개를 보내게 됩니다.
진짜를 통한 메시지, 상대방과의 연결
인증 서비스.인증 서비스가 처리해 줄 것입니다.이제 수많은 메시지, 잠재적으로 수백만 개의 메시지에서 해당 연결 비용을 상각할 수 있습니다.연결 비용
이제 기본적으로 무료입니다.기념 케이크.그러니 윈-윈.하지만 연결이 끊기면 어떻게 될까요?그래서 여기가 문제인 거죠.
흥미로워지기 시작하세요. 지금은 연결을 만드는 대신
매번 망가뜨리면서
매번 연결이 이루어지면 거의 모든 서비스가 제공됩니다.
물론 시작할 때 연결을 한 번 생성한 다음 다음과 같이 가정하면
연결은 여전히 있을 것입니다.그래서 메시지를 여러 개 보내면
연결 전반에 걸쳐 말이죠.자, 어느 시점에서든
어느 시점이든 가능하죠. 서비스 중 하나가 여기에 있습니다.
인증 서비스가 실패했습니다.이제 이러한 연결에 실패하고 이러한 메시지가 확정된 상태로 멈춥니다.이것이 우리가 보는 전형적인 패턴입니다.이런 저울을 쓰면
다시 말씀드리지만, 인스턴스가 세 개이고 양쪽에 세 개의 인스턴스가 있으면 연결 설정이 중단될 수 있습니다.따라서 어떤 종류가 있을 수 있습니다.
아, 그냥 프론트엔드 서비스를 반송하라고 하는 프로세스죠.어느 정도 영향력이 있긴 하지만 이봐, 회복되긴 했어.아직 가지고 있잖아
지속적인 연결.별거 아니에요.하지만 이게 만들어낸 게
이 경우에는 복원력이 위험하지만 규모가 훨씬 더 큽니다.그럼 수학을 좀 더 살펴보죠.어베일에 대해 생각해 볼게요
가용성 백분율.다음과 같이 정의하겠습니다.
모든 시스템 구성 요소가 온라인 상태인 시간의 비율입니다.개인적으로는 다음과 같이 정의할 수 있습니다.
시간의 힘으로 끌어올린 개별 요소는
구성 요소의 개수.그럼 모든 구성 요소를 가정해 봅시다.
가용성은 99.99% 입니다.사실 아주 좋아요.
인스턴스 가용성의 경우 일반적으로 더 낮을 수 있지만 이는 좋은 가정입니다.
시작점으로서요.따라서 시스템에 10이 있다면
구성 요소, 99.99% 를 10제곱으로 올렸다면 해당 시스템의 가용성은 99.9% 가 됩니다.하지만 이제 구성 요소가 10,000개라면 36.8% 로 줄어듭니다.자, 저는 이것이 수학적인 것이 아니라 실제로 작동하는 방식이 아니라는 것을 압니다.이건 수학적인 겁니다. 가정하면
모든 실패는 눈에 띄지 않지만, 아시다시피 여러분은 그저
실패의 기회가 너무 많아요이제 갑자기 회복력에 큰 문제가 생겼습니다.그리고 우리의 경험은
이런 경우 실제로 몽유병 같은 느낌을 받을 수 있습니다.
몇 가지 상황을 보고 나서 요점을 찾아내세요.
시스템이 제멋대로인 곳에서는 점점 더 나빠지고 있습니다.그리고 재미있게도 이런 근본적인 문제가 생겼습니다.
시스템의 신뢰성은, 규모가 커질수록 기회가 더 많아지기 때문이죠.
예를 들어 이런 종류의 장애.하지만 더 많은 것들도
예를 들어 네트워크 범위가 더 넓습니다.네트워크는 다음과 같을 수 있습니다.
가장 큰 속성 중 하나로 생각할 수 있습니다.
지구상의 시스템.네트워크 컨트롤 플레인,
네트워크를 구동하는 라이딩 프로토콜은 네트워크가 한 쌍의 목적지 한 쌍을 통해 A 지점에서 B 지점으로 어떻게 이동하는지에 대한 그림을 제공합니다.네트워크가 바뀌면 브리딩 프로토콜은
가서 다시 계산해 봐야죠.모든 패킷에 대해 그런 건 아니에요.네트워크가 바뀌면 그렇게 하죠.장치 수가 많을수록
네트워크가 연결될수록 일이 잘못될 가능성이 커지죠.
연결이 끊어질 가능성이 커집니다.배포도 마찬가지죠?배포는 그냥 할 수 있습니다.
문제가 생길 수 있습니다.대부분의 경우
시스템에 문제가 생겼어요. 배포 때문이에요.구성 요소가 많을수록
시스템 일수록 배포가 잘못될 가능성이 커집니다.
오류가 발생할 확률이 높아지고 로드가 급증할 가능성도 커집니다.기회가 너무 많아요
이런 상황이 생기면 회복력 위험이 나타날 수 있으니까요.
연결과 기본 패브릭, 변하지 않는 인프라에 따라 달라지는 일종의 시스템 상태입니다.그리고 이로 인해 우리는
우리가 시스템을 다루는 방식과 이에 대해 이야기하는 방식에 적용하게 된 가설
고객에 대한 회복력.이것이 바로 애플리케이션의 복원력입니다.
복구 빈도에 일정 부분 비례합니다.
워크플로가 실행됩니다.그리고 이것은 단지 마이크로서비스 간의 연결에 관한 것이 아닙니다. 그렇죠?스택의 어느 계층에서든 레질리언스 이벤트가 발생할 수 있으며, 더 자주 발생할수록
복구 작업을 실행하세요.워크플로우는 바로 여러분입니다.
복구 중에 할 수 있는 일일수록 복원력이 더 강해집니다.
시스템 규모가 커질 것입니다.따라서 이 내용은 다음과 같습니다.
인프라 교체.다음 워크플로를 기억하세요.
그리고, 그 인증 서비스가 실패하면
자, 그럼 그 서비스는
그러면 그 인스턴스를 더 잘 대체할 수 있습니다. 왜냐하면
항상 그렇게 하고 있어요.실제로 해당 워크플로를 정기적으로 실행하도록 하고 싶을 것입니다.마찬가지로, 메시지 버스도
및 이벤트 버스 연결.많이 분산되어 있습니다.
요즘 시스템은 메시지 버스 연결을 사용하여 분산 시스템 내에서 상태를 교환합니다.메시지 버스에 문제가 있거나 네트워크 문제가 있는 경우
이로 인해 메시지 버스와의 연결이 다음과 같이 됩니다.
장애가 발생하면 해당 연결을 다시 시작할 수 없습니다.
매우 중요합니다.다시 한 번 말씀드리지만, 지도자 선거는
분산 시스템에서는 그 중 일부에는 다음이 필요합니다.
리더를 선출하기 위한 리더 선택 알고리즘.생각할 수 있는 시스템이 많을수록 가능하다고 생각할 수 있습니다.
실패할수록 리더 선거를 더 자주 실행해야 할 수도 있습니다.AZ 대피이기도 하죠, 그렇죠?그건 일종의 실패라고 할 수 있겠죠.
인프라 문제로 인해 다음과 같은 문제가 발생할 수 있습니다.
가용 영역을 벗어났습니다.당신이 되고 싶은 무언가
정기적으로 할 수 있어요.그리고 당신이 원하는 다른 많은 것들이 있어요, 당신은
생각해 볼 수도 있겠네요. 알렉, 그러니까, 연결 재사용에 대해 말씀하시는 줄 알았는데요.그럼 그런 말씀이신 건가요?
레질리언스 리스크와 관련이 있나요?- 그래요.여기까지가 해결책입니다.
연결 재사용에 관한 얘기가 흥미로워요.왜냐하면 다시 생각해보면
매번 모든 연결이 만들어지는 초기의 아키텍처에는 비용이 많이 들었지만
믿을 수 없을 정도로 탄력적이었죠.하지만 그런 건 아니에요.
옵션은 두 가지뿐이죠, 그렇죠?그럼 여기에 대한 답은
정기적으로 연결을 다시 설정하세요.따라서 연결이 끊어지지 않도록 연결 수명을 설정하세요.
말하자면 몇 분 이상 살 수 있잖아요, 그렇죠?아직 기회가 있잖아
연결 비용을 상각하려면
시스템 사용량에 따라 메시지가 수백 개 또는 수천 개에 달할 수도 있습니다.하지만 여러분은 시스템이 실제로 아주 잘 작동하도록 강요하고 있습니다.
연결부 교체.그래서 실제로
인프라 이벤트가 발생하면 연결을 재설정하는 프로세스를 의미합니다.
항상 해오던 일이고, 그럴 수도 있습니다.
고객에게 원활하게 다가가세요.이러한 접근 방식을 당사 스택의 다른 곳에도 적용할 수 있습니다.그 중 하나를 말씀드렸는데
제가 소유하고 있는 서비스는 Route 53입니다.Route 53의 신뢰할 수 있는 DNS 서비스는 네트워킹을 사용합니다.
네트워크가 결정하지 않는 한 기본적으로 결정을 내리는 Anycast라는 기술
네트워크를 통해 트래픽을 보낼 위치.의도적으로 설계했습니다.
Route 53 네트워크에서는 Route 53이 팝업되도록 했습니다.이것이 엣지 로케이션입니다.
쿼리를 제공하는 서비스는 특별히 중요하지 않습니다.
각 개인에 대한 회복력이 뛰어납니다.첫째, 제 생각엔 그들이 가지고 있는 것 같아요.
지금은 라우터가 여러 개 있지만 처음 그 시스템을 만들었을 때는 3번 라우터마다 라우터가 하나밖에 없었습니다.괜찮았어요. 왜냐하면
삭제해야 하는 이벤트들을 자주 봤는데
라우터가 다운되거나 배포를 해야 한다는 이유만으로 서비스에서 항목을 제거하세요.
뭐 그런 식으로요.우린 퍼팅에 아주 능숙해졌어요
시스템을 가동하고 시스템을 사용하지 못하게 하는 거죠.즉, 고객이
경험은 투명했습니다.그리고 계속 진행해오면서
이제 막 늘어났던 서비스를 확장하기 위해서죠.Route 53이 가장 복원력이 뛰어난 이유 중 하나이기도 합니다.
정기적으로 서비스를 제공하기 때문에 우리가 보유한 서비스
복구 워크플로우 실행.그러니까 진짜 뭔가가 있을 때는
예상치 못한 일이 생기더라도 우린 괜찮아요. 왜냐하면
시스템을 서비스에서 제거하는 복구 워크플로 같은 건 아마 지난 며칠 동안 이미 몇 번 해봤을 겁니다.그래서 우리는 그것이 좋은 일이라는 것을 알고 있고
시스템이 그걸 견딜 수 있다는 걸 알아요.여기서 얻으셨으면 하는 교훈은
복원력이 뛰어난 시스템은 모든 계층에서 장애를 수용하고 예상합니다.가장 일반적인 방법 중 하나
이를 수용하지 않는 고객의 입장에서 볼 수 있는 것은 바로 연결을 관리하는 방식입니다.
그들의 애플리케이션 내에서 말이죠.그리고 중요한 건
이런 포럼을 통해 고객들과 이야기를 나눕니다.그 중 하나이기 때문이죠.
그 부분을 많이 볼 수 없기 때문에 우리가 잘 알아차리지 못하는 것들이죠.
고객의 애플리케이션.인프라만 볼 수 있습니다.
연결 상태가 어떤지 꼭 알 수는 없습니다.
상위 수준에서 관리됩니다.어떻게 지내는지 생각해 보세요.
인맥을 관리할 뿐만 아니라 모든 것에 대해서도 생각해 보세요
다음과 같은 문제가 발생할 경우 잠재적으로 영향을 받을 수 있는 시스템 측면
그럴듯한 실패 시나리오그 것들은 뭐죠?
밤에 잘 수 있게 해주실 수 있나요?그리고 제작에 정말 집중하세요
항상 하고 있는 일들, 그래서 예상치 못한 일이 생겼을 때
상황이 발생하면 훨씬 더 빨리 회복할 수 있습니다.그걸로 제가 하고 싶은 건
베키한테 맡기세요. - 좋아요, 알렉 정말 고마워요.한 가지 자세히 살펴볼게요. 알렉이 잠깐 얘기한 적이 있어요.
이러한 복구 워크플로, 그리고 거의 사용하지 않는다면 어떻게 이렇게 될 수 있을까요?
회복탄력성을 위험에 빠뜨릴 수 있는 현상 유지.그 중 가장 많이 나오는 것 중 하나를 자세히 살펴볼게요
시간은 점점 커지고 있습니다.그러니까 모든 좋은 논쟁은 밀짚맨으로부터 시작되죠.자, 이제 이걸 시작할게요
밀짚맨을 예로 들자면, 클라우드 환경에서는 효과가 없을 수 있겠죠.그러지 않는 방법은 다음과 같습니다.
클라우드에서는 효과적입니다.애플리케이션을 실행 중인데
클라우드에 있어요. 아시다시피, 고장난 게 아니에요. 제가 고치지도 않아요.그냥 놔두고, 그냥 놔두고, 이 서버들은 놔두고
그냥 영원히 달릴 뿐이야교체하거나, 확장하거나, 축소하지 않아요.여기 있어요. 영원히 운영되고 있어요.식물은 데이터를 기반으로 성장합니다.
센터, 실제로는 그렇지 않아요.알다시피, 아시다시피, 실제로 이것은
알다시피, 클라우드에서 이 작업을 수행하는 올바른 방법이죠.지금 여기 계신 거잖아요
re:Invent 클라우드 컨퍼런스.올바른 방법을 알고 계실 겁니다.
좀 더 비슷하죠.물론 AWS에서는
이를 도와주는 서비스.오토 스케일링이 있습니다.로드할 수 있습니다.
바로 앞에 밸런서가 있습니다.이게 친절하다는 거 알잖아요
어떻게 보일지물론, 거기에는 그보다 더 많은 것이 있습니다.여러분이 사용하는 모든 애플리케이션
실행 중일 수 있는 일부 데이터에는 이와 관련된 데이터가 있을 수 있습니다.글쎄요, 우리는 우리가 가지고 있는 AWS입니다.
여기서는 확장과 가용성, 관리 측면에서 다루었습니다.
스토리지의 레질리언스.우리는 모두 다른 것을 가지고 있습니다.
우리에겐 스토리지가 있고, 오브젝트와 파일 스토리지가 있고,
관계형 데이터베이스, 비관계형 데이터베이스도 있죠.그 밖에도 온갖 종류가 있습니다.
지팡이를 놓을 곳.그리고 좋은 소식은
이 예쁜 제품들의 가용성과 확장성은
많은 부분이 여러분을 위해 관리되었습니다.물론, 가끔은
여러분은 다음과 같은 상황에 처하게 될 것입니다.
호스트에 실제로 상태가 있는 서비스를 운영하고 있는 거잖아요. - [패널리스트] 왜
하고 싶은데요, 베키?- 네, 더 힘들 것 같죠?이런 식인데, 왜 선택하겠어요?글쎄요, 이건 사실
아주 좋은 숙소들이 몇 개 있는데, 그게 바로 여러분이
아마 실제로 하고 있는 것 같아요.한 가지 중요한 것은 이 호스트들이 보상을 받을 때
사용자, 고객의 요청은 데이터가 바로 거기에 있기 때문에 굳이 받을 필요가 없습니다.
종속성이 심화되면 요청에 종속성이 추가되고 지연 시간도 늘어납니다.컴퓨터에 캐시가 있는 경우
호스트, 물건을 캐싱하고 있는데 이런 상황에 처해 있습니다.물론 이 플릿을 확장하는 것에 대해 생각해보면
단순히 새 호스트를 데려오는 문제가 아닙니다.
서비스를 시작했는데 실제로 데이터를 로드하는 것은 순조롭게 진행되고 있습니다.
이 호스트에 맞죠?그러니까 이 호스트는 진짜가 아니에요
트래픽을 완벽하게 처리하고 원하는 방식으로 수행할 준비가 되어 있습니다.시간이 조금 더 걸립니다.그리고 당신이 현장에 있을 때 그걸 설명할게요
상황, 시간이 실제로 얼마나 가치가 있는지, 이 시간은 실제로 그만한 가치가 있습니다.
주의와 최적화.그 이유는 다음과 같습니다.어느 날, 구름 속을 달리고 다니게 되죠.
자신의 사업을 관리하고 더 높은 수준의 소득을 창출합니다.
계획했던 것보다 부하가 많이 걸리죠?일정량의 로드를 계획하는 경우, 어쩌면 오버프로비저닝할 수도 있습니다.
약간이요.하지만 제가 말하고자 하는 것은 부하가 이보다 훨씬 높은 수준이라는 것입니다.
그 일이 일어났습니다.아마 이렇게 생각하실 수도 있겠죠.
일종의 DDoS 공격 같은 것에 대해 말씀드리는 거예요.
사실, 실제로 이런 상황이 발생할 수 있습니다.
그것도 좋은 소식일 때 말이에요.알다시피, 당신이 팔고 있는 물건은 아주, 아주 인기를 얻게 되죠.트래픽이 더 많이 유입되고 있습니다.
계획했던 것보다 더 많은 사람들이 앉아서 이 정도 교통 체증에 대비하지 못했다는 안타까움을 느낄 수 있습니다.하지만 물론, 아시다시피
이런 일이 벌어지면 호스트에 과부하가 걸리고
브라우닝 상태가 되고 있습니다. 성능이 저하된 것일 수도 있습니다.
당신이 원하는 만큼은 아니죠.그리고 이걸 어떻게 벗어날 수 있죠?왜냐면 당연히 넌
이 상황을 어떻게 완화할 수 있을지 고민하고 있습니다.
가능한 한 빨리이런 경우에 우리가 생각하는 것이 바로 그것입니다.그럼, 어떻게 하세요?자, 저희 무기고에는 규모를 키우고 있는 도구가 있습니다.제가 말씀드린 것처럼 보통은
프로비저닝을 너무 많이 하려고 노력하세요. 하지만 알다시피, 만약
예상했던 것보다 더 많은 부하를 받게 되면,
규모 확대를 통해 얻을 수 있는 상황은 꽤 많습니다.
감옥에서 탈출할 수 있는 건 무료인가요?감옥에서 나가세요, 감옥에서 나오세요. 물론 금액은
이걸 완화하는 데 시간이 좀 걸릴거야, 넌
그 위에 상태를 불러와야 돼요그러니까 이건 마치
생각해 볼 게 있어요.그냥 지나치길 바랄 순 없죠.사실이야, 생각해 봐.그리고 제가 실제로 들어가서 한 시대에 관한 이야기를 좀 해드릴게요.
이게 언제 우리를 괴롭히게 됐는지, 어떻게 했냐고요.이 이야기의 제목은 배포인가 아니면 문제가 있는가입니다.그리고 다음에 대해 얘기할게요.
아, 이건 제가 10년 전에 일했던 실제 서비스예요.이 부분은 EC2에서 DNS 확인을 도와주는 부분입니다.
EC2 인스턴스를 보유한 고객을 위한 쿼리.2024년으로 접어든 지금은 꽤 오래되었습니다.
몇 년이 지난 지금, 이 기능들은
Route 53 리졸버라고 불렀는데 10년 전에는 할 수 없었던 많은 일을 이 리졸버로 할 수 있었습니다.그 당시에는 이름도 없었고 DNS와 EC2만 있었습니다.물론 우리는 다음을 실행합니다.
우리가 운영하는 시스템은 최초의 홉 시스템과 비슷합니다.
다양한 종류의 요청을 분류하고 전달하세요.
알다시피, 오른쪽으로 보내면 올바른 위치로 되돌아가서 DNS 응답을 받을 수 있습니다.제가 말씀드릴게요.한 가지 말씀드릴 것은 제가 배웠다는 거예요.
10년 전의 이야기를 들려드리죠. EC2가 지금 한창이기 때문이죠.
오늘날의 규모는 10년 전과는 근본적으로 다릅니다. 사실상 모든 시스템은
여기서 말씀드리자면, 거의 또는 거의 더 이상 존재하지 않습니다.말 그대로 존재하지 않거나 테세우스형 배일 수도 있습니다.
아주 크게 규모를 늘려서 기본적으로
다른 것이죠.그럼 제가 조금 말씀드릴게요.
이것이 무엇을 했는지, 그리고 어떻게 시작하게 되었는지에 대해 조금 설명해 드리겠습니다.
배포에 문제가 생겼습니다.그래서 고객이
가상 사설에서 EC2 인스턴스를 시작합니다.
클라우드와 해당 VPC는 다음과 같다고 가정합니다.
공개적으로 라우팅할 수 있는 인스턴스란 해당 인스턴스에 퍼블릭 IPv4 주소가 있다는 것을 의미하며, EC2를 유용하게 확인할 수 있습니다.
이 DNS 이름을 할당합니다.보시다시피 DNS 이름에는 퍼블릭 IP 주소가 분명히 나와 있습니다.
일종의 내장형이죠.이 DNS 이름은
일종의 흥미롭고 유용한 속성이죠.그래서 제가 여러분의 가상 사설 클라우드 밖에서 인터넷을 사용해서 DNS를 해결하면
이름, 여러분이 생각하는 것과 정확히 일치하고,
이게 정답이에요. 왜냐하면 이 52개의 점이 있으니까요.
퍼블릭 IP 주소: 정확히 이 주소까지 도달해야 하는 방법
인터넷에서 인터넷 게이트웨이를 통한 인스턴스
가상 사설 클라우드에서물론 제가 VPC 내부의 다른 EC2 인스턴스에 앉아 있거나 내부에 약간의 컴퓨팅이 있는 경우에는
VPC는 사실 퍼블릭 IP 주소입니다.
다른 인스턴스에 도달하고 싶은 방법이 아니에요.
그러려면 나가서 다시 들어가야 할 것 같아요.아니요, 사실 당신 인스턴스는
네트워크에 프라이빗 IP 주소가 있고 저는
이 EC2의 DNS 이름과 동일한 DNS 이름을 알고 싶습니다.
인스턴스가 이를 확인합니다.이것이 바로 DNS입니다.
DNS와 EC2가 수행한 중요한 기능 중 하나이며
고객에게 도움이 됩니다.좋아요, 그럼 어떻게 작동할까요?자, 그럼, 서로 다른 EC2 인스턴스가 두 개 있다고 상상해 보세요.
가용 영역.따라서 EC2 인스턴스 인스턴스는
일부 애플리케이션이 DNS 쿼리를 생성할 때 첫 번째 가용 영역에서 1위입니다.첫 번째 홉은
어디에 있는지 알아내야 했던 이 포워더들은
어떤 종류의 쿼리인가요?누가 물어보는 거지, 뭘 묻는 거지?이걸로 뭘 할 건데?이 DNS 호스트는 인스턴스와 동일한 가용 영역에 있었습니다.EC2에서 가용성을 구현하는 방법에 대해 조금이라도 알고 있다면 영역 수준에서 이를 생각하고 있다는 것을 알 수 있기 때문입니다.그리고 또 다른 것도 있는데, 저는
이 중 하나를 보여드리자면, 가용 영역에는 아주, 아주, 아주, 아주 많은 것들이 있습니다.쿼리도 그렇고, 쿼리 인스턴스 1도
예를 들어, DNS 이름을 묻는 거죠. 두 번째 질문이죠.그렇다면 이 DNS 포워더는 어떤 질문에 답해야 할까요?같은 VPC에 있는 누군가에 대해 물어보는 건지, 제가 물어볼 테니까요, 이렇게 말해야 합니다.
프라이빗 IP 주소.그렇다면 프라이빗 IP 주소는 무엇인가요?즉, 상태에 대해 이야기하고 있다는 뜻입니다. DNS를 생각해 보면 상태가 제대로 작동하고 싶을 테니까요.
호스트는 지연 시간이 정말 좋아야 하고
DNS의 가용성은 고객의 관점에서 볼 때 네트워크의 가용성과 거의 비슷합니다.좋아요, 그럼 우리 각자는
실제로 많은, 아주, 많은, 많은 DNS 호스트가
꽤 많은 내용이 담겨있습니다.어떤 EC2 인스턴스가 존재하나요?어떤 VPC에 있나요?프라이빗 IP는 무엇인가요?
주소?주 (州) 가 너무 많아요.그럼 그 주의 출처는 어디일까요?그럼 그 상태는 어디서 왔을까요?
EC2 컨트롤 플레인.아시다시피 고객은 EC2 API를 호출하여 EC2 인스턴스를 시작하고 네트워크의 다양한 측면을 변경합니다.이러한 정보는 EC2 컨트롤 플레인에 저장된 후 모두 전파됩니다.
이들이 필요한 다양한 장소
일을 하기 위해서요그럼 여기서 무슨 일이 벌어지고 있는 거죠?
고객은 항상 EC2를 변경하고 있습니다.
인스턴스는 항상 시작되고 종료됩니다.그리고 이러한 업데이트는
컨트롤 플레인에 들어와 다음과 같이 전파되고 있습니다.
이 모든 DNS 호스트들이죠.그래서 아주, 아주 스테이트풀한 호스트가 생겼습니다.좀 더 얘기해 보죠.
이 전파 시스템에 대해 말인데요.좋아, 그럼 아무거나 골랐어
가용 영역이 주어지면 다음과 같은 서비스가 제공됩니다.
이 전파 서비스, 많은 호스트는 다음과 같습니다.
DNS 전달자, 정말 많고 많은 호스트.다시 말씀드리지만, 그 방법에 대해 말씀드리겠습니다.
이것은 10년 전에 설계되었는데 약 10년 전에는 잘 작동했습니다.그래서 이게 작동하는 방식은
각 전파 호스트에 임대 공간 시스템이 있습니까?
잠시 동안 업데이트 푸시를 담당합니다.알다시피, 고객이 제공하는 업데이트는 궁극적으로 DNS에 전달됩니다.자, 이 작업은 다음에서 이루어집니다.
일종의 증분식이죠. 점진적 라운드에서요.자, 이제 점진적 라운드를 통해 DNS 호스트에 푸시해 보겠습니다.저희가 책임지고 있습니다. 또 하나, 여기 또 다른 것이 있습니다.좋아요, 이미 몇 가지 질문이 있으시죠?그렇죠?제 생각에 첫 번째 질문은 이 호스트 중 한 명이 이런 질문을 하면 어떨까요?
전파자의 책임인가요?느리면 어떡하죠?이제 어떻게 되는 거죠?글쎄요, 그 라운드는 더 오래 걸릴 거고, 그 라운드는 더 오래 걸리겠지만, 고객은 밖에 있어요
EC2에서 작업을 수행해도 중단되지 않았습니다.그래서 다음 인크리티먼트는
라운드는 더 커질 것이고 느린 호스트는 더 느리게 할 것이고, 다음 라운드는 더 커질 것입니다.보시는 것처럼 보이시죠?
약간 문제가 있어요. 그거랑 좀 문제가 있어요.알고 계셨을 때 또 한가지
규모 확대에 대해 얘기하려고 했는데 새 걸 가져오면 어떻게 되냐고
이 중 하나가 서비스에 들어갔죠.그리고 이것들이 있다는 것을 기억하세요.
매우 스테이트다운 호스트입니다.그래서 주 (州) 를 하나 데려올게요.
스테이트풀 (Stateful) 상태로 서비스를 시작해야 하는 호스트인데 상태가 되기 전까지는 제 역할을 할 수 없습니다.그럼 어떻게 해야 할까요?
우리가 그걸 서비스에 도입하면 다른 모든 사람들이 더 많은 돈을 받게 되죠.이걸로 전체 상태를 알 수 있죠.그리고 이 상태는 해당 지역 내 모든 EC2 인스턴스의 상태였습니다.그럼 그 숫자는 줄어들지 않겠죠?그 숫자가 그랬던 것처럼
올라가고, 올라가고, 올라가죠.이 새 호스트의 경우 전체 싱크대를 채우는 데 시간이 오래 걸리더라도
아주 잘 작동하고 있어요.그렇게 하는 동안 우리는 정말 큰 성과를 거둘 수 있습니다.
다음 번에 사용할 수 있도록 점진적으로즉, 고객으로 인한 지연이 발생한다는 뜻입니다.
EC2에서 이러한 작업을 수행하면 이를 고객의 DNS 쿼리에 반영할 수 있게 되는 시간이 점점 더 길어지고 있습니다.그 이유는 다음과 같습니다.
고객에게는 중요합니다.아까도 말씀드렸듯이,
아시다시피, DNS가 작동하지 않으면 네트워크가 작동하지 않는 거죠.
regs는 아무것도 찾을 수 없습니다.그래서 만약 고객이 런칭을 했다면
두 번째 EC2 인스턴스와 첫 번째 EC2 인스턴스
이름으로 접근하려고 했는데 몇 개가 있었어요.
그 외 일반적인 사용 사례로는 그 이름이나 다른 것이 있습니다.
해당 이름의 이름이 보일 것입니다.따라서 해당 인스턴스를 찾으려면 해당 인스턴스가 실행 가능하고 실행 중일 수 있지만 아직 연결할 수 없습니다.
아무도 찾을 수 없으니까요.그래서 저희 고객들한테는 그게 중요하죠.따라서 이러한 호스트를 배포하면 다음과 같은 그래프가 나타납니다. 그렇죠?이것은 부터 시작하는 지연 시간입니다.
물론 우리는 이것을 측정하고 있습니다.왜냐하면 고객에게 중요한 문제라면 그 가치를 측정해야 하기 때문이죠.저희 고객에게도 중요한 문제이기 때문에 저희도 그 가치를 측정하고 있습니다.EC2 인스턴스 시작부터 DNS가 완전히 전파되는 시점까지의 시간.이것이 클로즈드 루프입니다.
보시다시피 배포에서는 그렇지 않습니다.
여기 엄청 깔끔해 보이죠?문제랑 좀 구분이 안 되는 것 같은데요?이 그래프도 문제인 것 같네요.자, 이제 배포와 관련된 문제점이 하나 있는데, 알 수 없습니다.
배포인지 아니면 배포를 진행 중일 때 문제가 생긴다는 거죠.
보세요, 이거 보이시죠.그 이야기는 사실 몰라요. 이야기가 끝날 거라고 생각하잖아요. 왜냐하면 그걸 알기 때문이죠.
배포는 이렇게 보여야 하는데, 그래서 이게 좋은 거죠.
정상화하지 말아야 할 것 같아요.하지만 실제로는 그렇지 않잖아요
끝날 거라는 걸 알아요이게 우리를 때렸어요.무슨 일이 있었는지 보여드릴게요.그래서 우리는 평소처럼 배포를 했고
물론 이런 그래프가 나올 것으로 예상했지만, 이번 배포에서 약간의 문제가 있었다는 점만 빼면요.이 안의 문제점은
배포, 실제로 싱크대는 작동했고, 데이터 플레인도 작동했지만, 데이터 플레인은
프로세스를 다시 시작하지 못했습니다.그래서 아직 작업 중이었는데
아직도 오래된 데이터를 다루고 있습니다.그래서 모든 것이 괜찮아 보였고 배포 단계에 있는데 그래프는 괜찮아 보이지만 문제는 그래프가 예상대로 풀리지 않는다는 것이었습니다.그게 실제로 의미하는 바는
우리한테는 아주 나쁜 일이었어요. 왜냐하면 그 뜻이었으니까요.
이 배포를 했었는데 실제로 문제가 있었는데 그 때문에 문제가 생겼습니다.
우리가 가지고 있지 않았기 때문에 오랫동안 문제가 생겼습니다.
배포와 문제의 차이를 구분하는 거죠?그래서 이런 일이 일어난 후 우리가 이 문제를 해결해야 한다는 걸 알았죠, 그렇죠?그리고 정전 기간은
운영과 관련해 생각할 때 가장 중요한 것은 단연코 가장 중요한 것입니다.
우리가 만들어야 할 이벤트들이죠.우리는 이것이 중요하다는 것을 알고 있습니다
빨리 끝내줘서 고마워따라서 우리에게 중요한 일이죠.그럼 이제 뭘 했냐고요.여러분 모두가 앉아있는 것을 알고 있습니다.
여기 이미 더 나은 번식 시스템이 설계되어 있습니다.
제가 설명했던 것보단 말이죠.안 그랬어요?당신을 알아요. 그리고 좋은 소식이 있어요.
당신, 우리가 당신의 제안을 모두 받아들였는데 지금은 완전히 다른 서비스가 됐어요.하지만 이건, 아시다시피
바로 이 순간이에요. 10년 전에 우린 이걸 위한 훌륭한 아이디어를 가지고 있었죠.하지만 문제는 우리가 가지고 있었다는 것입니다.
방금 이거에 물렸어.우리가 봤는데 배포인가, 아니면 문제가 아닌지
상태가 양호합니다.그래서 우리가 가서 모든 것을 설계하기 전에 실제로 했던 일은
나중에 해봤는데, 호스트의 시작 시간을 현미경으로 관찰해서 여러 가지를 만들었죠.
로컬 최적화는 그다지 흥미롭지도 않습니다.우리는 종류를 바꿨습니다.
로컬 데이터베이스 파일이 약간 변경되었습니다.
광고 및 삭제 현황에 대한 비즈니스 로직
거기에 합쳐진 거죠.우린 사실 우리가 이겨야 할 게 뭔지 정확히 알고 있었죠.그 당시엔, 당신이
EC2 인스턴스를 시작했는데, 현재 해당 EC2 인스턴스에 접속하고 운영 체제를 가동하고 실행하는 데 30~40초가 걸렸습니다. 훨씬 더 빨라졌습니다.하지만 우리는 오래전부터 알고 있었습니다.
그 기한 내에 DNS를 작동시킬 수 있었으니까요, 고객님
우린 괜찮을 거예요그래서 우리가 이겨야 했던 거죠.이길 때까지 최적화를 해서 배포가 불가능하도록 했습니다.
더 이상 문제가 생긴 것 같네요우리의 배포는 다음과 같았습니다.
모든 것이 계속 성공하고 있습니다. 바로 여러분이 원하던 곳입니다.그럼 호스트 규모를 늘려볼까요?
스타트업 배포는 일종의 하위 사례입니다.어떤 경우에는 어떤 것들이 있을까요?
스테이트풀 호스트를 보유하고 있는 게 마음에 안 든다면
가져오는 데 걸리는 시간, 호스트가 이를 서비스에 도입하는 데 시간이 얼마나 걸리는지 살펴봐야 합니다.그게 마음에 안 들면
생각해 볼 게 몇 가지 있어요.우리 팀에서 흔히 볼 수 있는 AWS의 몇 가지 패턴은
S3에 저장된 상태를 스냅샷으로 캡처하여 다운로드할 수 있습니다.
스냅샷이 매우 빠릅니다.보통 그게 더 빠를 때가 많아요
일부 일련의 이벤트를 처음부터 동기화합니다.셀룰러 아키텍처
여기서 정말 유용할 수 있어요. 그냥 제한만 하면 되니까요.
상태를 최대로 조정해서 테스트해서 정확히 알 수 있습니다.
무엇을 다루고 있는지요.심지어 저희 팀도 본 적이 있어요.
이러한 운영적 성과를 조직 전체에 퍼뜨리고 있습니다.최근에 배포 시기에 대해 얘기한 것도 봤는데
호스트를 서비스에 도입할 때는 심지어 다음과 같이 전송하기도 합니다.
서비스를 시작하기 전에 합성 트래픽이 잔뜩 쌓여서 연결 풀 등 생각하지 못했던 것들을 포함하여 모든 것이 예열됩니다.그리고 배포가 가능해졌습니다.
훨씬 덜 파괴적이었죠.좋아요, 방금 얘기했어요
이 한 가지에 주의를 기울이는 것에 대해
도대체 그걸 측정하고 최적화하는 거죠.마이크를 초대하고 싶은데 그가 우리에게 말해줄 거예요.
물건을 측정하는 방법에 대해 알아야 할 많은 것들을 알려줄게요. - 좋아요, 고마워요 베키.좋아요, 저는 지난 몇 년 동안 많은 시스템을 연구해왔고 거의 모든 시스템에서 작업했습니다.
제가 지금까지 살펴본 바로는 일종의 스케일링 병목 현상이 있습니다.충분히 세게 밀어붙이면
트래픽을 충분히 보내면 결국에는 뭔가
어딘가 부서질 것 같았어요그러니까 얘기 좀 하고 싶어요
그걸 측정하는 방법에 대해 조금 얘기해 보자면, 왜냐하면,
무한대로 확장 가능하지 않아도 괜찮습니다. 괜찮지 않은 것은 무엇이고 그 원인은 무엇일까요?
실패한다는 것은 자신도 모르게 병목 현상에 부딪히는 것입니다.베키처럼 저도 열렬한 팬이에요.
이야기가 많아서 VPC에 대해 말씀드리고 싶습니다.VPC는 제가 여러 해 동안 작업한 서비스입니다.
다른 많은 AWS 서비스와 마찬가지로 VPC도 컨트롤로 구성되어 있습니다.
플레인 및 데이터 플레인.따라서 컨트롤 플레인은 모든 API 트래픽을 보내는 곳입니다.따라서 서브넷을 변경하거나 수정하는 경우
VPC 라우팅 테이블, 이러한 API 호출은 컨트롤 플레인으로 이동하며 데이터 플레인에게 무엇을 할지 지시하는 것이 컨트롤 플레인의 역할입니다.그리고 데이터 플레인은 패킷이 유선으로 흐르고 올바른 위치로 이동하도록 합니다.그래서 VPC를 구축할 때 해결해야 했던 문제 중 하나는 컨트롤 플레인에서 데이터 플레인까지 상태를 어떻게 분배할 수 있는가였습니다.여기서는 상당히 표준적인 기법을 사용하는데, 추가 전용 대기열을 사용하는데, 이렇게 하면
멋진 프로퍼티들이 많죠.하지만 속성 중 하나는
이것이 우리에게 주는 것은 바로 DNS와 마찬가지이기 때문입니다.
플릿: VPC 플릿 또는 EC2 인스턴스의 VPC 측을 위한 데이터 플레인이 정말 많습니다.업데이트를 보내면
이 추가 전용 대기열에서는 모든 데이터 플레인 노드가
원하는 속도로 읽을 수 있습니다.자, 왼쪽에 있는 노드는
저기, 업데이트 중에 멈춰도 상관 없어요
넷째, 나머지 데이터 플레인 객체는 계속 움직이고 오른쪽에 있는 다섯 번째 업데이트를 읽을 수 있습니다.다른 한 가지는 컨트롤입니다.
플레인이 하는 일은 데이터 플레인의 삶을 더 쉽게 만들려고 하는 것입니다.그러니까 실제로 아래로 내려가는 거죠.
미리 계산된 상태도 있고, 데이터 평면에 맞게 형식화된 상태도 있습니다.
더 쉽게 사용할 수 있게 해주죠.데이터베이스 배경의 사용자라면 비정규화된 뷰와 비슷합니다.지금 보고 있는 것과 똑같네요.
알다시피, 그럴 수도 있는 물체를 취하기 위한 수많은 논리가 있죠.
고객을 위해 한 가지 방식으로 배치하고 데이터 플레인에는 다른 방식으로 배치합니다.예를 들어 VPC 라우팅 테이블을 들 수 있습니다.다운으로 전송하는 대신
개별 경로 업데이트, 가장 긴 경로를 미리 계산합니다
모든 경로에 접두사가 일치하고 라우팅 테이블의 최종 버전을 데이터 플레인으로 전송합니다.그러니까 지금까지는 잘 작동하죠.
보통 이 추가 로그의 끝에 어떻게 추가할 수 있을지 생각하기 시작하죠.보통은 그게 정말 사소한 일이라고 생각하시죠.아시다시피, 저기 있는 걸 볼 수 있잖아요.
저기 상자 다섯 개가 있는데 전부
버전 번호가 적혀 있거나, 순번이 적혀 있습니다.그래서 우리는 다음 항목을 고르면 됩니다.
시퀀스를 6번으로 지정해서 대기열 끝에 고정하세요.그리고 보통은 네 말이 맞을 거야.그거 정말 예뻐요
이에 대한 간단한 해결책입니다.하지만 우리가 이 일을 하고 있기 때문에
미리 계산된 상태 단계는 사실 좀 더 미묘합니다. VPC 라우팅 테이블을 두 번 업데이트하면
바로 그 순간에, 우리는 이 작업을 진행하고 있습니다.
어디로 보낼지 정규화하는 방법을 알려드리죠.
데이터 플레인까지 내려가면 둘 다 알아야 합니다.
서로에 대해서요, 그렇죠?어느 쪽이 먼저 나오든 두 번째 오른쪽이 봐야죠. 맞아요, 그 다음엔 말이죠.그러니까 복잡한 상황은 아니죠.그리고 아주 표준적인 기법이 있는데 자물쇠를 사용하는 거죠?따라서 먼저 들어오는 사람이 잠금을 받고 두 번째로 API 호출을 받습니다.
나중에 잠금을 받게 됩니다.물론 자물쇠를 쥐는 즉시 자물쇠를 갖게 될 거예요
중요한 부분 맞죠?그럼 그 동안 뭘 하시나요?
자물쇠 잡고 계세요?그래서 우리한테는 아주 간단합니다.그럼 계속 실행해 봅시다.
VPC 라우팅 테이블 예시.따라서 잠금을 잡으면 현재 상태가 무엇인지 알 수 있습니다.
VBC 라우팅 테이블에 대해서요?새 경로를 추가하고 최종 경로를 다시 계산할게요
데이터 플레인의 상태를 확인한 다음
대기열에 추가한 다음 잠금을 해제하겠습니다.이제 당신이 어떤 일을 해본 적이 있다면
동시성 프로그래밍을 할 때, 중요한 섹션은 거의 항상 제일 먼저 보게 되는 부분이라는 걸 아실 겁니다.
성능 문제가 있어요.사실 이곳은 종종 병목 현상이 발생할 수 있는 곳입니다.하지만 한 번 살펴보죠.
정확히 어떻게 생겼는지이제 시간이 지남에 따라 어떻게 보일지 시각화해 보겠습니다.자, 이 자홍색 상자는
시간의 단위라고 생각하시면 됩니다. 아마도
두 번째, 어쩌면 1분일지도 몰라요.그리고 저기 있는 초록색 상자는
이제 자물쇠를 쥐고 있을 때죠.이것이 우리의 중요한 부분이죠.그래서 시간이 흐르면서
API 호출이 컨트롤 플레인을 통해 도착할 때마다
이 잠금을 획득합니다.그리고 다음과 같은 기간이 있을 수 있습니다.
API 호출이 없는 시간이죠.따라서 이 기간 동안 모든 슬롯을 차지하지는 않겠지만 결국에는 두 번째 호출을 받게 되고 또 다른 중요한 섹션이 생길 것입니다.그리고 만약 우리가 동시에 두 통의 전화를 받는다면, 기억하세요.
이 자물쇠에서 부딪히긴 하지만 사실 괜찮아요둘 중 한 명이 먼저 가져갈 거고, 다른 한 명이 잠시만 기다리면 할 수 있을 거예요
그 후 얼마 지나지 않아 그 권리의 순서를 정할 수 있겠죠.그래서 이 패턴은 꽤 잘 작동합니다.다음과 같이 상상하실 수도 있습니다.
플래시몹이 나타난다는 거죠?베키가 말한 것처럼 트래픽이 급증할 수도 있겠죠.갑자기 야생 컬렉션이 들어왔어요.
많은 요청이 도착하고 결국 순차적으로 순서가 지정됩니다. 시간이 흐르면 말이죠.다음에 대해 계속 생각하면
하지만 여기에는 문제가 있습니다.모든 요청의 도착 속도가 실제 처리할 수 있는 속도보다 빠르면 어떻게 될까요?여러분이 이 시스템을 만들었는데 갑자기
트래픽이 점점 더 많아지는데 계속 기다릴 수밖에 없죠.
사물함이 너무 오래 남았어요.어떻게 생각하세요?
요청이 너무 많이 들어오기 시작하면 어떻게 되나요?글쎄요, 전 정말 몰라요
너무 깊이 생각해 봐야겠어요. 실제로 그런 일이 우리에게 일어난 일이니까요.자, 이것이 우리가 보는 그래프입니다.
언제 이런 일이 있었는지 알고 있었죠.그래서 갈색으로 변했어요.여기서 Y축은 오류의 개수입니다. 라벨을 붙이지는 않았지만 실제로는 그리 크지 않습니다.비교적 적은 수의 오류입니다.그리고 그 오류는 무엇일까요?
들어와서 얻으려고 했던 요청의 출처입니다.
잠금했지만 시간이 초과됐어요. 그냥 잠금을 받을 기회가 없었으니까요.그냥, 그들은 그것을 얻을 수 없었을 뿐이죠.그리고 또 다른 흥미로운 건
이 그래프의 특징은 저절로 복구되었다는 것입니다.우리는 어떤 명시적인 조치도 취하지 않았어요.우린, 알다시피, 페이지였어요.
사람들이 그걸 보고 있었고, 우린 알아내려고 했어요.
뭘 해야 할지 알아내고 나서 저절로 회복됐어요.그러니까, 아시다시피, 바로
모두 손을 맞대고 무슨 일이 있었는지 알아내려고 애쓰고 있습니다.
이 브라운 아웃을 일으키려고 말이에요그래서 우리는 이론을 하나 세웠고, 우리의 이론은, 음, 가장 큰 이론을 얻었죠.
우리가 지금까지 본 플래시 몹은 우리가 다루지 않았을 뿐이고 그 플래시 몹을 처리할 충분한 여유 공간이 없었습니다.그리고 점점 더 많은 것을 파헤치고 로그를 샅샅이 뒤지고 그 이후에 무슨 일이 벌어졌는지 알아내면서 우리는 그렇지 않다는 것을 깨달았습니다.
스토리가 잘 맞나요?그거보다 조금 더 많죠.우리가 나중에 발견한 것은 우리가 실제로 가지고 있었다는 것입니다.
최근에 막 기능을 출시했었죠.그리고 이 기능이 어떤 역할을 했을까요?
그 중요한 부분에 시간이 조금 더 추가되었나요?그래서 이 기능을 출시한 후 갑자기 여유 공간이 줄어들었습니다.그래서 할 수 있는 일은
이 그림의 상단 버전을 보세요.
거기에 몇 개 넣을 수 있는 슬롯이 몇 개 있습니다.
더 중요한 섹션은 에 있습니다.공간이 충분하지 않아요
아래쪽은 사라졌어요.그래서 저희는 사실 안 했어요.
요청 로드 측면에서 사상 최고치를 기록했습니다.그런데 중요한 부분이 커져서 저희도 몰랐던 상황이었죠.그래서 우리는 이 문제를 고쳤고, 코드를 최적화했습니다.
그리고 몇 가지 사항을 변경했습니다.하지만 그 즉시
질문은 이랬어요. 음, 어떻게 하면 놀라지 않을 수 있을까요?이게 우리를 사로잡았기 때문이죠.
완전히 방심하지 않았어요생각해 볼 수 있겠죠.
어떤 지표를 적용하고 싶으신가요?뭐, 아마 그러실 거예요
API 오류에 대한 메트릭을 가지고 있는데 확실히 해냈고 그게 바로 경고를 받은 거예요.
이 문제에 대해 말씀드리죠.하지만 이것들은 소급 적용되죠.
그렇죠?반응성이 강하죠.이미 문제가 생겼어요.
우린 그러고 싶지 않아요.API 지연 시간을 측정하고 싶을 수도 있습니다.그래서 우리는 그것을 측정하지만
알고보니 중요한 부분이 사실 우세하지 않습니다.
시간을 API 호출의 일부로 나타낸 것이죠.그래서 실제로 잡음을 잃게 되겠죠. 좋은 신호는 아니었죠.그래서 다른 것이 필요했습니다.
바닥이 얼마나 가까워졌는지 측정할 수 있는 방법
시스템을 위한 여유 공간이 있나요?그래서 우리가 하기로 한 것은
이런 종류의 그림이 무엇인지 정확히 측정해 봅시다.
예를 들어보죠. 그 시간 중에 자물쇠를 잡을 수 있는 시간이 얼마나 될까요?그래서 몇 개 그렸어요.
일종의 점선 상자 같은 게 보이실 겁니다.
일곱 개의 메일박스가 채워져 있고, 세 개의 점선 상자가 있죠.시각적으로는 이 슬롯 10개 중 7개가 꽉 찬 것 같죠?그래서 이런 게 있었죠.
70% 정도는 배부르게 될 거라는 직감이죠.하지만 물론 이건 정말
간단한 예시죠.사실 그 상자들은
크기가 고정된 게 아니에요.한 단위로 셀 수는 없지만 그래도 셀 수는 있겠죠?다음과 같은 경우에는 상관 없습니다.
모양이 달라요.이걸 얼마나 오래 들고 있는지 포스팅을 시작하면
잠기세요. 그러면 지표를 게시하고 그 지표의 합계를 구해서 우리가 시간 블록을 얼마나 오래 보관하고 있는지 알 수 있죠?그러면 이렇게 합계를 구해볼 수 있습니다.
시간의 합계, 지연 시간의 합계, 일종의 특이한 지표죠.합계를 다음과 같이 입력하는 사람은 많지 않습니다.
대시보드의 지연 시간, 하지만 기본적으로
이 상황에서 말씀드리자면, 이렇게 고정된 상태로 우리가 사용한 시간 예산은 얼마나 될까요?그러면 우리가 얼마나 가까이에 있는지 알 수 있는 프록시가 생깁니다.
병목 현상에 시달리고 있어요.자, 이제 이 시스템에서는 진화가 진행되었죠.
몇 년이 지났지만 기본적으로는 여전히 같은 시스템이고, 이에 대한 척도가 있습니다.
이 자물쇠를 측정하는 날이죠.그리고 이건 일종의
그래프는 오늘날의 모습입니다.이것이 지연 시간의 합계 그래프입니다.일종의 주간 패턴을 볼 수 있습니다.이제 몇 주가 걸리죠.그리고 뭐가 예쁜가요?
이 그래프의 흥미로운 점은 그래프의 전반부에서는 비교적 평면적이라는 것입니다. 그렇죠?사실 아무 일도 일어나지 않아요.
성장 측면에서는 그렇습니다.그런데 중간 쯤이나 중간 쯤에서 조금씩 올라오기 시작합니다. 그래프에 빨간 선이 있는데 이 빨간 선은
임팩트 라인, 이봐요, 가서 뭔가 고쳐야겠네요.자, 이제 이걸 만들었죠.
그래프를 보면 경보가 울립니다.그리고 이건 휴먼 알람과 같은 페이지가 아니라 스프린트 추가 작업입니다.
우리 팀한테 가서 이 문제를 해결해 달라고.아시다시피, 비슷한 것이 있다면 셀룰러 아키텍처를 사용할 수도 있고, 더 많은 셀을 만들고 있을 수도 있고, 데이터를 더 많이 분할하는 것일 수도 있고, 작은 최적화를 할 수도 있습니다.
이 자물쇠를 쥐고 있으면서요.아키텍처 변경일 수도 있겠지만, 이제는 세상이 돌아가는 동안이 아니라 언제 변경해야 하는지 알 수 있는 조기 경보 시스템이 생겼습니다.
화재와 당신의 페이징 인간들.이 그래프에서 마지막으로 한 가지 더 말씀드리자면, 단위가 조금 이상할 수 있습니다.시간의 합계는 무엇을 의미할까요?그래서 시간을 균등하게 만드는 한 가지 방법은 다음과 같습니다.
1분짜리 데이터 포인트 그래프입니다.그런 다음 측정값을 같게 하거나 단위를 같게 하면 됩니다.따라서 1분짜리 데이터 포인트를 밀리초로 측정한다면
그런 다음 밀리초를 1,000으로 나누어 초를 구합니다.
60으로 나누면 분을 구할 수 있습니다.이제 합계를 알 수 있습니다.
분당 시간.자, 이제 0이 되죠.
자물쇠를 전혀 쥐고 있지 않다는 뜻이죠.
1분 동안 자물쇠를 쥐고 있다는 뜻이죠.그러니까 이 기법은 사실
꼭 새로울 필요는 없습니다.그리고 정말 멋진 게 있어요.
리틀 법칙 (Little's law) 이라는 방정식은 제가 지금까지 이야기했던 것의 일반적인 버전을 보여줍니다.그리고 리틀 법칙은 무엇인가요?
동시성의 평균 양은
시스템, 다시 말해, 얼마나 많은 일들이 일어날 수 있을까요?
동시에 평균 도착률과 같습니다. 따라서 사람들이 나타나거나 요청이 도착하는 빈도는 지연 시간을 곱한 값입니다.그러니까 여기 점심을 먹은 사람이 있다면
오늘 어느 식당에서든 이런 일이 벌어지는 걸 보셨죠?지연 시간은 거의 일정했어요.들어오면 오른쪽으로 걸었잖아
테이블까지 올라갔고, 점점 더 많은 사람들이 보여준 것처럼
올라왔어요, 무슨 짓을 한거죠?테이블을 더 열었죠.
더 많은 동시성을 추가했죠.그래서 이런 균형이 잡혔습니다.
둘 사이에서 행동하세요.하지만 지연 시간에 대해 말씀드렸는데 이 방정식에는 합이 없습니다.그럼 그게 어디서 나온 걸까요?음, 리틀의 법칙은 다양한 시나리오에 적용되지만
신중한 측정 기준의 관점에서 생각해보면
1분짜리 데이터 포인트처럼 실제로 몇 개를 만들 수 있습니다.
방정식에 대한 가정들 말이에요.따라서 1분 데이터 포인트에 도달하는 데이터 포인트의 개수에 대한 도달률은 바로 그 분 동안 가지고 있던 데이터 포인트의 수와 같죠?그럼 그냥 N이죠. 그럼 어떻게 계산할까요?
어떤 것의 평균 지연 시간은?총계를 취해 숫자로 나눕니다.
관찰한 횟수.그래서 그 N들은 상쇄되죠.따라서 이산 시간 단위의 경우,
메트릭 데이터 포인트와 같은 데이터 포인트의 평균 동시성은
시스템은 실제로 지연 시간의 합계와 같습니다.즉, 할 수 있다는 뜻이죠.
기존 옵저버빌리티 툴을 사용하면 정말 쉽게 그래프를 작성할 수 있습니다.다시 시각적인 내용으로 돌아가 봅시다.
한 번 더 예를 들어보죠. 그냥 설명해 볼게요.자, 여기 일곱 블록이 있어요.각 블록에 0.1초가 걸리고 이 블록은 1초라고 가정해 봅시다.이제 알게 된 사실이죠.
이것들을 합하면 병목 현상의 70% 에 달합니다.이제 동시성이 가능해졌습니다.
왼쪽이 하나, 저게 하나예요.이게 하나인 이유는 우리가 이걸 가지고 있었기 때문이죠.
전용 자물쇠 맞죠?한 가지만 실행할 수 있었어요. 그렇게 시스템을 만들었으니까요.우리는 이 자물쇠를 제자리에 두었죠.하지만 알고보니 리틀의 법칙이 밝혀졌어요
실제로는 훨씬 더 일반적이며 전용 자물쇠를 사용하는 곳에는 적용할 필요가 없습니다.작업자 풀이 있는데 풀에 얼마나, 몇 명의 작업자가 필요한지 알고 싶다고 가정해 봅시다.그리고 동시성을 측정할 수 있는 좋은 방법은 없습니다.
그 시스템 안에서 말이죠.접근할 수 있는 한 가지 방법
전체 작업의 지연 시간 합계를 그래프로 나타낸 경우입니다.
시스템을 통해 이동하면 최소값 또는
동시성이 얼마나 필요한지 평균적으로 알 수 있죠.따라서 총 142초의 작업이 매초마다 수행된다고 가정하면,
초당 142초라는 말은 그 부하를 처리하려면 최소 142명의 작업자가 필요하다는 뜻입니다.물론 이것들은
해당 기간의 평균입니다.따라서 1분의 데이터 포인트라면 1분 이상의 평균 데이터이므로 아마도 많을 것입니다.
피크가 최고조에 달할 때는 더 높아지죠.그러니까 분명히 정확히 142개 이상으로 규모를 확장할 수 있을 거예요.하지만 뭔가 얻을 수 있는 게 있어요
시간이 지남에 따라 그래프를 그리면 다음과 같은 느낌을 받을 수 있습니다.
제가 얼마나 가까워지고 있나요?방금 기능을 변경했는데 헤드룸이 크게 줄어들었는데 재평가해야 할 부분이 있다면
성능 최적화?섹션이 마음에 드셨으면 좋겠습니다.알다시피, 우리는 많이 생각합니다.
AWS의 절벽 확장에 대해 말하자면, 우리는 항상 주의를 기울이고 있습니다.
이를 측정할 방법을 찾고 있습니다.그리고 같은 기술을 사용하는 다양한 시스템이 많이 있습니다.EC2 인스턴스를 배치할 장소를 찾는 데 이 방법을 사용합니다.
실행 인스턴스를 호출할 때?EC2 배치 알고리즘은
이것으로 측정합니다.우리에겐 워크플로 시스템이 있고, 앞서 말했듯이 VPC 시스템도 있습니다.그래서 우리는 이 기술을 많이 사용합니다.언제든지 동시성이 어느 정도인지 측정할 수 있습니다.
시스템의 시간 합계를 그래프로 표시하는 것은 정말 쉬운 일입니다.
대시보드에 추가하기 위해서죠.다시 한 번 말씀드리지만, 여기서 중요한 것은 병목 현상에 도달하기 전에 병목 현상에 대해 알고 싶다는 것입니다.좋아요, 마지막 섹션이 하나 더 있어요.우리는 이것을 보너스 섹션이라고 부릅니다.올해 이 강연에 어떤 내용을 포함시킬지에 대해 잠시 이야기를 나누었는데요, 자주 논의되는 내용 중 하나는 항상 완화에 초점을 맞추고자 하는 바람입니다.크든 작든, 거의 실패했든 크든 운영 이벤트가 발생하면 항상 고객이 가능한 한 빨리 문제를 해결할 수 있도록 노력하고 싶습니다.그리고 몇 가지 기법들이 계속 등장하고 있습니다.
다시 말씀드리지만, 그건 꽤 보편적인 것 같습니다.
우리 팀 대다수에서는 그리 놀라운 일이 아닐 수도 있습니다.그 사람들을 보면
그래, 그래, 당연한 일이겠지만 뭐 어쩌겠냐고 하겠지
그것들이 얼마나 유용한지는 분명하지 않게 합시다.
우리가 그걸 얼마나 자주 하는지 말이에요.그래서 저는 이 강연에서 이 중 몇 가지를 소개해 보자고 생각했습니다.그래서 세 개를 드릴게요.
간단한 예를 들자면, 우리가 거의 생각하는 것들에 대한 간단한 힌트죠.
AWS의 모든 팀과 여러분 모두가 거의 광범위한 사용 사례를 통해 이점을 얻을 수 있을 것입니다.자, 첫 번째는
그냥 메트릭 그래프입니다.이 그래프는 오류를 보여주고 있는데, 이 오류는 뭔가
이런 일은 자주 발생하지 않습니다.아마도 여러분의 코드 깊숙한 부분에 있는 변형과 같은 것일 수도 있습니다.
불변성이 언제 위반되었는지에 대한 지표를 게시하세요.그런데 오늘 갑자기 깨어나셨는데, 그 변종은 실제로 위반당했습니다.그래서 이 지표는
오류 계정 게시.그래서 대시보드를 살펴보기 시작했는데, 이렇게 해보려고 할 수도 있겠죠.
이런 상황을 완화하기 위한 노력도 있습니다.뭘 하고 있는지 알아내려고 노력하죠.
출혈을 멈추려면 할 수 있어요. 그리고 다시 대시보드를 보세요.그리고 문제는, 우리가 회복했는가입니다.지금 이 그래프를 보시면 순식간에 알 수 있어요.
자, 이제 회복됐나요?그려 넣으면 어떡하지?
조금 다른가요?그래서 이 두 그래프의 차이는 아주 미묘합니다.글쎄요, 그렇게 미묘하지 않을 수도 있습니다. 사실 꽤 분명하죠.선이 있는 것 같아요.
옆으로 내려가죠, 그렇죠?그게 무슨 뜻이냐면
이 지표를 게시할 때, 행복한 날이라면
변형이 위반되지 않았으므로 항상 0점을 게시합니다.오류 수가 0이고 오류 수가 0이라는 뜻입니다.
오류 수는 0입니다.그리고 그 혜택은
고치는 순간부터 바로 알 수 있습니다.그래서 떨어진다는 사실은
저기 오른쪽 아래를 보면 아마도 의심이 사라질지도 모른다는 의구심이 사라지죠.
지표는 아직 전파되지 않았습니다.어쩌면 우리가 모르는 것일 수도 있습니다.이제 지표가 떨어졌음을 알 수 있습니다.이점이 하나 더 있습니다.
이렇게 하면 아주 쉽게 알람을 울릴 수 있다는 거죠.만약 이게 정말 드문 오류라면, 심지어 이런 오류도 없었을 수도 있습니다.
알람이 뭔지, 아니면 적절한 임계값이 얼마인지 생각해 봤어요.하지만 이제 그런 일이 생겼으니
원인을 완전히 찾아내려면 하루나 이틀이 필요할 수도 있습니다.
아니면 배포를 시작하세요.하지만 그 동안 당신은
알람을 울리면 즉시 알 수 있습니다.
똑같은 상황이 다시 발생할 경우 다시 신청할 수 있습니다.
어떤 완화 방법이 있든 말이지요.그래서 만약 당신이 가지고 있지 않았다면
이 포스팅은 혜택이 전혀 없고, 그 다음은 여러분의 지표와
알람으로는 고쳐졌는지 아닌지 알 수 없을 거예요
시스템이 더 나빠졌나요?그리고 더 이상 메트릭을 게시하지 않죠.0을 떨어뜨리지 않고는 이 둘을 구분할 수 없는 것 같아요.좋아요, 두 번째 치크.자, 여기 또 다른 오류 수가 있어요.이 녀석은 잘 동작합니다.좋은 미터법 에티켓이 있어요.그게 바로 0점을 올렸다는 거예요.
예전에도 그랬고 지금도 뜨고 있어요.제가 여러분께 드리는 질문은, 한 가지 행동이 무엇인가입니다.
이러한 영향을 최소화하기 위해 즉시 조치를 취할 수 있을까요?- [패널리스트] 버그를 고쳤나요?- 아니요, 버그는 수정하지 마세요.왜 그러시죠?아니, 당장 고치고 싶니?몇 초, 몇 초가 중요하죠.그럼 어떻게 하시겠어요?- [패널리스트] 롤백.다시 시작하세요. 좋아요. - 좋은 제안이네요.들었어요
롤백, 재시작 소리가 들렸어요.약간 다른 그래프를 보여드리고 답이 바뀌는지 확인해 보겠습니다.자, 이 그래프는 다음과 같습니다.
어느 정도의 차원성과 인스턴스 ID별 크기.죽여버리세요, 네.그냥 사실대로 말하자면
다음과 같은 차원을 가진 그래프가 있다는 것을요.
인스턴스 ID, 노드 ID 또는 가용 영역이 일치하면 순식간에 알 수 있습니다.
이 그래프를 보면 호스트를 서비스 밖으로 내보내야 할 일이 하나 있다는 것을 알 수 있습니다.
VIB에서 가져오고, DNS에서 가져오고,
무엇을 해야 하든, 필요하다면 궤도에서 핵폭탄을 터뜨리세요.그렇게 하면 회복할 수 있어요.그러면 그 원인이 무엇인지 알아낼 수 있겠죠.그리고 사실 정말 웃겨요.
이야기 하자면, 우리는 이 강연을 위해 연습 세션을 하고 있었는데, 바로 이 이벤트가 저희 팀 중 한 곳에서 일어났는데 정말 빠르게 진행됐어요.그들은 마치, 아, 이 그래프, 이 한 호스트가 정말 이런 식이었어요.
C 사용률이 높아서 서비스가 중단되는 거죠.그러고 나서 그들은 알아냈습니다.
그 후에 무슨 일이 벌어졌는지그러니까 그만한 가치가 있는 거죠.
몇 번이고 반복해서 말이죠.좋아, 마지막 트릭이야.이제 시작하겠습니다.알겠어요.아마 여기 계신 분들 대부분이 이런 그래프를 보셨을 겁니다.이것은 메모리 사용률 그래프입니다.오른쪽으로 올라가고 있습니다.
그래프는 만족스럽지 않습니다.그럼 바로 무엇을 할 수 있을까요?
이러한 영향을 줄이려면?방금 누가 진짜 재시작한다고 했잖아요껐다가 다시 켜세요.그래서 다시 끄는 이런 기법은 아주 널리 퍼져 있습니다.우리는 항상 이 방법을 사용합니다.그리고 제가 자세히 알아보고 싶은 건, 그래야 한다는 거예요
규칙적으로 운동하세요.그리고 만약 그렇게 하고 자신감이 매우 높다면, 좋은 표준 운영 절차로, 문제 티켓이나 어떤 종류의 경보가 울리면
그래프가 저렇게 보이는 걸 끄면
바로 재시작을 시작하고 바로 시작하세요.
다른 것들도 보세요.클릭해서 재시작을 클릭하는 것과 같습니다.그리고 그 일이 계속되는 동안 얼마나 오래 걸리든
너무 오래 걸리지는 않을 거예요. 그럼 시작해볼게요
제가 알아낼 수 있는 다른 것들을 살펴보면서
실제로 무슨 일이 벌어지고 있는 건지하지만 처음 몇 개 동안에는
몇 초 후, 이봐, 페이지가 하나 나왔어, 아니면 이봐, 이 알람이 울리잖아
끄세요, 다시 시작하세요.아주 간단합니다.그리고 우리는 이걸 여기저기서 사용하죠.시일 캐시에서 사용합니다.
구성 파일이 변경되지 않을 때는 적용하지 마세요.그리고 뭐, 알다시피, 당신은
이 목록을 보고 이렇게 말할지도 몰라요. 아, 당신
이것저것 다 테스트해봐야겠네요네, 확실해요?확실히 할 수 있어요.하지만 그럴 때가 많죠.
이런 이상한 엣지 케이스.롤백해야 했는데 롤백이 취소되지 않았을 수도 있습니다.
새 구성이 제대로 되었는지, 그렇지 않았는지, 알다시피
새 버전과는 다른 방식으로 자격 증명을 캐시했습니다.
뭐 이런 거 해봐.그래서 그냥 재시작 메시지를 보내고, 그냥 반송시키기만 하면 되죠.
플릿, 안심할 수 있습니다.왜, 왜 그런지 알 수 있을 거예요
그 버그는 나중에 생겼습니다.그냥 함대를 튕겨내세요.항상 그렇게 하세요.그럼 다음 커피를 마시며 마실 수 있는 싸구려 여자애들을 찾고 계세요?
서비스를 위해 휴식을 취하세요.글을 올리세요, 으악, 마이크 컨트롤을 던지세요.아뇨, 그러지 마세요.0을 입력하고 치수를 사용하세요.다시 말씀드리지만, 아직 없습니다.
기본 경계에 상관없이 그냥 인스턴스 ID가 되어야 합니다.
서비스에 적합합니다.그리고 나서 먼저 바운스하세요.
나중에 질문하세요.항상 완화 방안을 모색하세요.이 세션이 즐거웠기를 진심으로 바랍니다.여기 내려가서 나중에 복도로 나갈게요회복력에 대해 이야기하고 싶은 사람이 있으면 저도 Peer Talk에 참여하고 있어요.
앞으로 며칠 내로준비는 좀 됐는데
정말 감사합니다. 설문조사에 참여해 주세요.(청중들의 박수 갈채)