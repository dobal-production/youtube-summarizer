- 안녕하세요, 여러분, 감사합니다.
오늘 와줘서 정말 고마워요. 와줘서 정말 고마워요.이건 분명히
제가 아는 많은 분들께는 긴 한 주의 목요일이 될 거예요. 참석해 주셔서 정말 고마워요.슬라이드에서 알 수 있듯이 제 이름은 Tod Golding이고, AWS의 솔루션스 아키텍트입니다. 저는 지난 8~9년 동안 SaaS 분야에서 일하면서 다양한 분야에서 일해 왔습니다.
구축, 제공 및 운영의 다양한 단계에 있는 고객 및 파트너
AWS 기반 SaaS 솔루션.아시다시피, 그 기간 동안 우리는 이러한 솔루션을 구축해왔고, 이를 어떻게, 어디에 장착할 수 있는지 정말 살펴보았습니다.
SaaS 빌더는 일반적인 문제를 훨씬 쉽게 해결할 수 있는 도구를 제공합니다.
그리고 일반적인 문제도 있죠.그래서 우리는 건물을 짓기 시작했습니다.
이상적으로 가속화될 수 있는 레퍼런스 아키텍처, 라이브러리, 다양한 메커니즘
SaaS 구축을 위한 경로.최소한 우리가 만든 많은 것들을 구체적으로 구현할 수 있을 거예요.
슬라이드를 통해 이야기를 나눠보세요.그래서 우리는 EKS 레퍼런스를 만들었습니다.
예를 들어 아키텍처를 예로 들자면, 지난 몇 년 동안 아키텍처에 대해 이야기했는데, 좋은 콘텐츠도 있고, 서버리스 SaaS도 있고, 이와 같은 것들을 예시로 만들었는데 정말
이를 선택하고 즉시 얻을 수 있는 기능을 갖춘 조직에 유용합니다.
SaaS를 구축하는 것이 어떤 모습인지에 대한 실제 관점.하지만 우리는 스스로에게 묻기 시작했습니다. 더 할 수 있는 일이 있을까요?어떻게든 밀어붙일 수 있을까요?
조금 더 나아가서 좀 더 구체적으로 설명하자면, EKS의 한 가지 예나 한 가지 예를 들어보죠.
서버리스의 예시요?사람들에게 더 많은 것을 줄 수 있는 세상으로 나아갈 수 있을까요?
컴포저블 경험을 원하시나요?전부가 아닌 방식으로 SaaS의 일부를 제공할 수 있을까요?
아니면 아무 해결책이 없을까요?제 말은, EKS를 보면 움직이는 부분이 전부 있긴 한데 소비만 하고 싶으시다면
레퍼런스 아키텍처나 그 어떤 차원에서든 쉽게 그럴 수는 없습니다.
모든 것을 분해하고 그냥 이렇게 말하세요. “나 갈래요.
이 부분만 하세요.”이것이 바로 우리가 가진 개념에 생명을 불어넣은 것입니다.
SaaS 빌더 툴킷이라고 부르세요. 아니면 제가 SBT라고 부르는 걸 들으실 겁니다.그리고 SBT, SBT의 전체 비전은 좋은 일을 하는 것이었습니다.
엔지니어링 조직과 모든 팀이 정말 그렇습니다.
사람들에게 더 나은 도구를 제공하려는 노력은 어떻게 할 수 있을까요?
이걸 좀 더 소화하기 쉽게 만든다고요?어떻게 하면 이러한 SaaS 원칙을 위한 일종의 도구 세계를 만들 수 있을까요? 그리고 그러한 도구 세계를 어떻게 활용해서 SaaS 원칙을 쉽게 만들 수 있을까요?
무언가를 골라서 좀 더 세분화된 방식으로 사용할 수 있을 뿐만 아니라 기회도 만들 수 있습니다.
다른 타사에서 확장 프로그램을 추가할 수 있도록 하면 어디인지 알 수 있을 것입니다.
SaaS Builder 툴킷에서는 이미 다이나믹한 작업이 진행되고 있습니다.또한, 저희는 그걸 원했을 뿐이에요.
접근성도 좋아졌으면 좋겠어요.그래서 제가 보기에, 만약 여러분이 도구를 집어 들고 그 도구를 사용할 거라면
여러분의 개발 환경을 자세히 살펴보아야 합니다. 어떻게 변경하고 싶은지, 어떻게 커스터마이징하고 싶은지 알아내세요.
제가 하고 싶은 일을 하기 위한 건가요?우리는 여러분이 수천 줄의 줄을 헤매는 걸 원하지 않았어요.
복잡한 코드, 이를테면 제가 찾고 있는 것이 어디에 있는거죠?제가 변경하면 어떻게 되나요?
그거, 뭐가 깨질까요?우리는, 알다시피, 필연적으로 해내려고 노력했어요.
가치 있는 일을 하세요. 공정한 대우를 받아야 합니다.
엄청난 양의 코드를 작성해 주세요.하지만 우리는 사람들이 한다는 생각으로 그것을 설계하고 구조화하려고 노력했습니다.
우리가 들어와서 변화를 꾀할 거고
그걸 집어서 조각으로 쪼개서 먹으려고 했어요.그래서 제 목표는
오늘 세션은 정말, A, 여러분께 일종의
툴이 무엇인지, 툴의 범위가 어떻게 되는지에 대한 이해는 물론이고, 그 안에 들어가 볼 수도 있죠, 그렇죠?이 세션은 400레벨 세션입니다. 일단 끝내면
초반부에서는 SBT를 사용하여 환경을 구성하는 방법에 대한 많은 코드와 많은 예제를 보게 될 것입니다. 이를 통해 얻을 수 있는 것은
과거로 돌아가서 미리 시작하세요.그리고 링크도 공유할게요.
이 글의 끝부분에 대해 알려드리죠.
그 일환으로 SBT로 넘어가면 다운로드하여 직접 살펴볼 수 있습니다.그래서 여러분이 이 자리에 오셨기를 바라며, 우리는 이 코드를 확실히 이해할 수 있을 것입니다.이 소개 부분처럼 개념을 알아본 다음 정말 보고 싶어하는 부분에 대해 알아보겠습니다.이제 SBT에 대해 많은 이야기를 나누기 전에 먼저 다루어야 할 사항도 다루어야 합니다.
제가 가끔 받는 미해결 질문에 대해서요.사람들은 이렇게 말합니다. “음, 저기 있어요.
SaaS에 대한 청사진은 없어요. 왜냐하면 저는 항상 제 프레젠테이션을 많이 보면 그렇지 않은 것도 있다고 말하거든요.
제가 의도한 모든 것에 SaaS 스토리를 위한 청사진이죠. 그게 사실이기 때문이죠.다양한 도메인,
다양한 기술 스택, 다양한 환경, 다양한 팀, 다양한 매개 변수가 있습니다.
이는 여러분이 가지고 있는 것의 형태와 성격을 변화시킵니다.
SaaS 솔루션은 어떤 모습일지 모릅니다.네, 아주 상황에 맞게 SaaS 애플리케이션을 구축하는 거죠.동시에 구조도 있고 다양한 테마도 있습니다.
대부분의 아키텍처들과 같은 핵심 개념들이 계속 반복해서 볼 수 있습니다. 이것이 바로 SBT의 이면입니다. 우리가 말하자면,
핵심 테마를 가져와서 바꿀 수 있을까요?
근본적으로 빌딩 블록으로 만드나요?그리고 그것들을 충분히 구분해서 여러분이 참여할 수 있을 만큼 구성 가능한 것으로 만들 수 있을까요?
조각으로 나눠서 드시겠어요?자, 이제 제가 컨트롤 플레인을 가지고 있는 것을 보실 수 있을 겁니다.
그리고 애플리케이션 플레인.이에 대해 잘 모르신다면 SaaS에 대해 많이 이야기할 것입니다.이 컨트롤 플레인은
거의 모든 부분이 수평으로 되어 있는 부분이죠.
SaaS 환경의 한 부분으로서 여러 가지 문제를 해결해 보겠습니다. 이제 무엇이 문제인지 자세히 살펴보겠습니다.
조금 들어보죠.그리고 앱 플레인은 모든 종류의 비즈니스를 위한 곳입니다.
기능이란 바로 여기서 테넌트 격리와 데이터 파티셔닝을 비롯한 모든 전형적인 문제를 해결할 수 있다는 것입니다.우리는 항상 이것을 SaaS의 두 부분이라고 부릅니다.보시다시피 SBT가 많이 있습니다.
이걸 보고 물어보죠. 이게 뭐죠?그게 무슨 역할을 하죠?다음과 같은 개념을 보실 수 있을 겁니다.
컨트롤 플레인과 앱 플레인이 표면 전체에 나타나는 이유는 크기가 크기 때문입니다.
우리가 무엇을 하든 간에 우리가 알고 있는 상위 수준의 구조는 컨트롤이 필요하다는 것을 알고 있습니다.
플레인, 앱 플레인이 필요해요.그럼 SBT는 해볼게요
컨트롤 플레인과 앱 플레인을 제공한 다음 컴포저블을 제공합니다.
움직이는 부분 안에서 말이죠.그래서 만약 우리가 이렇게 한다면
고차원적인 그림을 꺼내서 이렇게 말하세요. “음, 이게 뭐예요?
SBT의 주요 요소들은요?무엇을 받을 수 있나요?박스에 뭐가 들어 있어요?”이 내용을 세 가지 영역으로 나누었음을 알 수 있을 겁니다.컨트롤 플레인이 있었어요. 시작했을 때 분명히 많은 사람들이 있었죠.
SaaS 컨트롤 플레인에 대해 점점 더 많은 이야기를 나누면서 이런 생각이 계속 들었습니다. “준비해 주실 수 있나요?
컨트롤 플레인을 만들었나요?”왜냐면 뭐가 너무 많아서
사실 저기 컨트롤 플레인에서 하고 계신 거잖아요
바로 사용할 수 있는 툴로 가장 적합한 후보 중 하나입니다. 많은 솔루션에서 공통적으로 사용되는 기능이 많기 때문입니다.테넌트 관리가 필요합니다.
메트릭과 분석도 필요하고 청구도 필요합니다.그래서 저희는 SBT와 함께 적어도 잘 패키징되고 바로 사용할 수 있는 컨트롤 플레인을 만들려고 노력했습니다.아시다시피, 바로 사용할 수 있는 컨트롤 플레인인 프로덕션 등급은 아닙니다. 하지만 여기에는 모든 움직이는 부분이 있기 때문에 이를 가져와 특정 조직을 위한 프로덕션 버전을 만드는 것이 일종의 일입니다.이 컨트롤 플레인에서도 타사 통합을 볼 수 있습니다.따라서 청구 및 미터링과 같은 매우 구체적인 개념이 있습니다.
그리고 제어 영역에 있는 인증에는 여러 공급자가 있을 수 있습니다.그래서 누군가가 솔루션에 다른 공급자를 데려오고 싶어할 수도 있다고 생각했던 영역에서 우리는 세 번째 공급자를 허용하는 메커니즘을 만들려고 노력했습니다.
당사자가 통합하면 3분의 1이 어디인지 알 수 있을 것입니다.
당사자들이 여기에 개입하여 이러한 오퍼링에 추가했습니다.그리고 이 강연에서 아마 여러 번 들으실 수 있을 거라는 컨셉을 꼭 말씀드리고 싶은데요, 자신만의 컨트롤 플레인을 가져오라는 아이디어죠.이것이 우리가 가지고 있는 컨트롤 플레인, 그리고 SBT입니다.
오늘은 컨트롤 플레인입니다. 컨트롤 플레인이 되기 위한 것은 아닙니다.우리는 이미 자체적으로 다양한 기술 스택을 사용하여 더 많은 컨트롤 플레인을 구축하는 것을 고려하고 있습니다. 예를 들어, 오늘날 컨트롤 플레인은 서버리스로 구현되어 있는데, 구현한다면
컨테이너 기반 버전인가요?다른 것도 들여올 수 있을까요?
아이덴티티 및 기타 용도의 타사 제품
이것의 또 다른 움직이는 부분은요?저한테는 당신이 그러길 바라지 않아요
컨트롤 플레인을 유일한 컨트롤 플레인이라고 보시면 좋겠습니다.
컨트롤 플레인을 가지고 나서 물어보는 패턴은
저희가 도와드릴 수 있는 것이 있나요, 아니면 더 필요한가요?기여하고 싶으신가요?
사실 하나는 가능하죠.그럼 반대편은
이 앱 플레인, 앱 플레인은 이전에 구축한 모든 레퍼런스 아키텍처를 자연스럽게 가져와 사용할 수 있는 공간이었습니다.제가 말씀드린 것처럼
서버리스, EKS 등등, 이렇게 말해보세요. “그럼
기존 버전을 분해해서 앱 플레인 부분을 가져와서 SBT에 넣고 SBT 규정을 준수하도록 다시 작업한 다음 소비하도록 해 보겠습니다.
일반적인 컨트롤 플레인.거의 증거에 가까웠어요.
우리가 이렇게 말할 수 있었던 컨셉은 “이 앱 전체가 그런가요?
플레인/컨트롤 플레인이 작동하나요?새 스택을 가져올 수 있나요?그리고 우리가 만들었나요?
컨트롤 플레인 사이의 적절한 경계선과
앱 플레인에서 제대로 작동할까요?”그래서 만약 여러분이 오늘 SBT를 받으러 가서 이렇게 말하면, “이봐, 나
컨트롤 플레인도 필요하고 EKS 레퍼런스도 필요해요
아키텍처를 제 앱 플레인처럼 사용하세요.” 두 부분을 모두 구할 수 있고, 원한다면 그곳이 출발점이 될 것입니다.또한, 우리의 일환으로
실험을 해보니 새 제품을 가져왔는데 CS가 없었어요.
이전의 레퍼런스 아키텍처였죠.그래서 저희가 말했죠. “이봐, 이제
이걸 해냈으니 얼마나 쉬울까요?
새 앱 플레인을 도입할 사람이 있나요?”그리고 그 팀은 2~3주 만에 새로운 ECS 앱 플레인 예제를 도입했습니다.제 생각에 컨트롤 플레인을 꺼내는 것만으로도 이러한 제품을 생산하는 데 따르는 부담이 크게 줄어들었다는 증거가 있다고 생각합니다.
레퍼런스 아키텍처.타사 통합을 다시 한 번 하고 자체 앱 플레인도 가져와야 합니다.
여기서는 자명하죠, 그렇죠?앱 플레인은 다양한 유형의 기술을 위한 공간입니다.
스택 및 솔루션.다음과 같이 시드했습니다.
몇 개는 성공으로 이어지겠지만, 앞으로 더 많이 나타날 것으로 예상합니다.실례합니다.그리고 아래쪽에 도서관만 보이실 겁니다.
그리고 유틸리티도 있죠?여기가 우리가 살아온 곳이야
우리가 만든 많은 것들을 가져왔는데, 토큰 자판기는
우리가 만든 도서관은 정말 유명한 도서관으로, 이런 사람들을 도울 수 있습니다.
테넌트 격리를 하면서 다음과 같은 개념을 취했습니다.
그걸 패키지로 묶어서 이 라이브러리 영역에 넣었죠.따라서 앱 플레인을 구축할 때는 저희 앱 중 하나를 사용하던지
직접 만들면서 이렇게 말할 수도 있겠죠. “나도 할래요.
테넌트 격리를 해봐, 토큰 자판기를 만들고 싶었어.” 우리가 할 수 있는 방법을 알려드렸어요
이를 사용자 환경에 적용하고 쉽게 적용할 수 있습니다.
토큰 자판기.그러니까 예상할 수 있겠네요.
도서관과 유틸리티 분야는 이 분야에서 훨씬 더 성장할 거예요. 왜냐하면 우리가 실제로
하려고 하는 건, 어떤 도구를 사용해서 좋은 앱 플레인을 더 쉽게 만들 수 있느냐는 거죠.이제 저희가 하고 싶었던 일 중 하나는 이 앱을 어느 정도 컴포저블로 만들고 사람들이 접근할 수 있도록 하기 위해서입니다.
저희가 원하던 부분만 골라보세요. 저희는 이 작품을 만들고자 했습니다.
느슨하게 결합된 경험이긴 하지만, 통제력을 가지려면 인정해야 합니다
플레인이랑 앱 플레인은 의도적으로 상호작용이 있어서 둘 사이를 오가는 거죠.그래서 우리는 어떤 종류를 정의해야 한다고 말할 수 밖에 없었습니다.
여기에 통합 계약이 있습니다.아마 이곳이 우리가 매우 훌륭하다고 말할 수 있는 몇 안 되는 곳 중 하나일 것입니다.
어떻게 작동하는지 규범적이었어요 왜냐면 우린 그래야만 했으니까요
이 수준에서는 규범적이었죠.그래서 우리는 여기서 인터페이스를 정의했습니다. 기술을 살펴보죠.
그게 바로 인터페이스의 배경이 돼서 작동하죠.하지만 우리는 기본적으로 이렇게 말했죠.
“컨트롤 사이에서 흔히 발생하는 일반적인 이벤트는 무엇인가요?
플레인이랑 앱 플레인?”그래서 온보딩은 이벤트를 전송합니다.
앱 플레인으로 이동하여 온보딩, 지표, 분석 및 데이터를 완료하세요.
앱 플레인에서 컨트롤로 돌아옵니다.
집계할 플레인.하지만 공간이 많이 남았다고 말씀드렸죠.
여러분이 이렇게 말씀하실 수 있습니다. “글쎄요, 저만의 이벤트를 추가하고 싶거나 저만의 프로토콜을 추가하고 싶어요.
이 통합에 대해서요. 하지만 여기 어딘가에
이 기능이 작동하려면 통합이 필요합니다.그런 다음 컨트롤 플레인 안에서 빌링과 미터링, 그리고 우리가 할 수 있을 거라고 생각했던 다른 영역들에 대해 이야기했습니다.
규범적인 컨트롤 플레인을 제공해 드릴 수 있습니다.
이러한 것들을 구현한 것이긴 하지만 사람들이 직접 제품을 가져오고 싶어할 것이고 파트너들은 직접 와서 제품을 가져오길 원할 것이라는 점을 인정해야 합니다.이제 여기에서 컨트롤 플레인의 확장성 모델을 사용한 예제를 살펴보겠습니다.
이 작업을 수행하기 위한 인터페이스.그리고 라이브러리 영역에서도 퍼스트 파티 또는 서드 파티에서
이 경험을 통해 타사 라이브러리와 도구를 가져올 수 있습니다.그래서 저는 우리가 나가서 물건을 가져오고 스위치를 돌리면 되는 궁극의 플러그 가능한 경험을 만들었다는 생각을 아무에게도 알려주고 싶지 않습니다.
그리고 모든 것이 제대로 작동하죠.예를 들어, 제작을 하는 것 처럼요.
이 인터페이스들은 잘 작동하지만 아직 글을 써야 합니다.
인터페이스와 호환되도록 만드는 조그마한 코드죠. 그래서 우리는 이 코드를 만들고자 합니다.
확장 가능한 환경이지만 일부 확장성은 관습을 통해서도 제공됩니다. 예를 들어 “여기서 이런 일이 일어납니다.” 라고 말하기는 했지만, 그래도 직접 들러서 환경을 조정해야 할 수도 있습니다.
제대로 작동하려면 약간이요.그래서 저는 여러분께 이 모든 것이 자급자족해서 그냥 사용할 수 있다는 생각은 드리고 싶지 않습니다.
스위치를 끄고 스위치를 돌려서 전원을 켜고 끕니다.이제 정말 중요한 게 하나 있어요.
여기서 SBT를 통해 얻을 수 있는 교훈은 SBT는 CDK라는 것입니다.
경험이 많죠?힘과 강점, 그리고... 에 크게 의존하고 있습니다.
방법을 설명하는 CDK의 표현력
인프라가 프로비저닝되고 구성되는 방식인데 앱 플레인 및 애플리케이션 플레인 모두에서 이러한 경험이 많이 발생하기 때문입니다.
컨트롤 플레인 측에서는 온보딩 또는 환경 구성, 프로비저닝 및 설정에 관한 것입니다.
초기 설정이든 무엇이든 상관없습니다.제가 보기에 CDK의 장점은
완전한 표현이 가능한 언어이고 O 언어이고, 그나저나 우리는 타이프스크립트를 사용하고 있지만
다양한 언어를 지원하며 그 근본에는 다음과 같은 것이 있습니다.
CDK 구조체의 개념.CDK 구조가 가장 좋습니다.
라이브러리에 있는 추상적이고 기본적인 아무것도 없는 객체
CDK가 알고 있는 것이죠.그리고 우리가 한 일은
근본적으로 그 구조체에서 파생되어 SBT 구조체인 전체 구조체 라이브러리를 만들었습니다.자, 이제 보시면 아시겠지만
컨트롤 플레인 구조체, 그리고 그 안에
컨트롤 플레인 구조체에는 실제로 빌드하고 프로비저닝하는 데 필요한 모든 기능이 포함되어 있습니다.
컨트롤 플레인을 구성하세요. 그러면 컨트롤 플레인은 구조를 사용합니다.테넌트 관리 구조도 있고, 사용자 관리 구조도 있습니다.자세히 살펴보면 다음과 같이 보일 것입니다.
코드를 살펴보면 모든 것이 다음과 같이 표현됩니다.
이런 다양한 구조들.그래서 어떻게 그리고 어디서 수정하고 싶은지 살펴보기 시작하면서
행동을 바꾸든 말든, 당신은 여전히 그냥 들러서 이렇게 말하고 있어요. “아, 저만의 행동을 만들고 싶어요.
테넌트 관리 구조, 어떻게 소개할까요?직접 만들어도 되고 대체할 수 있을까요?
현재 있는 테넌트 관리 구조가 있나요?”어떻게 작동하는지 살펴보도록 하겠습니다.다른 하나는 정말 중요하죠.
여기서 짚고 넘어가야 할 점은 SBT는 도구라는 것입니다.
제품이 아니죠?우리는 만들려고 하는 게 아니에요
클릭 한 번으로 다운로드하면 인스톨러가 있고 UI를 불러와서 뭘 할지 말하죠
SaaS 애플리케이션 또는 SaaS 환경이 어떤 모습인지 알고 싶습니다.에디터 입장에서 무언가를 짜는 것과 같은 순간입니다.
CDK를 통해 원하는 경험을 해보세요.그런 측면에서 볼 때, 이 프로그램은
건축업자 또는 이를 잘 알고 이해하는 사람의 손
적어도 CDK와 이러한 코딩 개념 중 일부를 중심으로 길을 찾는 방법.그리고 더 많이 할수록
이러한 구조를 이해하고 더 많이 가질수록
이런 언어 구조를 통해 길을 찾는 게 더 접근하기 쉬울수록
여러분을 위한 것일 거예요.그래서 만약 이렇게 말하면, “음, 어떻게 생겼지?
그럼 이걸 할 수 있는 거지?”예를 들자면
어떻게 보일지, 제가 건설하러 가고 싶다고 해봅시다.
SBT가 포함된 SaaS 솔루션, 먼저 나가서 SaaS 빌더 툴킷을 설치하겠습니다.이 제품은 다음과 같은 형태로 출시되어 있습니다.
여기 npm을 사용하여 패키징하세요. 많은 분들이 가지고 계실 것입니다.
과거에 npm을 보거나 사용했지만 기본적으로 설치해야 합니다.
SBT를 설치하듯이 사용자 환경에 SBT 설치
인터넷에 없는 다른 라이브러리.다른 확장 프로그램이 있는 경우
설치하시면 됩니다.그리고 이제 여러분의 코드에서
편집기에 들어가면 기본적으로 어떤 구문을 가져와야 할까요?뭘 하고 싶은데?전체 내용은 다음과 같습니다.
저희가 만들어 드린 구조물의 풍경이요.그냥 사용할 수 있습니다.
가장 단순한 방식이고 그냥 다음과 같은 일을 할 수 있습니다.
이미 턴키 방식이므로 바로 사용할 수 있습니다.또는 좀 더 세부적인 방법으로 선택하여 커스터마이징할 수도 있습니다.
바로 그 경험이 여기 있습니다.그래서 이 예제에서는 가장 간단한 모델을 사용해봤습니다.제가 창작을 하고 싶다고 가정해 봅시다.
컨트롤 플레인을 돌리면, 여기는 유사 코드입니다. 컨트롤을 불러오겠습니다.
툴킷에서 꺼내서 다음과 같이 사용할 수 있었습니다.
에디터에서 참조할 수 있는 항목이었어요.그리고 나서 스택을 선언할 거예요. 잘 아시는 분이 계시다면
기본적으로 CDK를 사용하면 언제든지 인프라, 주변 구조물을 프로비저닝하거나 구성할 수 있습니다.
클라우드와 마찬가지로 스택이라고 합니다.
포메이션 스택 등그리고 나서, 이 글의 본문 안에서 제가 무엇을 제어하고 싶은지를 말씀드리죠.
비행기가 어떻게 생겼냐고요?여기서는 앱 플레인 구성도 가져올 수 있고, 여기는 라이브러리 등 제가 원하는 모든 것을 가져올 수 있는 곳입니다.
여기 도움이 필요해요.그리고 이 물건이 이미 있고 제가 모든 것을 다 넣었을 때
제가 원하는 에디터에서는 그냥 CDK를 사용하겠습니다.
배포를 통해 직접 구성과 구성을 가져와서 배포하고 환경을 설정해 보세요.그리고 이것의 장점은
변경하면서 CDK가 좋아요를 누를 수 있는 기능도 생겼고
델타가 자동으로 처리되고 변경 사항이 적용됩니다.그래서 밝혀진 건
적어도 저희 의견으로는 정말 좋은 메커니즘이죠.자, 그럼 SBT의 전반적인 경험과 우리가 달성하고자 하는 바는 이것으로 충분합니다.직접 보고 확인할 수 있도록 컨트롤 플레인을 자세히 살펴보겠습니다.
이 안에 뭐가 들어 있냐고요.그리고 제가 시작한 건
여기서 가장 간단한 모델이죠.근본적으로 안 될 거라고 말할 수 있는 곳이죠.
컨트롤 플레인을 아주 많이 구성하세요.그냥 나가면 돼요
컨트롤 플레인을 선언하고 기본값 대부분을 사용하세요.
컨트롤 플레인의 동작을 살펴보고 어떤 일이 일어나는지 확인해 보세요.여기로 들어가시면 맨 위에 제가 기본적으로 SBT를 가져오고 있는 부분이 보이실 겁니다. 제가 이미 작업을 완료했기 때문이죠.
npm을 제 환경에 설치하세요.이제 생성해 보겠습니다.
컨트롤 플레인 스택, 스택이 좀 있어야 하는데
이건 그냥 CDK 구조일 뿐이에요.이제 설정의 일부로
제 컨트롤 플레인, 컨트롤 플레인 자체를
인증이 있고, 이 경험에 참여하는 시스템 관리자의 ID가 있고, 공급자가 있어야 합니다.그래서 이 경우에는 기본값을 제공했습니다.
이 구현은 Cognito 인증이므로 이 환경의 일부로 Cognito 인증을 설정하겠습니다.그리고 여기서 설정해야 하는데, 그 중 일부는 누가 초기 시스템인지도 알려주기 때문이죠.
컨트롤 플레인을 프로비전하면 관리자 사용자가 될 것입니다.그럼 그냥 말하시면 됩니다. 그냥 새로 만들면 되죠.
SBT 컨트롤 플레인이 여기 있어요.그래서, 컨트롤은
비행기, SBT. 여기 보이는 컨트롤 플레인은
이 라이브러리에서 가져온 컨트롤 플레인 구조체
우리가 가지고 있는 모든 것을 기본 구현으로
바로 사용할 수 있습니다.그래서 만약 당신이 원하신다면
박스에서 꺼내서 사용하면 다음과 같이 보일 것입니다.그러면 어디에 있는지 알 수 있을 것입니다.
인증의 일환으로 이메일 주소, 즉 이메일 주소를 제공합니다.
관리자 사용자용이고 그게 전부입니다.그래서 저한테는 이게 가장 간단하죠.
그냥 다운로드해서 “아무거나 내놔.” 라고 말하면
조종기가 있잖아.” 그냥 가서 실행해
CDK로 스택을 배포하면 컨트롤 플레인이 실행되고 있어요.컨트롤 플레인 구조 안에서 실제로 무슨 일이 벌어지고 있는 걸까요?그게 우리에게 어떤 영향을 주고 있는 걸까요?
그게 우리를 위해 무엇을 구성하고 있는 걸까요?음, 설정에 대해 얘기해봤는데
이를 위해 Cognito를 설치해 주세요.테넌트 관리 기능이 있습니다.
서비스 계약이 포함되어 있습니다. 거의 모든 컨트롤 플레인이 어딘가에 있어야 합니다.
테넌트 상태, 테넌트 정책, 이 모든 것을 관리합니다.
테넌트의 기타 특성.그래서 그 구조는 다음과 같습니다.
테이블을 만들고 다른 모든 비트를 설정하는 데 사용합니다.사용자가 있어야 합니다.
시스템 관리자를 위한 관리 기능만 있는 것이 아닙니다.
처음에 이들을 만들려면 다음을 만들어야 합니다.
마이크로서비스, API, 그리고 여러분을 가능하게 하는 모든 것
초기 생성 이후에도 이러한 서비스와 상호작용할 수 있습니다.예를 들어, 다음과 같은 경우
맨 위에 관리자 콘솔이나 CLI가 있습니다.
컨트롤 플레인에서는 이 사용자 관리 시스템의 CRUD 인터페이스를 사용하여 새 사용자를 생성할 것입니다.
사용자 관리 등테넌트 관리 서비스와 동일합니다.생성 중에만 제공되는 것이 아니므로 직접 가서 살펴보는 것이 좋습니다.
세입자의 상태를 보고 뭐라도 하세요.그래서 API가 있고
이 모든 것이 제대로 작동하도록 도와주는 서비스들이죠.실제 컨트롤 플레인 API
여기서 직접 생성해야 하고, API 게이트웨이와 이에 필요한 모든 비트를 설정해야 합니다.그리고 이 이벤트 매니저는
구조는 이미 나와 있습니다. 이벤트 관리자 구조는 컨트롤 플레인과 앱 플레인 간의 통신을 가능하게 하는 것입니다.
앞서 얘기했었죠.그래서, 그래도
이전 슬라이드에서 본 코드는 우리가 거의 아무것도 하지 않은 것처럼 보였는데, 정말 많은 일이 진행되고 있습니다.
여기서는 내부적으로 살펴보죠.그래서 좀 더 자세히 들여다보면 알 수 있을 겁니다.
컨트롤 플레인 경험을 한 번 보시고 그 일부를 보시고 제가 가서 꺼내봤어요.
테넌트 관리 구조.그래서 우리가 파헤쳐 본다면
컨트롤 플레인을 살펴보면 어딘가에서 이 테넌트 관리 구조를 갱신하고 이를 사용하여 테넌트 관리 환경을 초기화하는 것을 볼 수 있을 것입니다.그 안에 묻혀 보면 한 가지 사실을 알 수 있을 것입니다.
실제로 테이블을 생성하고, 모두 생성하고 모두 저장하려면 DynamoDB 테이블이 필요합니다.
상태도 그 일부입니다.자, 여기서 구조물들이 점점 더 깊이 들어가서 이 경험에 연쇄적으로 들어가는 것을 다시 볼 수 있습니다.그냥 하는 게 아니라
하지만 원시 명령과 DynamoDB 테이블 생성을 통해 IM 비트와 데이터를 포함한 모든 비트를 래핑하는 테넌트 관리 테이블을 만들었습니다.
테이블 구성 및 기타 모든 항목
거기서 일어나야 돼요.그리고 내일 “글쎄요, Dynamo에 저장하고 싶지 않거나 다른 것을 하고 싶어요”라고 말한다면, 테넌트 관리 테이블 구조를 직접 대체하여 원하는 대로 할 수 있습니다.분명히, 그게 다른 문제를 어떻게 망가뜨렸는지 알아내야 할 거예요.하지만 저는 베풀려고 노력하고 있어요.
기회가 어디에 들어와야 하는지 더 잘 알 수 있고, 원한다면 행동을 바꿔야 합니다.그러면 다음과 같은 내용도 볼 수 있을 것입니다.
여기 테넌트 관리 Lambda가 있습니다. 이것은 서버리스 환경입니다.그래서 우리는 테넌트를 가동하고 있습니다.
관리 마이크로서비스는 다음과 같이 수행할 수 있는 다양한 작업을 모두 지원하는 일련의 람다입니다.
테넌트 관리의 일부.이 테넌트 관리에서 반환된 Lambda 호출이 여기에 있는 Lambda 변수라는 것을 알 수 있습니다. 그 위치를 살펴보겠습니다.
잠시 후 관련성 있는 방식으로 참조됩니다.하지만 그 일환으로 HTTP 통합을 설정하기도 합니다. 바로 여기가 바로 그곳입니다.
함수로 이동하는 경로 등을 설정하기 위해 API 게이트웨이를 설정하세요.하지만 Lambda 함수를 설정하면 아래 테넌트 관리 함수를 볼 수 있습니다. 이것이 바로 Lambda입니다.
반환된 함수입니다.여기서 한 단계를 백업해 보겠습니다.여기서 보실 수 있을 겁니다.
여기 있는 Lambda.TenantManagement Func는 다음과 같은 경우에 참조됩니다.
HTTP 통합을 설정하는 것은 실제로 여기서 가져온 코드, 즉 모든 파이썬이 있는 곳을 참조하는 것입니다.
제 환경에서는 이 모든 다양한 Lambda를 구현하는 모습입니다.
시중에 나와 있는 함수들.다시 말씀드리지만, 여전히 제 느낌은
들어가서 방법을 알아내는 건 그렇게 어렵지 않아요.
아니면 바꾸고 싶지만, 이해도 할 수 있을 겁니다.
맛과 접근 방식, 전체적인 디자인
이 경험의 모델이죠.여기서 또 다른 부분을 보여드릴게요.
컨트롤 플레인을 만들어서 모든 것을 설치하고 실행해 보세요. 이제 컨트롤이 필요하죠.
비행기가 가동되고 있고 우리가 처리할 예정입니다.
온보딩 이벤트.음, 그걸 설정하기 위해 우리가 뭘 했냐고요?그러면 어떤 일이 벌어질까요?
온보딩 이벤트가 열리나요?글쎄요, 이 모든 것은 내부에서 생성되는 등록 서비스를 통해 관리됩니다.
컨트롤 플레인과 등록 서비스는 기본적으로
다양한 모든 서비스의 오케스트레이션 처리
테넌트를 시스템에 온보딩하려면 호출해야 하는데 실제로는 꽤 많습니다.또한 앱 플레인이 가능하도록 앱 플레인으로 전송해야 하는 모든 이벤트를 오케스트레이션합니다.
온보딩 경험의 일부로 필요한 작업을 수행하십시오.그리고 참고로, 데이터를 추적하는 테이블도 있습니다.
등록이 진행되는 동안의 상태 및 진행 상황.따라서 한 테넌트가 온보딩을 시작하고 우리가 이 모든 것을 다르게 부르기 시작하면
생성하려면 이 등록 테이블을 약간 업데이트한 다음 등록에 대한 API가 필요합니다. 이 API를 통해 다음 작업을 수행할 수 있습니다.
CLI나 콘솔을 이용해서 이렇게 말하세요. “등록은 어떻게 진행되고 있나요?아니면 이 중 하나가 멈춘 것 같은데, 가서 상태를 보고 지금 어디에 있는지 봐도 될까요?”그래서 여기에 다음과 같이 할당해 보겠습니다.
등록, 고유 식별자, 그리고 그 데이터로부터 데이터를 가져옵니다.
우리 환경으로 들어오는 메시지의 본문을 보면 다음과 같이 보일 것입니다.
여기 테이블이 있어요. 여기서 말씀드렸잖아요
우리는 이 상태를 저장하고 있고, 이 항목들을 테이블에 넣고 현재 상태를 저장하고 있습니다.
이 등록의 상태를 해당 테이블에 담았습니다.그런 다음 테넌트 관리 서비스에 메시지를 게시하고 있습니다. 앞서 설명했던 테넌트 관리 서비스에 메시지를 게시하고 있습니다. 해당 테넌트 관리자에게 메시지를 게시하고 있습니다.
서비스를 통해 말하자면, 시스템에서 이 테넌트를 생성하면 바로 그 테넌트를 만들고 있는 것입니다.
해당 테넌트에 첫 번째로 들어가서 사용자를 설정하고 그 과정에서 발생해야 하는 다른 부분들을 설정합니다.그리고 마지막으로 이 항목이 다시 돌아오면 테넌트를 업데이트합니다.
테넌트 ID와 해당 테넌트를 생성할 때 가져온 정보를 사용하여 등록합니다.마지막으로, 이 슬라이드에서는 다루지 않을 수 있기 때문에 이 부분도 함께 살펴보겠습니다.
이 글의 앱 플레인 쪽에서 테넌트를 만드세요.이제 이걸 보실 수 있을 겁니다.
컨트롤 플레인 이벤트를 만드세요. 이 컨트롤 플레인 이벤트를 만들면 기본적으로 채워집니다.
온보딩하고 있는 테넌트에 대한 데이터를 포함하는 이벤트입니다.
계획, 그들의 정보, 온보딩되어 앱 플레인에게 이렇게 말하는 사용자, “야, 무슨 이벤트야?
보내드릴까요?”우리가 새 테넌트를 온보딩 중이었는데 그게 해고됐어요
그리고 돌아오면 들어오는 데이터를 얻을 수 있을 거예요
그걸 보고 돌아와서 말하자면, 성공했나요?실패했나요?그리고 궁극적으로는 언제
이 모든 것이 엉망이 되면 등록이 업데이트될 것입니다. 우리가 성공적으로 프로비전했나요?
앱 플레인 내 테넌트?움직이는 부분이 너무 많아서 이미 너무 많았습니다.
디테일이 원했던 것 이상일 수도 있습니다.하지만 이 움직임의 측면에서 어떤 일이 벌어지고 있는지 알려드리고 싶습니다.
앱 플레인과 컨트롤 플레인 사이, 그리고 이것이 어떻게 구현되는지에 대해
내부적으로 살펴보자면, 그 방법도 다시 한 번 설명해 드리겠습니다.
CDK 안에서 작동하죠.이제 마지막으로 말씀드리고 싶은 컨트롤 플레인에 대해 말씀드리자면, 인터페이스가 있다고 말씀드렸는데, 빌링 메터링에 대한 모든 것이 갖춰져 있습니다.이들 각각은 이러한 인터페이스의 추상화를 다음과 같은 방식으로 선언하려고 시도했습니다.
최소한 컨트롤 플레인에 필요한 기본 작업을 지원할 수 있기를 바랍니다.컨트롤 플레인이 필요로 하는 것보다 훨씬 더 많은 일을 할 수도 있습니다. 우리는 그저 노력하는 것뿐입니다.
필요해 보이는 기본 작업을 소개해 드리겠습니다.
우리가 만질 수 있는 곳을 컨트롤 플레인과 통합할 수 있습니다.보시면 아시겠지만, 우리는
여기에 인증이 있습니다. 테넌트, 죄송합니다. 시스템 관리자이고 Cognito는
이를 구현한 것입니다.Okta를 넣을 수도 있습니다.
여기에 핑 (Ping) 을 넣을 수도 있고, 다른 것을 넣을 수도 있습니다.
원하신다면 구현해 보세요.그리고 결제 측면에서도 Moesif를 통해 통합을 구현했습니다. 바로 우리가 원했기 때문이죠.
보세요, 이게 실제로 효과가 있었나요?사람들이 통합할 수 있나요?가서 보시면, 거기에 예들이 있습니다.
빌링 통합에 대해서요.그리고 미터링 측면에서는
앰버플로가, 오, 너무 빨리 갔어요Amberflo는, 오, 재미있네요. 전체를 구현했네요
우리를 위한 미터링 솔루션.그래서 저는 이 모든 것이 진화할 것이라고 확신합니다. 하지만 이 인터페이스들은 괜찮은 수준을 대표하고 있는 것 같아요.
확장성 측면에서 보면 시간이 흐르면 지원을 위해 어떻게 발전할지 알아내야 할 것 같습니다.
더 많은 특징 및 기능.자, 이것이 컨트롤 플레인입니다. 그 내부를 살짝 엿볼 수 있습니다.더 많았는데 우린
저기 좀 볼 수도 있겠지만, 어떤 내용인지 더 잘 설명해 드리고 싶어요.
앱 플레인 측에서 일어나는 일이에요. 앱 플레인이
여기는 조금 다릅니다.처음에 말씀드렸듯이
컨트롤 플레인에 있는 이 상자들, 보라색 상자가 보이시죠. 몇 개 있을 거예요.
대부분의 컨트롤 플레인에 있는 박스의 변형이죠.오른쪽에 있는 앱 플레인에는 무엇이 표시되는지 누가 알겠어요?기술 스택은 무엇이든 될 수 있습니다. 우리가 풀스택 사일로에 배포되고 있나요?우리는 풀 스택 풀이나 그런 것들의 일부 변형에 배포되고 있습니다.어떤 계층화 전략, 여기에 있는 수많은 파라미터가 라우팅 방식에 영향을 미칠까요? EKS의 테넌트당 네임스페이스일까요?별도의 함수인가요?
서버리스를 사용한다면?이 모든 것에 어떻게 배포할 수 있을까요?예를 들어, 모든 것이 완전히 다르게 보일 수 있습니다.그래서 우리한테는 그러지 않았어요.
앱 플레인에서 사용할 수 있는 것에 제약을 가하고 싶었지만, 우리가 제공하는 앱 플레인 중 하나를 사용하지 않고 직접 앱 플레인을 만들려는 경우에도, 우리가 제공할 수 있는 것 중 하나를 줄 수 있는지 말씀드리고 싶었습니다.
앱 플레인을 조금 앞당겨서 시작해보자면
적어도 사람들이 빌드할 때 흔히 하는 일이 무엇인지는 알 수 있을 것입니다.
앱 플레인이 앱 플레인을 구현하기 위해 할 수 있는 일은 무엇일까요?몇 가지 도구, 라이브러리, 메커니즘을 알려줄 수 있을까요?
그러면 더 쉬워질까요?그럼 무엇이 관련되어 있는지 살펴보자면
앱 플레인을 만들 때 우리는 그냥 분해합니다.
우리가 모든 것을 구축할 때 이것을 빌딩 블록으로 만들어 버립니다.
레퍼런스 아키텍처는 SBT 이전에도 항상 이런 기능이 있었다는 것을 알 수 있었습니다.
우리가 기본 애플리케이션이라고 부르는 것에 대한 개념
비행기 인프라, 이봐, 난 몰라요
아직 세입자가 없는데 필요한 게 뭐가 있을까요?
세입자가 나타나기 전에?VPC를 만들어야 돼요, 저는
클러스터를 만들어야 하고, 게이트웨이를 만들어야 하고, 어쩌면, 좀 만들어야 할지도 몰라요
다른 인프라.만약 제가 베이스라인 구축의 일환으로 완전히 통합된 환경을 가지고 있다면 그렇게 하겠다고 주장하실 수도 있겠습니다.
제가 원하는 서비스를 새로 만들지 않으면 시간이 날 때까지 기다릴 수도 있습니다.
첫 번째 테넌트가 온보딩했어요.하지만 근본적으로 우리 회사의 거의 모든 사람들이
앱 플레인 경험에는 이와 같은 기본 구조가 있는데, CDK가 이를 주도하고 있기 때문에 구문을 보게 될 것입니다.그리고 다른 하나는, 음,
이 작업이 완료되면 기본 환경을 얻을 수 있습니다.그리고 또 다른 한 가지는 항상 공통점이었는데, 기본 환경이 있다는 것은 훌륭하다는 것입니다.이제 테넌트를 이 환경으로 데려온다는 것은 무엇을 의미할까요?여기서 중요한 것은 어디에 소유할 수도 있고 없을 수도 있느냐에 따라 달라집니다.
테넌트별 구조죠, 그렇죠?모든 것이 통합되어 있고 테넌트당 수행하는 작업이 거의 없다면 이는 매우 간단한 프로세스일 수 있습니다.사일로화하거나 전용으로 설정한 경우
테넌트별 인프라, 즉 이 모델에서는 온보딩 중에 좀 더 색다른 작업을 수행해야 합니다.
무엇을 만들어야 하는지 알아내기 위한 것들
개별 테넌트마다?그래서 이 모델에는 테넌트도 있습니다.
프로비저닝 구조는 다음과 같습니다. “좋아요, 테넌트를 소개하려면 무슨 일이 일어나든 상관없어요.
이 기본 환경에서는 이 구조를 살펴보고 필요한 모든 것을 만들 수 있도록 오케스트레이션할 것입니다.
테넌트별로 생성되죠.”그래서, 여기가
우리는 라이브러리를 만들었고 이를 중심으로 도우미를 만들었습니다.또한 와이어링에 도움이 되는 모든 요소를 만들었습니다.
그리고 이벤트 프로세싱도 마찬가지죠.따라서 온보딩 이벤트를 보내셨다는 사실을 파악하여 모든 것을 트리거하겠습니다.
그런 일이 일어나야 합니다. 그리고 나서 여러분의 세부 사항을 알려드리죠.
앱 플레인이 나타나기 시작합니다.이제 스스로에게 이렇게 말할 수 있습니다. “직접 가서 그 모든 것을 쓰고 싶고, 나만의 기준 코드를 작성하고 싶고, 가서 제 코드가 어떻게 생겼으면 좋을지 알아보고 싶어요.
테넌트를 프로비전하는 걸 좋아해요.”해당 앱 플레인이 수락할 것입니다.
거기서 하고 싶은 건 뭐든, 그냥 활용하고 싶은 것만 남았어요
우리가 가지고 있는 몇 가지 비트와 그것을 좀 더 간단하게 만들기 위해 노력해야 하는 관례가 있나요?여기서는 전적으로 여러분이 선택하실 수 있습니다.하지만 이제 제가 이 모델을 가지고 있고 이 세트를 갖게 되면
자, 이제 이 모델에서는 풀스택 사일로 모델을 사용하고 있고 들어오는 모든 테넌트가 자체 전용 환경을 갖는다고 가정해 보겠습니다.프로비저닝 구조
여기 있는 테넌트의 경우 컨트롤 플레인과 온보딩을 통해 모든 것을 프로비저닝할 수 있습니다.
필요한 리소스, 모든 라우팅을 구성하고 해당 테넌트를 환경에 도입하는 데 필요한 모든 작업을 수행한 다음, 헹구고 반복하기만 하면 됩니다.이 슬라이드에서 얻을 수 있는 교훈은, 마치 이 앱 플레인에서도, 만들고 싶은 것을 만들러 갈 수 있는 열린 공간이더라도, 여전히 무엇을 살펴봐야 한다는 것입니다.
SBT는 여러분께 조금이나마 도움이 될 수 있도록 바로 사용할 수 있도록 도와드릴 수 있습니다.
그 분야로 한 발 앞서 나가겠습니다.이제 제가 하고 싶은 건 “좋아, 이거 가져가자.
기준을 도입하고 규정한다는 것이 무엇을 의미하는지에 대한 일종의 추상적인 생각입니다.
테넌트를 환경 및 프로비저닝하고 좀 더 구체적인 것으로 매핑하세요.”그럼 이제 무엇을 살펴보죠?
바로 사용할 수 있는 EKS 아키텍처는 구현될 때 영향을 미칩니다.
애플리케이션 플레인처럼 말이죠.그럼요, 당연히, 우리가 컨트롤 플레인을 사용한다면 여러분이 할 수 있는 일은 할 수 있을 겁니다.
컨트롤 플레인을 가동시키는 것에 대해서는 이미 말씀드린 바 있습니다.이제 프로비전을 말씀드리면
기본 환경은 기본적으로 “여기에 모든 리소스가 있습니다.
만들러 갈게요. 기본적으로
EKS 환경의 셸이 테넌트를 받기 시작할 준비가 됐어요.”이제 온보딩 이벤트가 발생하면 온보딩이 종료되고 이제 앞서 설명한 프로비저닝 스크립트가 실행됩니다. 이 경우에는 테넌트 네임스페이스를 생성하여 필요한 서비스를 활성화한 다음 이후의 각 테넌트가 이런 방식으로 도입됩니다. 그렇죠?모든 작업을 마치면 저는
오른쪽이 보이는데요, 기본적으로 모든 것을 지원하는 애플리케이션 플레인이죠.
컨트롤 플레인에서 발생하는 온보딩 및 온보딩 이벤트.따라서 자세히 살펴보면
여기에 사용된 CDK 코드, 우리가 여기서 실제로 해낸 것은 다음과 같습니다. “음, 컨트롤 플레인에서 잘 작동했던 모든 것들이
아마도 애플리케이션 플레인 쪽에서는 잘 작동할 것입니다.
이 문제도 마찬가지죠.”그럼 여기서 EKS를 만드는 것과 같은 표현을 모두 볼 수 있을 겁니다.
방금 보신 클러스터, 가서 모든 리소스를 만드세요
그걸 위해서는 그게 필요하죠.가서 앱 플레인을 만들어 보세요.
전체 앱 플레인 때문에 테넌트를 프로비저닝하고 설정하는 데 필요한 스택이 여기 있습니다.
스택은 개별 테넌트를 프로비전할 때 사용할 것입니다.그런 다음 설치하러 가세요.
이 모든 것을 위한 API, 가서 모든 비트를 구성하세요.그러니까 기본적으로 우리가 할 수 있는 건
이것은 여러분이 직접 작성할 수 있는 CDK 코드라는 겁니다. 하지만 저희는 그냥 가져와서 패키징해서 똑같은 방식으로 전달하고 있을 뿐입니다.
컨트롤 플레인 측에서 보신 코드를 전달해 드렸습니다.그러니까 일종의 의미가 있는 거죠.
한결같은 느낌이 들어요.그래서 실제로 제공되는 것은
이 EKS 아키텍처에서는?어떻게 하면 좋을까요?여기서 만들어진 게 뭐야?자세한 내용은 다루지 않겠지만, 기본적으로 우리가 사용하고 있는 것은
현재 사용 중인 테넌트용 하위 도메인
인그레스 컨트롤러, 네임스페이스를 설정하고 있습니다.
개별 테넌트의 경우, 여기서는 선택한 사항이며, 다음으로 설정했습니다.
라우팅이 제대로 작동하도록 말이죠.여기서도 설정 중인 것을 보실 수 있습니다. 각 네임스페이스는
모든 경로를 설정하세요.주문 테이블은 사일로화된 주문 테이블이므로 생성해야 합니다.
테넌트별 기준.그런 다음 제품 테이블이 생성되고 모든 테넌트가 공유합니다.여기에 있는 내용은 그다지 중요하지 않습니다. 음, 이제 프로비저닝을 작성한다는 것이 무엇을 의미할까요?
이 경험을 통해 여기서 수행해야 하는 테넌트별 프로비저닝을 수행할 수 있을까요?그리고 적어도 어떻게 할 수 있을까요?
그걸 기계화해서 직접 쓰면 이 상자 안에 있는 모든 것을 담을 수 있을까요?원하는 일을 하기 위해 SBT에서 어디에 들러야 하는지 알 수 있을 거예요.그럼 적어도 어떤 역할을 하는지에 대한 개념적 관점을 살펴보죠.
바로 지금이 제대로 작동하도록 하겠습니다.그래서 온보딩 요청을 받으면 앱 플레인에서 수신합니다.
온보딩 이벤트와 제가 말씀드린 앱 플레인 스택이 보이시죠. 우리는 이 구조를 만들었습니다.
시중에 나와 있는 이 앱 플레인 스택은
기본적으로 필요한 모든 것을 조율할 것입니다.
온보딩 중에 발생하는 모든 테넌트 리소스를 생성하세요.따라서 테넌트 라이프사이클 관리가 있습니다. 구성이라는 단어는
여기서 2초에 한 번씩 제 입에서 나오는데 그게 전부이기 때문이죠.
이런 것들이 맞죠?그리고 나서 불이 붙습니다.
AWS 코드 빌드 작업은 기본적으로 이렇게 말하죠. “이건 어려운 작업이야.
그냥 해줄게, 이벤트 받을게
제가 작업을 만들고 라이프사이클, 이것의 프로비저닝을 관리할 거예요. 아니요
프로비저닝이 무엇이든 상관 없습니다.”그리고 실행될 거예요
이 프로비저닝 스크립트는 전혀 특이하지 않습니다.그리고 정말,
당신이 방금 “내 앱 플레인을 만들고 싶어서”라고 하면 네 직업이
앱 플레인에 있는 어떤 것과도 완전히 다르게 생겼습니다.” 저는 여기서 멈추고 이렇게 말할 수 있습니다. “바로 여기에 가서 이 프로비저닝 스크립트를 위한 코드를 직접 작성해서 채워보겠습니다.
그리고 어떻게 해야 하는지 말씀해 주세요.하지만 적어도 이벤트 처리, 작업 생성, 스핀업, 이 작업의 실행, 컨트롤 플레인으로 보내는 메시지 등은 여전히 모두 해결될 것입니다.”하지만 이 경우에는 우리가 어떤 존재인지 알기 때문에
이 EKS 예제를 사용하여 다음과 같이 구성해 보겠습니다.
앞서 처리 과정에서 보신 하위 도메인
이들을 위한 라우팅은 이 경험의 일부로 테넌트 ID를 설정하고 해당 네임스페이스를 프로비저닝할 것입니다. 여기서 할 것입니다.
매니페스트를 비롯해 네임스페이스와 서비스를 설정하기 위해 해야 할 다른 모든 것들을 설정하고 프로비전을 할 것입니다.
서비스 계정.이 작업을 모두 끝내고 이 작업을 실행하고 나면 메시지를 보냅니다.
컨트롤 플레인으로 돌아가서 테넌트에 필요한 모든 리소스를 생성해야 합니다.이 모델에서 제게 좋은 소식은, 만약 여러분이 일을 그만두고 싶다면
이 중 일부를 변경하면 찾을 수 있고, 찾을 수 있고, 찾을 수 있고, 원하는 방법과 위치를 결정할 수 있을 정도로 세분화되어 있습니다.
경험을 바꿔보세요. 물론 이벤트가 다시 돌아오죠.이제 내부를 들여다 보면
CDK 뷰는 다음과 같이 볼 수 있습니다.
제가 말씀드렸던 이 직업이죠.우리가 이 일을 시작했는데 이 일은 결국 없어지고 말하죠. “저는 프로비저닝 실행을 관리하고 조율할 거예요.
이 인프라에 대해서요.”참고 자료를 보실 수 있을 겁니다.
다음은 이전 슬라이드에서 참조한 프로비저닝 스크립트입니다.그리고 프로비저닝 스크립트를 실행하면 근본적으로 종료되는데, 이것은 그 일부를 예로 들 수 있습니다.
무슨 일이 벌어지고 있는지 몇 가지 말이에요.이 파일을 상상하실 수 있을 겁니다.
훨씬 더 큰 파일이지만, 여기에서 환경에 인증이 설정되고 Cognito에서 설정이 설정되는 것을 볼 수 있습니다.
인증 및 그 중 일부.여기에서도 매니페스트를 볼 수 있습니다. EKS에 있고 매니페스트를 사용하고 있기 때문입니다.
서비스와 서비스가 차지하는 공간, 그리고 어떻게 스핀될 것인지 설명하기 위해서입니다. 여기에는 설정 방법도 포함될 수 있습니다.
라우팅과 그 비트들.그리고 세팅도 하고 있어요
서비스 계정을 만드세요. 설정해야 하고
서비스 계정을 경험의 일부로 구성하세요.자, 이제 코드를 작성하시면 됩니다.
매일 글을 쓰세요. 솔직히 말해서, SBT를 전혀 보지 못했더라도 여전히 몇 개씩 써야 할 거예요
이 코드의 버전입니다.하지만 가장 이상적인 방법은 패키징이 되어 있는 것인데, 이 규칙을 통해 사용자가 직접 어떤 방법을 사용해서 커스터마이징하거나 구성하거나 변경할 수 있는지 좀 더 빠르게 파악할 수 있습니다.
요구 사항을 충족하기 위한 것입니다.여기서 앱 플레인에서 놓칠 수 있는 또 다른 부분은, 다시 말씀드리지만, 양방향이라는 것입니다.
이것은 컨트롤 간의 일종의 통합입니다.
플레인 및 앱 플레인.앱 플레인에서 이벤트를 다시 보내야 합니다.
온보딩의 성공 또는 실패 여부에 관계없이 컨트롤 플레인에 전달되는 더 많은 청구 단위와 결제 정보가 도움이 됩니다.
청구 구현, 청구서 생성 방법 파악, 다시 전송된 계량 데이터, 로그 데이터 등이 잠재적으로
다시 여기로 보내드리자면, 메트릭입니다.그래서 저희는 여러분이 쉽게 통합할 수 있도록 EventBridge를 통해 이러한 메시지를 더 쉽게 게시하고 전송할 수 있도록 이 쪽에서 할 수 있는 일을 하고 있습니다.
컨트롤 플레인을 사용해서 말이죠.그리고 만약 당신이 그 중 하나를 사용한다면
Moesif와 같은 기본 결제 서비스
앞서 보여드린 것처럼 해당 이벤트를 자동으로 인제스트하고 적용하기만 하면 됩니다.
어서 가세요. 청구서가 제대로 작동하잖아요.그렇다면 이 경험을 어떻게 맞춤화할 수 있을까요?그게 실제로 어떤 역할을 할까요?
이걸 커스터마이징한다는 뜻인가요?아닌 것 같은 느낌이 들어요
여기 클래식 확장 모델이 라이브러리인데
비트를 확장으로 추가하기만 하면 됩니다. 마치 여기의 것과 비슷합니다.
여러 코드의 전체 표면적, 어떤 곳에서는
인터페이스, 다른 곳을 통해 확장할 수 있습니다.
실제로 들러서 확장해야 할 거예요
그리고 코드 수정.전체적으로 볼 때, 우리는 도구가 아니라 도구일 뿐입니다.
일종의 제품 사고방식이죠.SBT의 핵심적인 요소들이 있습니다. SBT를 계속 사용하고 새로운 기능을 따라가고 싶다면 바로 여기에 물어봐야 합니다.
여러분들이 궁금해하는 것은, 음, 제가 만약 방향을 틀린다면
그들이 의도한 게 뭐지, 내가 이전 버전과 호환되지 않겠어?아마 그럴지도 몰라요
여기서 가장 큰 미해결 질문이죠.하지만 제가 하고 싶다고 해봅시다.
저만의 컨트롤 플레인을 만들고 결정했죠.
앞서 말씀드렸는데, 저는 제 소유의 테넌트를 갖고 싶어요.
관리 서비스가 여기 있어요.자, 이제 보시게 되실 겁니다.
기본 컨트롤 플레인 대신 저만의 컨트롤 플레인인 컨트롤 플레인이 생겼습니다.
박스에서 꺼내면 됩니다.그리고 제가 말할게, 음, 한 가지
여기서 건설하고 싶은건 건설하고 싶은데요
테넌트 관리 서비스를 제공하지만 기본 테넌트 관리 서비스를 구축하는 대신 내 서비스를 구성해 보겠습니다.
테넌트 관리 서비스.다음에 대해서도 이야기했습니다.
이것을 변형해서 구현할 필요 없이 할 수 있습니다.
자체 테넌트 서비스를 자체 테넌트 관리 구조로 사용하면 기존 테넌트 관리 구조에서 파생되어 속성만 재정의하거나 속성만 재정의할 수도 있습니다.
바꾸고 싶은 부분은 어떤 것일지 여부에 따라 달라질 수 있습니다.
도매로 대체하거나 오늘날의 작동 방식을 수정한 것이죠.여기서 볼 수 있는 또 다른 것은 이미 임차인이 있다는 것입니다.
구성 서비스, 하지만 제가 추가할게요
이 컨트롤 플레인을 가동하는 과정에서 테넌트 구성 서비스의 일부 동작을 변경하세요.하지만 다음으로 다음으로 넘어가겠습니다.
아, 이런, 너무 많이 갔어요.여기 있는 사용자 관리 서비스, 저는 그냥 outof 를 사용하고 있어요
박스에 있는 것은, 이미 잘 작동한다고 생각하는데, 어떻게 사용하는지는 괜찮습니다.
사용자를 관리하고 생성합니다.몇 가지 더 많은 것들이 있습니다.
이 상자 안에 있어야 하겠지만 한 슬라이드에 모두 담을 수는 없습니다.하지만 제 요점은, 저는
이제 제가 코드를 가져올 위치를 고르고 선택해서 여기에 저만의 구조를 만들었죠. 저만의 테넌트 관리 서비스를 만들었죠.
이미 존재하는 다른 구조들의 동작은 다음과 같습니다.
구성을 바꾸고, 어떤 경우에는 그냥 “아니요, 일부는 그냥 작동합니다.
그냥 있는 그대로도 괜찮아요.” 제가 그 모든 것을 구성합니다.
제 컨트롤 플레인 스택에 넣었다가 이제 배포할 때 그런 맛을 느낄 수 있어요.
스택을 컨트롤 플레인으로 사용하세요.다른 건 여기 있어요
앱 플레인 쪽에서는 이 모든 이야기를 나눴습니다.
여러분이 쉽게 사용할 수 있도록 이러한 구조를 어떻게 만들었는지, 이 모든 중요한 부분들에 대해 말씀드리죠.
가져오는 것이 무엇을 의미하는지 전체 라이프 사이클에 대해 알아보는 것
앱 플레인에 생명을 불어넣고 컨트롤 플레인과 통합하세요.글쎄요, 이들 각각은
이 퍼즐의 조각들은 한 점을 나타냅니다.
직접 방문하여 교체하기로 결정할 수 있습니다.
코드를 작성하거나 코드를 변경하거나, 알다시피, 저는 쉽게 할 수 있습니다.
사람들이 이렇게 말하는 걸 보세요. “저는 서버리스 SaaS를 가지고 있어요.
즉시 구현하거나 EKS 솔루션을 즉시 사용할 수 있지만 이런 차원은 마음에 들지 않습니다.
구현 방식이나 내 앱에 다른 동작이 필요한지에 대해 설명하면 됩니다. 예를 들어 프로비저닝 스크립트에서 무언가를 변경하고 원하는 동작을 얻을 수 있어야 합니다.또 다른 것은 단지 확장하는 것입니다.
SBT 환경 맞죠?그래서 확장에 대해 생각해 볼 수 있는 방법이 몇 가지 있습니다. 하나는 바로 이러한 인터페이스를 사용하는 것입니다.그냥 소개를 하고 싶으시다면
직접 청구서를 작성하거나 직접 구성해 보고 싶으신가요?
자체 미터링 구조는 전적으로 자유롭게 할 수 있습니다.관심이 있다면
자체 확장성, 자체 인터페이스를 도입해 주실 수 있나요?그렇게 할 가능성은 높지 않지만, 확실히 그렇습니다.
자신만의 커스터마이징을 도입할 수 있는 또 다른 지점이나 영역이죠.그럼 이 커스터마이징이 맞을까요?잘 모르겠지만 가서 다음과 같이 작성해 주실 수 있습니다.
자체 컨트롤 플레인 맞죠?교체할 거라고 말할 수도 있겠죠
컨트롤 플레인 전체, 내가 다 써볼게, 내가 만들 거야
컨테이너화된 버전이고 제가 원하는 컨트롤 플레인인 다른 솔루션을 사용하지만 여전히 준수할 거예요
통합을 위해 존재하는 인터페이스 모델을 사용해서
애플리케이션 플레인과 함께 다음 중 하나를 사용하겠습니다.
기존 애플리케이션 플레인.저한테는 그게 아직도
어떤 형태로든 확장이 가능하다는 점에서 여전히
컨트롤 플레인과 앱 플레인 간의 인터페이스를 활용하여 컨트롤 플레인을 적합하게 만드세요.
전체 경험에 반영합니다.그리고 여기 있는 다른 하나는 그냥 직접 가져오는 거예요
앱 플레인이 여기에 있죠?제 생각에 대부분의 사람들은 우리가 시작점으로 제공하는 기존 앱 플레인 중 하나를 사용자 정의하거나 그냥 말할 것입니다.
처음부터 직접 작성하세요.하지만 우리가 보게 될 것은
여기, 우리 팀에서도 볼 수 있을까요?
SBT에 점점 더 많은 앱 플레인이 추가되고 있습니다. 추가할 수 있으니까요.
이 모델 덕분에 더 빠르게 많은 앱 플레인이 생겨났습니다.
지금까지 테넌트별 계정에 대해 말씀드렸듯이
테넌트당 영원히, 테넌트당 VPC는
계속 얘기해 왔지만, 실제로 찾아볼 만한 좋은 예시는 없습니다.자, 이제 앱 플레인 안에서 그 모델을 구현한 다음 가져오면
이미 존재하는 컨트롤 플레인의 다른 모든 장점들을 말씀드릴 수 있는 것은
코드를 많이 작성하지 않아도 되는 엔드-투-엔드 솔루션.사실 제가 그랬던 것 같아요.
월요일에 있었던 강연에서는 셀 기반 아키텍처와 이러한 새로운 용도에 대해서도 다루었습니다.
셀 기반 아키텍처에 대해서요.그게 뭔지는 파헤치지 않겠습니다.
여긴 정말 큰 의미가 있긴 하지만 확실히 알 수 있어요
여기서는 셀 기반 아키텍처를 사용하는 앱 플레인을 만들고 있습니다.그리고 마지막으로 말씀드리자면, 어디에나 있는 SaaS, 이게 바로 이 아이디어인데요, 원격이 있으면 어떨까요?
앱 플레인에 리소스가 있나요?앱 플레인이 대부분 SaaS 공급업체 계정에서 실행되는데 스토리지가 실행되어야 한다고 가정해 보겠습니다.
고객 계정에서 말이죠.우리는 더 많은 것을 보고 있고
이러한 현상은 특히 제너레이티브 AI 분야에서 더 많이 나타나고 있습니다.뭐, 그래도 갈 수 있겠네요
예제를 만들어 보거나 구현이 가능한 저만의 앱 플레인을 만들어 보세요.
제 앱의 일부가 있다는 것은 무엇을 의미할까요?
내가 제어하고 그 일부인 앱 플레인에서 실행
원격으로 실행되는 리소스와 상호 작용하고 있나요?그러니까 이건 문제가 아니에요. SBT 없이도 이 모든 걸 할 수 있었죠.하지만 가장 중요한 이야기는 이 새 모델들을 한 입 베어 물고 전체 표면을 다시 만들지 않고도 이상적으로는 새 모델을 시험해 볼 수 있다는 것입니다.
SaaS 환경에 대해서요.공유하겠다고 말씀드렸는데
이 URL을 여러분 모두와 공유해 주세요.관심이 있으시다면
직접 가서 살펴보니까 정말 관심이 많아요.
아시다시피 이 제품에 대한 피드백을 받을 수 있는 데에는 수많은 파트너가 있었습니다.
지금 이 제품을 개발해 나가고 있는 사람들, 그리고 비즈니스를 위해 현대화와 혁신을 하고 있는 사람들, 이 기술을 파악하고 사용하고 있는 사람들
그걸 출발점으로 삼았죠.그리고 제 생각엔 그게 미래라고 생각해요.
우리가 어떻게, 어디서 하느냐에 따라 크게 달라집니다.
확장성을 높일 수 있는 기회가 더 많아질 것으로 보입니다.하지만 너무 복잡하게 만들어서 특정 환경에 맞는 일을 할 수 없을 정도로 복잡하게 만들지는 않으면서 항상 그렇게 할 것입니다.여기서 몇 가지 요점을 말씀드리자면, 여기서 말씀드린 내용을 보면 이와 같은 것은 없다는 것을 아주 분명하게 알 수 있을 것 같습니다.
SBT 사용 방법에 대한 여정.그렇지 않아요, 오, 모두가 SBT를 받고, 모두가 가는 거고
컨트롤 플레인을 설치하면 모두가 선택하고 선택합니다.
앱 플레인을 설치하고, 구현할 때마다 필요한 라이브러리를 가져오세요. 그게 모두의 여정이 될 거예요.확실히 여기서 중요한 것은 컨트롤 플레인을 원하거나 앱 플레인만 원하거나, 자체 컨트롤 플레인을 가져오거나, 특정 라이브러리만 갖고 싶다는 것입니다.그게 고르는 거고
이 모든 것을 골라서 물건을 잡을 수 있는 옵션도 있습니다.
그리고 필요할 때 사용하세요. 정말 가치 있는 일이라고 생각해요.솔직히 말해서 많은 사람들이 “컨트롤 플레인을 좀 주시겠어요?” 라고 말했던 것 같아요.그리고 어떤 분들께는 이게 가장 좋은 출발점이 될 것 같아요. 컨트롤 플레인을 들고 “이게 컨트롤 플레인의 모습이야”의 기초로 삼을 거예요. 많은 분들과 이야기를 나눴으니까요.
조직에서 “같은 팀이 컨트롤 플레인과 앱 플레인을 구축하더라도 컨트롤 플레인을 별도의 제품으로 취급해야 합니다”라고 말하는 것에 대해 말하는데, 무엇을 만들지 결정하는 것에는 중요한 차이점이 있습니다.
컨트롤 플레인에서 일어나는 일, 앱 플레인에서 무슨 일이 일어나고 있는지, 그리고 이러한 측면에서는 어떻게 돌아가는지
솔루션의 라이프사이클 동안 수정 및 업데이트됩니다.그리고 이 둘 사이에 경계를 두는 것은 결국 많은 사람들에게 매우 유용할 것입니다.
함께 일하는 조직들.그래서 제가 보기에도 불구하고
오늘날 볼 수 있는 컨트롤과 앱 플레인 사이의 인터페이스는 결국 이러한 행동을 유도하고 다음과 같은 결과를 가져옵니다.
이런 것들은 서로 다른 부분이라고 생각하세요.이미 죽도록 때려버렸던 그 비트는
꽤 명확하다고 생각해요. CDK 경험을 통해 보시고 길을 알 수 있기를 바랍니다.
지금 들어오셨는데 이건 에디터 기반 경험이고 제가 사용하고 있는 구조가 뭔지 생각해 보셔야 합니다.구문을 어떻게 구성할 수 있나요?그 모든 움직이는 부분들이 바로 SBT의 힘이자 가치입니다.그리고 우리가 성숙해감에 따라 점점 더 많은 것을 보게 될 것입니다.
CLI로 인해 상황이 점점 줄어들고 있습니다.
일종의 UI를 만들어 보는 것에 대해
이 모든 걸 다 보고 설치도 끝내고 설치도 끝낸 제품인 것처럼 다루세요
포인트 앤 클릭 경험.CDK가 마음에 들지 않으면 아마도 마음에 들지 않을 것입니다.
엄청나게 많은 SaaS 빌더 툴킷.물론, 여러분도 글을 쓸 수 있을 거라고 생각하시겠죠?
테라폼 버전은 정말 멋질 거예요. 그냥 테라폼 버전과 CDK 버전, 다른 버전을 돌리는 거죠. 꽤 큰 발전이긴 하지만, 그건 아니에요.
다른 방법보다 낫습니다. 이런 접근법 중 하나와 그 많은 부분에 모두 몰두해야 했기 때문입니다.
저에게 SBT의 장점은 CDK로 할 수 있는 일에 묻혀 있습니다.정말 좋아할 것 같아요.
우리가 거의 별개의 CDK 라이브러리로서 존재한다는 걸 보면, 제 생각엔
SBT가 무엇인지는 아주 많지만 그것보다 더 많은 것이 있습니다. 왜냐하면 여러분은 아직도 알아야 할 중요한 것이 무엇일까요?
광범위한 SaaS 애플리케이션으로 달성하고자 하는 것이 있나요?그리고 앞서 말씀드린 것처럼 애플리케이션에 가장 적합한 구성 요소를 골라서 선택하세요.그리고 마지막으로
이걸 키우게 도와줘요, 어디에 있는지 알아낼 수 있게 도와주세요
가봐야겠네요, 피드백을 주세요.원하시면 저에게 이메일을 보내주세요. 제 이메일 주소는 마지막에 있어요.마음대로 하세요. 하지만 저는 나가서 실험해 볼게요.SBT를 위한 워크숍이 있었어요.
올해 re:Invent에도 참석했으니, 원하시면 그냥 가서 정말 간단한 실습을 해보시면 됩니다.
컨트롤 플레인 설정, 배포 및 생성
그리고 이 모든 단계를 수행하죠.그리고 보여주지 않을게요
거의 다 있는 것 같으니까 이 모든 게
지금 일어난 일이에요.(웃음) 그럼 여기서 마무리하겠습니다.와줘서 정말 고마워요. 서둘러 통과했어요.
이게 코드 비트는 그냥 눈이 피로해지는 걸 원하지 않았기 때문이에요
좋아요를 눌러보는 순간, 전체 목록을 정리해 보세요.
화면에 있는 코드.하지만 파헤쳐 보면 좋겠죠.
여기서 잠깐, 무슨 일이 벌어지고 있는지 알려드리죠.
이 내용을 들여다보면 우리가 이걸 통해 달성하고자 하는 것이 무엇인지, 그리고 집에 돌아와서 이걸 어떻게 활용할 수 있을지 더 잘 알 수 있습니다.
그리고 무슨 일이 벌어지는지 보세요.그래서 그것 말고는 나머지는 정말 좋겠어요
당신의 re:Invent는 정말 멋져요. 보여줘서 고마워요
오늘도 좋은 하루 보내세요.(관중들의 박수 갈채)