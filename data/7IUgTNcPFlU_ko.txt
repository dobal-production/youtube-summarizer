- Camada Zero라는 극도의 복원력을 갖춘 아키텍처 프레임워크를 시청해 주셔서 감사합니다.카마다 제로는 제로입니다.
이름은 포르투갈어로 되어 있습니다.그래서 오늘은 커뮤니케이션을 단순화하기 위해 C Zero라는 별명을 사용하겠습니다.그래서 C Zero라고 말할 때마다 우리는
우리의 프레임워크를 의미하죠.시작하기 전에 제가 여러분께 드릴 몇 가지 질문에 대해 친절하게 답변해 주시길 부탁드리며, 손을 들어 (불명료하게) 답변해 드리겠습니다.자, 여기 계신 분 중에 선교부를 건설하고 운영해 보신 분이 계신 분이 계신가요?
프로덕션 환경에서 중요한 애플리케이션을 사용하시나요?네, 그래서 저희도 그렇습니다.그 동안 당신들 중 누구한테서
실패 상황은 거의 또는 전혀 없었습니다.
임무 수행에 실패했을 때 실패를 피할 수 있는 통제
크리티컬 애플리케이션?네.그렇다면 레질리언스가 핵심 주제일까요?
제 생각엔 여러분에게 맞는 것 같은데요, 그렇죠?그러니까 우리를 위한 거예요.이것이 바로 C Zero가 프레임워크일 뿐만 아니라 프레임워크의 컬렉션이기도 한 이유입니다.
기술적 제품 및 원칙, 특히 우리가 거래할 때
합리적인 양의 고객 요청을 처리합니다.Unibanco에는 요즘에는 더 많은 제품이 있습니다.
6,500만 명 이상의 고객 중 2천만 명
디지털 전용 고객입니다.해당 고객은
우리가 비즈니스 서비스라고 부르는 서비스를 제공합니다.비즈니스 서비스로서 다음을 수행할 수 있습니다.
예를 들어 은행 계좌 개설을 이해하면
전자 결제 실행 또는 보험 패키지 계약.당사는 4,000건 이상의 보험을 보유하고 있습니다.
이러한 비즈니스 서비스.그리고 가장 큰 서비스 중 하나로서
라틴 아메리카의 금융 기관에는 현재 10만 명의 직원이 근무하고 있으며, 그 중 14,000명이 근무하고 있습니다.
저랑 여기 있는 제 친구처럼 기술에 특화된 사람들이에요.우리는 이제 98년이 되었습니다. 거의 100주년이 된 조직이고 세월이 흐르면
우리는 습관을 바꾸는 것을 인지하고 있습니다.
고객의 기대, 특히 지난 한 해
코로나바이러스 팬데믹 기간 동안 집을 떠나 오프라인 매장에 갈 수 없는 힘든 시기를 겪었던 시기
그리고 우리 물건도 사세요.온라인으로 사야 했어요.그리고 우리의 방식이 바뀌었죠.
고객들은 우리 제품과 상호작용하고 있습니다.따라서 지금은 더 이상 해당 매장의 영업 시간에 제한되지 않습니다.그들은 언제든지 무엇이든 살 수 있습니다.그리고 우리에겐 변화가 필요했습니다.
우리 조직은 문화적으로, 특히 기술이 비즈니스를 지원할 수 있는 것이 아니라는 점을 깨닫고 있습니다.그렇지 않다면 그것이 우리 비즈니스의 핵심입니다.그리고 (불명료한) 조직으로서 우리에겐 여전히 몇 가지 획일체가 있습니다.
온프레미스에서 운영하려면 다음과 같이 설립해야 합니다.
현대화 전략을 통해 고객의 기대에 부응할 수 있습니다.그래서 우리는 다음과 같이 시작했습니다.
AWS와 10년 동안 파트너십을 맺고 주변 장치 애플리케이션부터 시작하여 이 구조화된 로드맵을 구축했습니다. 이를 통해 우리는 그들과 함께 개발 및 배포에 대해 배울 수 있었습니다.
단일 AZ 배포의 이러한 애플리케이션은 이후에 다중 AZ 배포로 발전하는 식으로 최대 무효 지역까지 이어집니다.
그리고 AZ를 함께 묶어보세요.그 컴파운딩
애플리케이션을 마이크로서비스로 아키텍처링하기 때문에
속도를 높일 수 있습니다.우리는 이러한 비즈니스를 통해 고객에게 새로운 기능을 제공합니다.
말씀드린 서비스.2016년에 우리는 프라이빗 클라우드를 사용하여 클라우드에서 실험을 시작했습니다.그리고 2020년에 우리는 의무를 정의했습니다.
퍼블릭 클라우드 퍼스트가 되겠습니다.즉, 모든 것이
Itau의 새로운 애플리케이션은 클라우드에서 실행해야 합니다.2021년에는 클라우드 마이그레이션 속도를 가속화할 예정입니다.클라우드 마이그레이션이라고 하면
호스팅에 대해서는 언급하지 않겠습니다. 아키텍처 설계와
애플리케이션을 재구축하세요.올해 말까지 우리는 45% 의 소유권을 갖게 될 것입니다.
AWS에서 실행되는 애플리케이션.그리고 다음 연말까지
내년에는 60% 가 될 것입니다.그 세월 내내
특히 지난 2년 동안 우리는 많은 것을 배웠습니다.그런 상황 중 하나에서
2020년 12월에 한 데이터 센터가 있는 AWS 지역 중 남미 동부에서 상황 격차가 발생했습니다.
한 가용 영역 중 에어컨 문제가 발생했습니다.그런 상황에서는
데이터 센터가 과열되어 폐쇄되었습니다.
일부 랙이 자동으로 실행됩니다.따라서 일부 애플리케이션이 노출되었습니다.
로드 밸런서를 사용하는 엔드포인트는 실패할 수 있었습니다.
그 고장난 AZ에서 말이에요.정상적인 상황이에요.AZ가 여러 개 있는 클라우드에서는 예상할 수 있는 일입니다.
그 중 하나가 고장날 수도 있습니다.하지만 API가 있던 다른 일부 응용 프로그램에서는
게이트웨이를 진입 지점으로 사용했고, 오류율이 증가하면서 AZ가 풀에서 제거되었고 (불분명한) 고객에게는 더 이상 요청이 처리되지 않았습니다.하지만 오류율이 감소하자 다시 시도했습니다.
고객의 요청에 따라 에어 호스를 제공하는 것은 반대합니다.그래서 그 상황에서는 이러한 특정 애플리케이션을 제어할 수 없었습니다.현존하는 브라질 시장을 고려하면
시장 통합, 소수의 플레이어만이 프로세스를 진행합니다.
국내 전체 거래와 Itau가 가장 큰 거래이므로 전체 거래의 30% 를 처리합니다.
국내에서는 매일.그리고 2020년 12월에 있었던 그 상황은 우리의 사명 중 하나에 큰 타격을 입혔습니다.
핵심 애플리케이션은 대부분의 고객 14% 에 영향을 미칩니다.우리에게 미치는 영향은 감당할 수 없는 수준입니다. 왜냐하면 우리 애플리케이션의 경우
당사는 고객 중 10% 이상이 미치는 영향이 위험도가 높은 것으로 간주합니다.우리는 고객에게 영향을 미치고 있으며, 경우에 따라서는 규제에 영향을 미치기도 합니다.(불명료하게) 저는 브라질 전자 상거래 시장이 2025년까지 두 배로 성장할 것이라는 보고서를 작성했습니다.상상하실 수 있을까요?
2025년 12월에 상황이 일어날 수도 있나요?영향을 받았을 거예요
훨씬 더 많은 고객.그렇기 때문에 지금부터 미션 크리티컬 애플리케이션에 이름을 붙일 예정입니다.
100% 가동 시간이 절실히 요구되는 C Zero 애플리케이션으로서 말이죠.따라서 가동 및 운영을 보장할 수 있습니다.그런 점을 염두에 두고 제가 할게요.
여기서 제 친구한테 연락해서 더 자세한 내용을 설명해 주세요. - 고마워요, 루치아노.안녕하세요, 제 이름은 호르헤입니다.저는 이타우에서 디스팅션 엔지니어로 일하고 있습니다. 오늘 여러분께 보여드릴 수 있는 무언가를 소개해 드리려고 합니다. 적어도 다음과 같은 측면에서는 여러분의 삶을 영원히 되돌릴 수 없을 정도로 변화시킬 것으로 기대됩니다.
회복력에 대해 생각해 보세요.제 친구 루치아노가 말했듯, 우리가 브라질에 있다는 컨텍스트는 우리의 일부 응용 분야에서 매우 중요합니다.물론 모든 상황에 맞는 것은 아닙니다.대부분의 애플리케이션은 대다수라고 말할 수 있습니다.
대부분의 애플리케이션은 표준 규격을 준수할 수 있습니다.
(불분명한) AZ 솔루션과 (불명확한) 지역 솔루션에 있는 브라질의 아키텍처입니다.하지만 이러한 응용 분야 중 일부는
현대화의 특징, 이런 유형의 애플리케이션
매우 중요합니다.그리고 이러한 유형의 애플리케이션을 위해 이 프레임워크를 설계합니다.단지 하나의 응용 프로그램이 아니라 수백 개의 응용 프로그램이 있는 것과 같지만 수천 개의 응용 프로그램이 있는 것은 아닙니다.그러니까 기본적으로 우리가 가지고 있는 응용 프로그램의 4%, 4~ 5% 정도입니다.처음에는 레질리언스를 달성하기 위해 플랫폼 구축을 고려하기 시작했습니다.자, 이제 극한으로 발전해 봅시다.
복원력이 뛰어난 플랫폼.모든 애플리케이션을 넣어 봅시다.
이 플랫폼 위에 있으면 괜찮을 거예요하지만 우리가 시작했을 때
응용 프로그램을 생각해 보면 응용 프로그램에는 많은 것이 있습니다.
요구 사항이 서로 다릅니다.그래서 몇 가지 응용 프로그램이 있습니다.
등급이 낮은 애플리케이션이고, 일부 애플리케이션은
높은 가치를 지닌 애플리케이션.그래서 엄청 힘들 거예요
모든 애플리케이션의 모든 요구 사항을 충족할 수 있는 플랫폼을 갖추기 위해서요.그리고 나서 시작했습니다.
레질리언스에 대한 전략을 재고해보죠.그러다가 생각해낸 게
C 제로, 카마다 제로.그렇다면 C Zero는 프레임워크입니다.극도의 복원력에 대한 우리의 접근 방식은 단순한 아키텍처 접근 방식이 아니라 엔지니어링 측면, 운영 측면까지 아우르는 것입니다. 모든 것의 결합을 통해 얻을 수 있는 것은
결론, 극한의 탄력성, 안정성, 그리고 높은
우리가 원하는 가용성.요약하자면 C Zero는 원칙상 우리가 생각하는 프레임워크이고 앞으로 보여드릴 프레임워크입니다.
이 세 가지 기둥의 원칙을 모두 보여드리겠습니다.기둥당 하나의 원칙에 대해 자세히 알아보겠습니다. 물론 그 이상입니다.
다른 쪽에 대해서는 제쳐두고 대화를 나눌 수 있어서 기쁩니다.
원하신다면 원칙을 말씀해 주세요.하지만 이 모든 것을 명심하세요.
우리가 설계한 원칙은 단순한 원칙이 아닙니다.우리는 이 원칙을 극도의 회복탄력성에 대한 사고방식으로 생각해 냈습니다.그리고 오늘 우리의 사명은 이러한 사고방식을 여러분께 설명해 드리는 것입니다.루치아노가 말했듯이,
우리가 통제권을 갖고 싶어요.실패는 일어날 수 있기 때문에 맞서고 싶지는 않지만, 우리는 실패를 통제할 수 있기를 원합니다.
그런 실패에서 벗어나세요.MATTR을 최소화하고
결국 고객에게 미치는 영향을 최소화합니다.알겠어요?한 번 살펴볼까요?
아키텍처 원칙부터 시작하겠습니다.이것이 12. 12가지 아키텍처 원칙입니다.첫 번째 항목인 스케일 유닛을 살펴보겠습니다.
기반 아키텍처.누구에 대해 들어 보신 적이 있으신가요?
스케일 유닛 접근법?없음?알겠어요.그럼 도착할게요.왜, 어떻게 이 아키텍처에 접근하는지 설명해 드리겠습니다. 사실
셀 기반 아키텍처.하지만 세포라고 불리는 대신
우리는 그것들을 스케일 유닛이라고 부릅니다.이 개념을 설명해 보죠.
스케일 유닛은 조금 제쳐두고 C Zero 아키텍처를 셀 기반 아키텍처로 다루겠습니다.셀 기반 아키텍처 설계에 대한 우리의 접근 방식이 무엇인지 설명해 드리겠습니다.그리고 마지막에는 스케일 유닛 개념을 다시 설명하겠습니다.이 모든 구성 요소에 대해 자세히 살펴보겠습니다.이건 아키텍처가 아니야, 알겠지?이건 아키텍처의 원형이에요.각 애플리케이션은
우리는 이 슬라이드에 있는 모든 내용을 염두에 두고 점수를 디자인합니다.먼저 세포부터 살펴보죠.세포는 무엇일까요?셀이 바로 애플리케이션입니다.따라서 응용 프로그램은 셀 내부에 존재합니다.애플리케이션은 독립적이어야 합니다.셀프 컨테인드란 무슨 뜻인가요?
모든 것이 있고, 컴퓨팅 계층이 있고, 데이터베이스 계층이 있고,
메시지 계층은 우리가 전달해야 할 모든 것을 갖추고 있습니다.그 목적은
응용 프로그램은 이 셀에 있습니다.예를 들어보죠.만약 이 애플리케이션이
API 기반 애플리케이션이며 이에 대해 공개하겠습니다.
쿠버네티스 클러스터에서 실행되는 일부 서비스를 통한 API로는 하나가 있을 것입니다.
이 설계에서는 셀당 쿠버네티스 클러스터를 사용합니다.이 애플리케이션에 DynamoDB 테이블이 있는 경우 DynamoDB는 한 개만 남게 됩니다.
셀당 테이블 수 등.이게 이 세포의 아이디어죠.이 세포는 분리되어야 합니다.
다른 세포와 함께 말이죠.따라서 어떤 세포에 장애가 생기면 그 세포에만 영향을 미치게 되는 거죠.다른 모든 세포에는 영향을 주지 않아야 합니다.세포 간에 종속성이 있다면 느슨하게 달라야 합니다.
(불명료) 순서대로.건강하면 괜찮고, 실패하면 안 돼요.
다른 세포에도 영향을 미칩니다.이 경우 셀 1A를 다음과 같이 표현했습니다.
녹색은 건강한 상태라는 뜻입니다.그러니까 이 세포는 건강해요.하지만 응용 프로그램을 통해 우리가 볼 수 있는 것은 세포 중 일부가 고장나는 것입니다. 이 세포는 그렇지 않을 것처럼요.
저는 빨간색으로 표시했는데, 실패했다는 뜻이죠.그러니까 세포 1A는 건강한 거죠, 세포
1B는 실패했어요. 괜찮아요.그리고 괜찮을 거예요
예를 들어 해당 API의 트래픽을 라우팅할 수 있다면
단방향으로 셀로.그래서 우리가 라우팅하면
단방향 휴대폰으로 트래픽을 보내면 고객이 볼 수 없습니다.
셀 1B에서 발생한 장애.이것이 우리가 세포에 접근하는 방법입니다.여기까진 괜찮죠?다른 곳으로 이동해 볼까요?
이 아키텍처에서의 컨셉은 샤드입니다.우리에게 필요한 샤드는
시스템의 파티션.이건 정말 물리적이에요
예를 들어 일부 고객은 하나의 샤드에, 다른 고객은 다른 샤드에 배치하는 시스템의 파티션입니다.따라서 애플리케이션당 애플리케이션은
샤드를 설계합니다.그래서 우리는 어떻게 하면 파편을 배치해서 복원력을 제공할 수 있을지 생각해봅시다.한 가지 예를 들어보죠.
우리가 설계하고 있는 애플리케이션 중 하나는
복원력 향상을 위한 샤드.중요한 API가 하나 있습니다.
이것이 우리의 인출 API입니다.이 출금 API는
모든 ATM에서 사용됩니다.브라질에 가면
한 지점에 가면 ATM이 다섯 개 보이는데 고객이 현금을 인출하고 싶어하면 이 API로 갈 수 있습니다.슈퍼마켓에 가는데 파트너 ATM이 두 개 있는데 고객이 슈퍼마켓에서 현금을 인출하려고 하면 동일한 API에 도달할 것입니다.그래서 저희가 돈을 인출할 수 있는 유일한 승인 창구인 셈이죠.따라서 이 API는 매우 중요합니다.우리는 갖고 싶지 않아요.
이 시스템이 실패하는 이유는 필요한 경우 고객이 돈을 받으러 가는 것을 피하고 싶지 않기 때문입니다.그래서 우리는 샤드에 접근합니다.
생각해 보면 ATM과 각 특정 위치의 터미널을 서로 다른 샤드로 분산시킬 수 있습니다.같은 지점의 예에서 ATM이 다섯 개라면 각 ATM은
하나의 다른 샤드로 라우팅됩니다.즉, 샤드 문제, 전체 공유 문제가 발생하면 해당 위치의 ATM 하나만 다운되고 고객은
필요 없이 해당 장소에서 돈을 인출할 수 있습니다.
다음 사항을 알아내려고 다른 곳으로 이사하는 경우
다른 ATM이 작동 중인지 아닌지이 도표는 우리가 다른 것을 가지고 있다는 것도 보여줍니다.
이 사례의 샤드 디자인입니다.따라서 샤드는 서로 다를 수 있습니다.
세포를 이용한 디자인.자, 이 샤드의 두 번째 부분은 셀 2B와 셀 2C입니다.녹색은 건강하다는 뜻이고
셀 2C의 경우 흰색은 활성 상태가 아님을 의미합니다.
아직 해당 샤드에 대해서는 아직 활성화되지 않았거나 활성화되지 않은 디자인입니다.우리가 이 일을 하는 이유는
정적 안정성을 확보하기 위해서죠.장애가 발생할 경우, 수신되지 않는 요청, 즉 외부에서 오는 요청을 처리하기 위해 새 셀을 가동할 필요가 없습니다.
특정 샤드에 대한 세부 정보요그러니까 이 경우, 셀 2B에 문제가 생기면
그리고 건강에 해로워지기 시작하면 (불명료한) 세포는 2C 세포로 보내집니다. 왜냐하면 그 두 세포는
샤드 내부에도 살고 있습니다. 즉, 샘플의 경우 특정 터미널 ATM에 대한 요청에 응답할 수 있다는 뜻입니다.
그 특정 샤드에 대해서요.완전한 허용 오차 외에도
세포의 경우에는 세포 내의 세포를 사용합니다.
완전한 관용을 위해 샤드를 만들었죠. 하지만 그 외에도 우리는
확장성을 위해서도 사용할 수 있습니다.예를 들어 이 샤드는
샤드 디자인이 다릅니다.그냥 두 개의 세포만 있는 게 아니에요.
세 개의 세포가 있는데 그 안에는 없어요.
액티브 디자인, 액티브 디자인이 아닙니다.하지만 지금은 활성 상태입니다.
능동적이고 능동적인 설계란 이 사례에서 우리가 가진 허용오차는
셀이 두 개 이상이고 C Zero에는 필수입니다.
셀이 두 개 이상 있어야 합니다.하지만 우리에겐 방법도 있어요
세 개의 다른 세포 사이에 수요를 분배하는 거죠.그러니까 만약 우리에게 뭔가가 있다면
계절에 따라 달라지는 한 주, 그러니까 계절성이 있는 한 주 정도면 더 많은 세포를 생성할 수 있습니다.
이런 종류의 샤드에서 말이죠.애플리케이션이 오버라이드됩니다.
애플리케이션당.애플리케이션이 지원하는 경우
액티브 액티브 디자인을 구현하면 다음을 구현할 수 있습니다.
액티브 액티브 디자인을 통해 확장성도 확보할 수 있습니다.이것이 바로 우리가 염려하는 부분입니다.세포, 즉 세포에 대해 이야기할 때, 한 가지 사실이 있습니다.
전체 파편, 즉 규모가 큰 전체 시스템을 망가뜨릴 수 있습니다.그래서 어플리케이션을 설계하면
그 셀, 예를 들어 1000TPS를 지원하는 쿠버네티스 클러스터에 있는 거죠.
2000TPS를 받으면 아마도 활성 셀이 고장날 것이고 라우터가 트래픽을 보낼 것입니다.
이 경우, 건강한 셀에는 다른 셀이 고장날 수 있습니다.
그러면 모든 세포가 망가질 거예요.이것이 바로 우리가 세포 개념에만 신경을 쓰는 이유죠.그리고 우리는 스케일 유닛 개념을 생각해 냈습니다.그래서 처음부터 응용 프로그램을 설계할 때 셀, 샤드를 설계할 때 우리는 이 규모에 대해 생각했습니다.규모는 어떻게 될까요?
그 세포, 저 세포, 저 척도 단위의뭐가 될까요.400을 설계할 건가요?
팁, 1,000탭, 1만 팁?우리가 결정합니다.디자인을 할 건가요?
데이터 1기가바이트, 10기가바이트, 100기가바이트의 데이터일까요?설계 단계에서 결정합니다.우리는 편안함을 느껴야 합니다.
그 얘기는 스케일 유닛의 설계에 대해서요.자, 이제 살펴보죠.
이 애플리케이션에 대해 살펴본 결과 우리의 정점을 볼 수 있는 것은
온디맨드는 x였죠. 셀을 위한 샤드, 더블 x를 위한 스케일 유닛을 디자인했습니다. 왜냐하면 우리는 그것에 익숙해져야 하기 때문이죠.스케일 유니티의 확장성을 높이는 것은 쉽지 않을 것입니다. 샤드를 분할하지 않으면 다시 생각해야 할 것입니다.
더 높은 수준을 지원하기 위한 애플리케이션 설계
이 경우의 처리량이것이 바로 우리가 하는 이유입니다.
체중계에 주의하세요.체중계가 매우 중요합니다.
이런 유형의 응용 분야에서는 모든 것이 망가지는 것을 방지하기 위해 세포를 스케일 단위로 취급합니다.물론 저는 라우팅에 대해 많이 이야기했습니다.그리고 쉽게 할 수 있게 되었죠.
이 아키텍처에는 라우터가 필요하다는 것을 이해하세요. 왜냐하면
애플리케이션이 종료되어야 하는 적절한 샤드뿐만 아니라 정상 위치에도 요청을 적절하게 라우팅해야 했습니다.
그 샤드를 팔았어요요청을 라우팅하면
비정상 샤드 또는 비정상 스케일 유닛으로
아시다시피, 우리는 고객에게 영향을 미칠 것입니다.이를 위해 우리는 라우터라고 할 수 있는 기술 제품을 설계합니다.
이 라우터를 컴퍼스 (compass) 라고 부릅니다.가능한 가장 얇은 라우터입니다.모든 라우트 로직을 담고 있습니다.
그리고 모든 셀을 검사합니다. 모든 스케일 유닛이 정상인지 확인하죠.그리고 이 두 정보를 가지고 라우팅 테이블이
그리고 헬스 테이블은 수신되는 요청을 바탕으로 어디로 라우팅할지 결정합니다.그 외에도
물론 단일 장애 지점이 될 수도 있습니다.따라서 라우터는 그 외에도
셀 기반 애플리케이션.그래서 우리는 이 라우터를 배포합니다.
여러 셀에 순서대로문제가 생겼을 때
세포 중 하나를 사용해도 괜찮습니다. 우리는 그 세포를 빼내고, 그 세포를 꺼내고
라우터의 다른 셀에서는 트래픽을 수신할 것입니다.여기서 볼 수 있는 또 다른 것은 AZ의 역할입니다.
이 원형에서는 말이죠.세포를 볼 수 있겠죠.
특정 AZ에 살고 있는 이유가 바로 그 때문이죠.
물론 이 작업을 수행하고 싶습니다. 실패 도메인을 AWS에 바인딩하고 싶기 때문입니다.
도메인의 장애 도메인, 즉 AZ입니다.그래서 저는 그걸 피하고 싶어요.
전체 시스템에 영향을 미치는 단일 AZ 문제인 셈이죠.그런 일은 절대 피하고 싶어요.만약 모든 세포가 존재한다면
세 개의 AZ에 퍼져 있으면 AZ 중 하나에서 장애가 발생하면 모든 셀에 영향을 미치게 됩니다.우리는 그렇게 하고 싶지 않습니다.따라서 셀 1A의 쿠버네티스 클러스터처럼 클러스터를 스핀업하면 이 쿠버네티스 클러스터를 하나의 AZ 내에 있는 서브넷으로 제공합니다.이것이 바로 이 클러스터가 될 것입니다.
그 특정 AZ에 위치할 거예요.그리고 그건 아주 중요해요. 왜냐하면 그 이야기는
말씀하신 루치아노가 우리에게 가져다 준 아이디어는 다음과 같습니다.
최대한의 배치 제어.다시 말씀드리지만, C Zero는 제어력을 갖추는 것에 관한 것입니다.우리는 시스템에서 발생하는 장애로부터 벗어날 수 있기를 원합니다.하지만 이제, 우리가 한 가지 예를 들자면
이 아키텍처나 아키텍처의 원형을 들여다보면 간단한 생각을 하게 됩니다.
애플리케이션의 새 버전을 배포하는 것과 같이 훨씬 더 복잡해졌습니다. 이제는 단지 하나의 애플리케이션이 아니기 때문입니다.이 경우에는 7개의 애플리케이션이 있고, 세 개의 다른 라우터 클러스터에 세 개의 라우터 또는 세 개의 기본 배포도 있습니다.그 외에도 배포도 중요합니다.
이로 인해 응용 프로그램에 장애가 발생할 수 있고
이것이 우리가 피할 수 있는 방식으로 배포를 조정하려는 이유입니다.
이 모든 셀에 동시에 실패를 유발하기 위해서죠.그런 이유로 우리는
컨트롤 플레인을 설계했습니다.컨트롤 플레인, C Zero 컨트롤은
플레인은 공격 제품입니다.여기서는 단일 상자로 표현했지만 단일 구성 요소는 아닙니다.사실, 모든 배포를 조율하는 복잡한 시스템입니다.따라서 컨트롤 플레인은
샤드 1부터 시작하여 안정화될 때까지 잠시 기다린 후 변경 사항을 항상 적용하는 등 배포 단계를 제어합니다.
부하가 부족한 셀.그래서 컨트롤 플레인은 나침반 라우터와 함께 작동하여 셀에 부하가 걸리거나 부하가 없을 수 있습니다. 셀에 부하가 걸리면 컨트롤 플레인을 배치할 수 있습니다.
생산 중이 아닌 셀을 대상으로 테스트를 진행하세요.컨트롤 플레인은
나침반을 사용하여 오케스트레이션하여 새 버전의 애플리케이션과 이전 버전으로 향하는 트래픽을 섀도닝합니다.
애플리케이션 버전.캐너리와 컨트롤 플레인을 사용하여 배포를 이동할 수 있습니다. 또한 모든 샤드에 동시에 배포하지 않아도 됩니다.왜냐하면 우리가 그렇게 한다면
버그를 도입하면 버그를 도입할 것입니다.
전체 시스템에서 말이죠.컨트롤 플레인 로직에서는 셀도 만들려고 합니다.
이전 버전과 함께 사용할 수 있습니다.즉, 버전의 롤백은 라우터 레이어를 켜기 위해 필요한 것입니다.시간을 들일 필요가 없습니다.
사실 롤백할 물건을 배포하는 거죠.따라서 이 모든 것이 컨트롤 플레인의 책임이고 컨트롤 플레인은 이 모든 아키텍처가 작동하고 복잡성을 줄이는 데 중요한 역할을 합니다. 그렇지 않으면
우리가 흔히 사용하는 도구이지만 간단한 버그 수정은 매우 복잡할 것입니다.
이 아키텍처에서의 배포.루치아노에게 넘겨서 살펴보도록 하겠습니다.
공학의 기둥. - 호르헤 정말 고마워요.호르헤가 말했듯, 우리에겐 약간의 엔지니어링 기술도 있습니다.
원칙도 마찬가지죠.그리고 생각해보면
엔지니어링 원칙에는 여러 가지 패턴이 있습니다.
이미 꽤 잘 정의되어 있고 책, 백서 및 기사를 통해 문서화되었습니다.
레질리언스와 관련이 있습니다.예를 들어, 그 중 몇 가지를 말씀드릴 수 있습니다.재시도 패턴, 시간
아웃이나 리더 선출, 선택이 필요한 시점
특정 요청에 응답할 서비스 하나 또는 시퀀스 브레이커를 선택하세요.
서비스 내에서 오류가 발생한 종속성을 호출할지 여부를 결정할 수 있습니다.따라서 계속
사용 가능한 기능 중 일부를 사용하여 고객 요청을 처리합니다.이 모든 것이 이 상황을 해결하는 데 도움이 됩니다.하지만 예를 들어보죠.
서비스의 외부 의존성을 호출하는 거죠.이것이 바로 C Zero에 대한 우리의 극도의 회복력 사고방식입니다.예를 들어, 여기
외부 의존성을 a와 동기식으로 호출하는 서비스를 이미 만든 사람
메시지 큐가 중간에 있나요?네, 그럼 우리도 해봤나요?그 점을 염두에 두고 다음 중 하나를 선택하겠습니다.
여기서 우리의 원칙 중 하나를 좀 더 논의하겠습니다.용도가 잘 정의되어 있고 출처를 공유하지 않는 소규모 서비스.예를 들어 Java 프로그래밍 언어를 예로 들어 보겠습니다.
스프링 부스 프레임워크를 사용하면 개발자가 메서드 위에 주석을 달아서 결과를 바꿀 수 있습니다.
메시지 소비자의 메서드와 단일 메서드 호출을 사용하여 동일한 메서드를 전환합니다.
메시지 생산자로서, C Zero의 경우
우리가 점점 더 많아지고 있기 때문에 막중한 책임감을 의미합니다.
테스트 표면 및 문제 해결
해당 서비스의 표면.문제가 발생하면 두 가지 방법으로 모두 문제를 해결해야 합니다.이를 염두에 두고 C Zero 애플리케이션의 예를 간단한 다이어그램으로 보여 드리겠습니다.여기서는 이 접근 방식을 사용하여 좀 더 세부적으로 구분해 보겠습니다.
바로 이 서비스의 책임을 살펴보세요.
예를 들어보죠.먼저, 비즈니스 처리를 담당하는 컨트롤러가 있습니다.
외부 의존성 호출의 오케스트레이션을 뒷받침하세요.그래서 우리는 모든 변화를 겪게 됩니다.
비즈니스 로직에 대한 필요성은 바로 그 특정 서비스에 있습니다.다른 부분은 없습니다.
엑셀이나 응용 프로그램을 변경해야 합니다.같은 방식으로,
해당 컨트롤러를 위한 교육된 리포지토리가 있어야 합니다. 즉, 데이터 상태의 모든 변경 또는 소비는 컨트롤러의 책임입니다.다른 어떤 서비스도 저장소에 직접 액세스할 수 없습니다.따라서 우리는 이를 보장할 수 있습니다.
모든 데이터 변경은 컨트롤러를 통해 이루어집니다.이 작은 것의 또 다른 부분
재시도 로직을 예로 들 수 있습니다.지연된 메시지 큐 패턴을 통해 외부 서비스에 재시도 로직을 적용했습니다. 이 패턴에서는 재시도 시 필요한 변경 사항이 매우 특정한 서비스에 반영되며, 이는 우리에게도 도움이 될 것입니다.
대기열을 모니터링하고 흐름이 어떤지 파악하기 위해서입니다.
해당 대기열에 있는 메시지 수가 예상보다 많습니다. 즉, 더 많은 메시지를 재시도하고 있습니다.
해당 서비스에서 예상했던 것보다 더 많아요.서비스의 다른 부분은 다음을 분리하는 것입니다.
생산자와 소비자, 즉 생산자 흐름이 외부 종속성으로 내려가면 거기서 구현할 수 있기 때문입니다.
예를 들어 스키마의 검증을 통해 다음과 같이 할 수 있습니다.
요청을 준수하고 외부 종속성으로 다운스트림합니다.같은 방식으로
소비자 여러분, 우리도 똑같이 할 수 있습니다. 변화가 생기면
필요에 따라 격리해서 진행합니다.따라서 이 두 서비스의 문제 해결 및 테스트 범위를 줄이고 다음을 통해 검증할 수 있습니다.
다운스트림 흐름과 업스트림 흐름이 어떻게 진행되고 있는지, 방해가 된다면 예상할 수 있습니다.이를 바탕으로 한 간단한 도표는
빌드 쪽에서는 처음에는 더 복잡해 보이지만, 조금 더 복잡해질 것입니다. 하지만 나중에는
진화적 유지 관리가 더 쉬울 것입니다. 왜냐하면
특정 변경이 필요한 경우를 대비하여 애플리케이션의 일부 특정 부분을 변경할 수 있습니다.또한 앞서 말했듯이 테스트와 실행이 더 쉬워집니다.
애플리케이션 문제를 해결하세요.하루가 끝날 무렵,
복원력을 높이는 것, 이것이 바로 우리가 찾고 있는 것입니다.
이 C Zero 애플리케이션용입니다.이를 염두에 두고 호르헤에게 넘겨서
작전을 계속 진행해 보세요. - 이제 본론으로 들어가 보겠습니다.
어려운 부분 작업.보통 우리는 복원력에 대해 생각할 때 운영 측면에서는 생각하지 않습니다.그리고 대부분의 경우,
시스템을 제대로 운영하지 않는 것은 우리가 도입할 때
시스템 장애.여기에는 몇 가지 원칙이 있는데 그 중 하나가 바로 변화입니다.변경 사항을 설계하고 구현하세요.
극도로 원할 때는 복잡할 때가 있습니다.
발생한 실패는 피하세요.하지만 아키텍처에서 보았듯이 두 개의 서로 다른 셀이 있고
몇 가지 제한적인 정책이 있는 반면, 저희는 항상
이전 버전의 셀을 다시 전환할 준비가 되어 있습니다.그럼 위험은
변경 사항을 구현하면 교환이 크게 줄어듭니다.그래서 저는 변화가 매우 중요하다는 것 외에도 변화에 대해 이야기하지 않고 다음 사항에 대해 자세히 알아보기로 했습니다.
옵저버빌리티 부분이죠.옵저버빌리티 (Observability) 는 애플리케이션을 관찰 가능하게 만드는 방법이 아주 많다는 것을 알고 있습니다.확실히 필요합니다.미션 크리티컬 애플리케이션
관찰 가능해야 하고 이해할 수 있어야 합니다.
효과가 있든 안 되든 최대한 빨리하지만 사실, 애플리케이션은
관찰 가능해야 한다는 것이 첫 번째 원칙입니다.하지만 사실 제 최상위는
오늘 여기서 다루고자 하는 내용은 알림 플랫폼과 관련된 것인데, 옵저버빌리티와 연계되어 있습니다.우리가 흔히 볼 수 있는 것 중 하나는 우리에게 임무가 있다는 것입니다.
중요한 애플리케이션, 그리고 모든 것에 대한 지표가 있죠.인프라, 네트워크,
애플리케이션, 비즈니스, 모든 것.그리고 알람을 많이 울렸죠.임계값, (불명료), CPU 메모리, Q 길이, Q 지연 시간, 모든 것.그리고 문제가 생기면 폭풍처럼 쏟아지는 경고를 받게 됩니다.
어떻게 해야 할지 모르겠어요. 정확히 알 수 없는 경보가 너무 많이 오고 있기 때문이죠.
무슨 일이 벌어지고 있는지 이해하세요.내가 뭘, 우리가 본 건
또, 우리가 본 것 또한 우리가 많이 알람을 울리고 나서 떠나는 것들도 있습니다.
일부 알람이 울리고 있습니다.생산을 종료합니다.수백 개의 알람이 울립니다.그리고 엔지니어한테 가세요. 이봐요, 저기
수백 개의 알람이 울리고 있어요.오, 흔하네, 괜찮아.알람은 처음부터 있었어요.응용 프로그램이 작동하고 있다고 말할 수 있습니다.오, 알겠어요.그건 우리가 원하는 게 아니에요
C Zero 애플리케이션에서 말이죠.그래서 여기서는 우리가 어떻게 접근하는지, 특히 더 중요하고 실제로 영향을 미칠 수 있는 알림의 우선 순위를 어떻게 정할 수 있는지 보여 드리겠습니다.
고객 측면에서요.그리고 우리는 SLO를 사용하고 있는데, SLO는 다음과 같은 목표를 가지고 있다는 꽤 일반적인 개념이기도 합니다.
우리가 원하는 서비스 수준 중 일부는 말이죠.좀 더 명확하게 설명하기 위해 간단한 데모로 넘어가겠습니다.SLO에 대한 우리의 접근 방식우선, 시작하겠습니다.
모든 것을 측정합니다.그래서 우리는 모든 것을 측정했지만, 그 다음에는 이해해야 합니다.
사용자 여정이란 무엇일까요?예를 하나 들어보죠.응용 프로그램 중 하나입니다.이 응용 프로그램에는 다음이 있습니다.
발견이라 불리는 여정.이것은 매우 중요한 발견이며, 매우 중요한 발견입니다.
이 애플리케이션에서의 여정은 고객에게 영향을 미칩니다.
작동하지 않을 경우 많은 문제가 발생할 수 있습니다.이 여정을 계획하기 시작하죠.그래서 이 에너지 때문에
포인트 디스커버리가 제대로 작동하려면 어떻게 해야 할까요?
건강하면 제대로 할 수 있을까요?그래서 두어 개 있네요
우리가 유발하고 요청하는 구성 요소 (불명료)
그리고 그런 것들도요.좋아요, 그럼 계약서를 설계하죠.그래서 우리는 정의를 사용하고 있습니다.
SLO 계약에 대해이 계약의 정의에는 다음과 같은 내용이 있습니다.
에 대한 몇 가지 메타데이터가 있지만, 여기서는 이 SLO를 정확히 어떻게 계산할지 알 수 있습니다.이 SLO의 목적은 다음과 같습니다.이 SLO는 발견 여정을 위한 이 여정의 지연 시간 SLO입니다.그래서 P90에서 500밀리초 미만을 목표로 삼았습니다.
이 API 호출에서는이것이 우리의 목표이고, 이것이 바로 에서 구현된 것입니다.
이러한 사기가 이 계약에 반영되었습니다.그러면 모니터링을 시작할 수 있습니다.물론이죠, 우선.음식 발견의 여정을 보여주는 대시보드도 있습니다.그래서 이런 것들은 꽤 흔합니다.SLI와 알림이 있습니다.
여기에 있는 모든 것에 대해 말하자면, 가끔은 우리가 신경 쓰지 않는 알림의 일부이기도 하죠 (웃음).여기 한 가지 예가 있습니다.
이 클러스터를 (불명료하게) 테스트하고 테스트 중에 확인할 수 있는 것은
여기서는 지연 시간이 많이 늘어났습니다.물론 처리량도
이 테스트 도중에 떨어졌어요.그와 동시에,
SLO를 계산한 결과 SLO가 충족되지 않은 것으로 나타났습니다.그래서 우리가 가장 먼저 한 일은 다음과 같습니다.우리는 그 지표 P를 아홉 번째 숫자로 변환시켰는데, 500억 미만으로 줄였습니다.
두 번째를 백분율로 나타낸 것입니다.그러니까 그 모든 사람들이
오늘날의 운영에서는 SLO가 무엇인지 이해할 필요가 없지만 SLO는 이해할 수 있습니다.
납품 중이기 때문에 SLO를 충족하지 못하고 있습니다.
SLO의 100% 미만입니다.따라서 이것이 표준입니다.
수술이나 수술에 아주 중요한 게 있어요.
운영되고 있는 팀들은 우리가 회의를 하고 있는지 아닌지를 금방 이해하므로 그럴 필요도 없습니다.
SLO가 뭔지 생각해 보세요?아, 지연 시간이 더 짧아졌네요
500개 미만 또는 200개 미만이요.그들은 그것에 대해 생각할 필요가 없어요.그래서 우리는 SLO를 계산하고
SLO를 100% 를 기반으로 하는 지표에 넣으세요.그러면 SLO를 볼 수 있습니다. 시간 경과와 경과에 따른 SLO의 변화, 그리고 SLO도 볼 수 있습니다.
SLO는 줄어들고, 실험 중에는 SLO가 줄어들고, 실험에서는 KO가
실제로 목표를 9% 로 잡았기 때문에 DAR 예산을 계산할 수 있습니다.이것은 DAR이 얼마나 좋은지 보여줍니다.
테스트 중에는 예산이 소모되고 있습니다.여기서 쉽게 알 수 있듯이 10분 동안 DAR 예산을 모두 소진했고, 그 동안에는
특정 기간 동안 우리는 고객에게 영향을 미쳤습니다.물론 저희도 그렇습니다.
DAR을 숫자로 계산하세요.하지만 경보에 접근하는 방법은 다음과 같습니다.우리가 계산하는 세 번째 지표가 있는데, 바로 연소율입니다.사실 이건
우리가 소모하는 속도는 특정 노력 예산입니다.이런 유형의 애플리케이션에서 1시간의 창은 우리가 할 수 있는 시간이고, 엔지니어들이 조치를 취하도록 할 수 있는 시간대입니다.그리고 이렇게 되면
연소율이 1을 넘는다는 건 그렇지 않으면
그 당시에는 아무 것도 하지 마세요. 특정 기간 동안 남은 AR 예산을 소진할 것입니다.이게 방아쇠입니다.화재 경보나 경보를 원하면 이 경보를 엔지니어에게 알리고 엔지니어들이 와서 실제로 무슨 일이 일어나고 있는지 이해해야 합니다.아마도 이 시간에는 우리가 볼 수 있는 광경이 펼쳐질 것입니다.
기술 경보도 많이 울리고 있습니다.아마도 CPU는 어딘가, 메모리는 어딘가, (불명료), 네트워크,
(불명료) 어딘가.우린 몰라요.그냥 문제가 될 거예요
사실 C Zero에서는 조사를 하지 않습니다.
문제에 맞서 싸우세요.그럼 확인만 해볼게요
어떤 셀이 이러한 지연 문제를 일으키고 있는지 확인하고 해당 셀의 트래픽을 제거해 보겠습니다.그리고 나서 우리는 이해하려고 노력합니다.
거기서 무슨 일이 벌어지고 있는거죠.하지만 이것이 우리가 경보에 접근하는 방식입니다.이에 대한 우리의 경보 시스템은
미션 크리티컬 애플리케이션은 연소율을 기반으로 합니다.
SLO의 AR 예산.어떻게 계산하는지, 어디서 계산하는지, 어떻게 계산하는지 생각하시는 것 같은데요?그래서 우리는 컴포넌트를 개발합니다.
세포 안에 있는 거죠.응용 프로그램과 매우 가까운 곳에 다음과 같은 구성 요소가 있습니다.
SLO를 계속 계산합니다.SLO, AR 예산, 연소율.SLO, AR 예산 및 AR 속도.그리고 이 구성 요소는 그 일부입니다.
정상 상태입니다. 즉, 이 구성 요소에 장애가 발생하면 전체 세포가 고장난 것으로 간주합니다.그렇다면 우리는 할 수 없습니다.
더 이상 SLO를 계산해 보세요.그래서 우리는 그 세포에서 벗어나야 합니다. 뭐가 뭔지 모르기 때문이죠.
거기서 벌어지고 있는 일이죠, 그렇죠?그게 우리가 접근하는 방식이에요.
C Zero의 운영을 위한 SLO는 우리가 사용하는 중요한 애플리케이션입니다.다시 설명해 보겠습니다.
파워포인트를 프레젠테이션으로 옮겨 요약해 보겠습니다.따라서 C Zero, Camada Zero는 다음과 같은 프레임워크입니다.
아키텍처 원칙, 엔지니어링 원칙
및 작동 원칙.저희의 극도의 레질리언스 마인드를 이해해 주셨으면 좋겠습니다. 아키텍처뿐 아니라
이러한 스케일 유닛이 아닌 아키텍처 접근 방식을 사용하는 것뿐만 아니라 엔지니어링에서 우리가 가지고 있는 원칙 중 하나인 작은 책임 원칙과 운영 원칙에도 적용했습니다.다시 말씀드리지만, 카마다 제로 (Camada Zero) 에서는 두 가지, 기본적으로 두 가지를 원하죠.극도의 회복력에 대한 사고방식
그리고 최대한의 통제력.사실, 우리는 원하지 않아요.
장애가 발생한 적이 있는데 그 실패를 해결해야 하는 상황이었어요.사용자, 고객
그 당시 영향을 받았고 우리는 이해하려고 노력하고 있습니다.
무슨 일이에요.그래서 카마다 제로에는
이런 상황은 없습니다.우린 그냥 감방 안에서 멀어져만 갈 뿐이야
모든 게 괜찮을 거예요.그리고 완전한 샤드나 파티션에 어떤 장애가 있더라도, 그것이 오류를 나타내지는 않습니다.
전체 시스템 장애.그래서 우리는 축복받은 사람들을 줄입니다.
비율을 최대한 높이세요.즐거운 시간 되시길 바라며, 여러분 모두에게 감사드립니다.시간이 되셨다면, 거기 계세요.
우리 부스에서 몇 시간 더 남았어요그게 될 거예요
모셔서 Camada Zero 또는 기타 제품에 대해 더 자세히 논의하게 되어 기쁩니다.
은행에 있어요.그리고 이 프레젠테이션도 기대됩니다.
회복력에 대한 여러분의 생각을 조금이나마 바꿀 수 있을 것입니다.정말 고마워요. - [루치아노] 정말 고마워요.(관객 박수)