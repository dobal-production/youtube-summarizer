- 안녕하세요 여러분, 안녕하세요. 고마워요.
우리 세션에 들어오겠습니다.오늘 모두 참석해 세션에 참여하게 되어 반갑습니다.슬라이드에서 알 수 있듯이, 이제 더 자세히 살펴보도록 하겠습니다.
추가에 관한 매우 구체적인 SaaS 주제는 다음과 같습니다.
멀티테넌트 SaaS 환경으로의 페더레이션 ID 지원.제 이름은 담미카 스리야난다입니다.오늘 제 동료 토비 버클리도 저와 함께 무대에 섰습니다.우리 둘 다 AWS의 수석 아키텍트입니다.우리는 팀의 일원입니다.
AWS SaaS 팩토리라고 합니다.이름에서 알 수 있듯이 우리 팀은 고객 및 파트너의 구축, 마이그레이션, 현대화를 지원합니다.
AWS상의 멀티테넌트 솔루션.이제 고객이 언제든지
저희에게 연락하여 구축에 도움을 요청하고 있습니다.
그들의 SaaS 솔루션은 가장 먼저
우리가 논의할 것은 어떻게 관리하느냐에 관한 것입니다.
SaaS 애플리케이션에서 이러한 ID 작업을 제공하기 위한 사용자 및 ID.이제 대부분의 경우 저희가 중앙에서 관리하는 표준 SaaS ID 워크플로우를 구현하도록 도와드리겠습니다.
테넌트, 테넌트 사용자 및 내부 ID
SaaS 애플리케이션.자, 이제 SaaS 제공업체는
이러한 것들을 관리할 뿐만 아니라 더 나은 제어 기능을 갖게 될 것입니다.
SaaS 앱 내 ID, 하지만 ID 제공을 위한 ID
오퍼레이션도 포함됩니다 (예: 인증).
최종 사용자에 대한 권한 부여오늘 우리가 할 일은
한 단계 더 나아가 어떻게 추가할 수 있는지 살펴보겠습니다.
SaaS 애플리케이션에 대한 페더레이션 ID를 통해 SaaS 제공업체로서 이제 온보딩할 수 있습니다.
자체 IdP를 보유한 테넌트이므로 싱글 사인온이 가능합니다.
SaaS 애플리케이션에.여러분도 그렇게 왔으면 좋겠어요.그리고 이게 될 거예요
레벨 300에 대한 논의이기 때문에 코드를 작성하거나 데모를 할 시간이 없을 수도 있습니다. 하지만 디자인 원칙에 대해 깊이 있게 살펴보도록 하겠습니다.
아키텍처 패턴 및 페더레이션 추가에 대한 구현 세부 정보
SaaS 애플리케이션에.몇 가지 방법을 살펴보겠습니다.
다음과 같은 방법으로 다양한 페더레이션 프로토콜을 구현할 예정입니다.
아마존 코그니토를 예로 들어보겠습니다.자, 시작하기 전에
페더레이션에 대해 말씀드리자면, 시간을 내서 표준 SaaS ID 패턴과 기본에 대해 자세히 알아보고 싶습니다. 아직 그럴 것이기 때문입니다.
페더레이션 스토리에도 유효하고 적용성이 높습니다.이제 개괄적으로 살펴보자면 SaaS 애플리케이션은 두 가지 주요 구성 요소로 나눌 수 있다는 것을 알 수 있습니다. 애플리케이션 플레인은
비즈니스 로직, 마이크로서비스, 데이터베이스 등을 모두 갖추고 있습니다.또한 공유를 제공하는 SaaS 컨트롤 플레인도 있습니다.
SaaS 공급자가 서비스를 운영할 수 있도록 서비스를 제공합니다.
SaaS 애플리케이션을 효율적으로 사용합니다.핵심 기능 중 하나
SaaS 컨트롤 플레인의 특징 중 하나는 원활한 테넌트를 제공한다는 것입니다.
온보딩 기능을 통해 테넌트를 온보딩한 다음 SaaS 애플리케이션에서 사용자를 생성하도록 요청합니다.이제 이를 위해 일반적으로 중앙 집중식 시스템을 사용합니다.
SaaS 애플리케이션 내에 SaaS ID 공급자가 있으므로 SaaS 애플리케이션 내에서 이러한 사용자 ID를 안전하게 관리하고 운영하는 데 도움이 됩니다.따라서 인증 및 인증과 같은 ID 작업을 제공할 수 있습니다.
이들에 대한 권한 부여자, 보시면
프로필을 생성하기 위해 테넌트 사용자에게 필요한 정확한 데이터세트입니다.
SaaS IdP에는 두 가지 주요 데이터 유형이 있습니다.일반적으로 다음과 같이 요청합니다.
사용자 이름, 암호 및 기타 ID 세부 정보와 같은 테넌트 사용자의 사용자 특성을 제공하십시오.그리고 생성하는 동안에도
SaaS IdP에 해당 프로필도 삽입하고 싶습니다. 테넌트 ID와 테넌트 컨텍스트도 여기에 삽입하려고 합니다.즉, SaaS IdP에서 생성하는 모든 테넌트 사용자는 사용자 ID와 테넌트 ID (SaaS ID라고 함) 를 함께 갖게 됩니다.그러면 다음을 수행하는 데 도움이 될 것입니다.
SaaS 애플리케이션 내에서 이러한 사용자를 고유하게 식별하세요.따라서 주요 목표는
이 설계의 목적은 성공적으로 인증되면 SaaS 산업을 테넌트 사용자에게 다시 전달하여 SaaS와 상호 작용하는 데 사용할 수 있도록 하는 것입니다.
애플리케이션을 효율적으로 사용하세요.자, 이제 여러 가지가 있습니다.
이를 구현하는 방법, 하지만 SaaS IdP가 토큰 기반을 지원하는 경우
아이덴티티 오퍼레이션을 통해 무언가를 쉽게 활용할 수 있습니다.
SaaS를 나타내는 인접한 웹 토큰처럼
사용자의 신원을 확인한 다음 해당 토큰을 사용자에게 발행하여 사용자가 실제로 해당 토큰을 사용하여 효율적으로 작업할 수 있도록 합니다.
SaaS 애플리케이션.이제 이러한 토큰은
일반적으로 SaaS IdP에 의해 완전히 관리됩니다.그리고 보안 기능도 갖추고 있습니다.
예를 들어 기본적으로 내장되어 있습니다.암호화되어 있고 TTL도 있고 만료될 예정입니다.
언젠가는 올라오기도 하죠.이제 아이덴티티 측면에서 토큰 기반 구현은 다음과 같은 테넌트 사용자의 다운스트림 통신을 자동화하는 데 큰 도움이 될 것입니다.
SaaS 애플리케이션도 마찬가지입니다.이제 예를 들어보겠습니다.예를 들자면,
SaaS 애플리케이션.저는 이 코그니토를 SaaS IdP로 사용하고 있습니다.그리고 테넌트 한 명이 등록되어 있습니다.그리고 존 (John도 한 명) 이 있습니다.
그 테넌트의 사용자 중 프로필이 이미 생성되었어요...이미 Amazon Cognito에서 생성되었습니다.자, 존이 시도할 때
유효한 세션이 없는 경우 SaaS 애플리케이션에 액세스하세요.
이 단계에서 사용할 수 있는 SaaS 앱은 Cognito에 요청합니다.
John을 인증하기 위해서죠?여러 가지 방법이 있지만, 낮은 수준에서는 oauth2/authorize 엔드포인트를 호출할 것입니다.
Cognito로 이 작업을 완료하세요.왜요?왜냐하면 코그니토는 오픈ID이기 때문입니다.
다음을 기반으로 구축된 연결 구현
oauth2 사양 맞죠?그러면 우리가 a를 사용할 것이라는 것을 알 수 있을 것입니다.
ID 작업 측면에서 Cognito를 사용하고자 할 때마다 많은 oauth2 엔드포인트가 필요합니다.이제 이 단계에 있는 Cognito는
로그인 페이지가 표시됩니다.호스팅된 UI인 Cognito를 활용했습니다.
테넌트 사용자에게 인증을 요청하기 위한 관리형 프런트 엔드 인터페이스입니다.그러면 John이 들어올 것입니다.
그가 만든 사용자 이름과 암호.그러면 Cognito는
인증을 하세요.인증에 성공하면 Cognito가 다시 돌아옵니다.
인증 코드를 사용하여 SaaS 애플리케이션으로 이동합니다.이제 SaaS 앱이 oauth2/Authorated를 사용하여 토큰을 요청할 수 있습니다.
인증 코드를 전달하여 엔드포인트를 표준화합니다.따라서 Cognito는 John 내부에 있는 SaaS ID를 가져와서 변환합니다.
토큰 중 하나로 만든 다음 표준을 통과시키세요
ID 토큰, 액세스 토큰 및 새로 고침 토큰을 SaaS 애플리케이션으로 다시 보냅니다.자, 제가 가지고 있는 방법을 바탕으로
SaaS 애플리케이션을 개발했는데 ID 토큰에 John의 SaaS 아이덴티티를 표시할 수 있습니다.
액세스 토큰도 마찬가지고요.이제 예를 들어 ID 토큰을 활용하여 John의 SaaS ID를 표현했습니다. 여기서 사용자 세부 정보와 John의 테넌트 세부 정보를 사용자 지정 속성 측면에서 확인할 수 있습니다.이제 이 정보가 있으면
이걸 쉽게 보내세요...John이 다운스트림 통신으로 수행할 모든 API 호출과 함께 이것을 HTTP 헤더로 쉽게 보낼 수 있습니다.
SaaS 애플리케이션 사용.그러면 모든 마이크로서비스가 기본적으로 토큰을 가져와서 크랙할 수 있게 하는 데 도움이 될 것입니다.
John의 세부 정보, 사용자 세부 정보, 테넌트 ID 및 데이터를 열고 액세스하십시오.
모든 테넌트리 작업에 대한 테넌트 세부 정보도 제공됩니다.이제 이렇게 할 수 있습니다.
이 토큰 덕분에 이러한 다운스트림 워크플로에 많은 자동화가 가능해졌습니다.
기반 인증.자, 뭘 보시면
Cognito 디자인은 현재 단계에 있습니다. 몇 가지 사항이 있습니다.
이는 SaaS 제공업체가 담당해야 합니다.그 중 하나는
사용자 스키마를 정의하는 것인데, 이는 무엇을 의미하는지와 같습니다.
사용자가 SaaS IdP에서 생성하도록 한 다음 이를 다음과 같이 매핑해야 하는 사용자 속성
oauth2 어트리뷰트를 Cognito에 저장한 다음, 다음과 같은 속성을 생성하십시오.
SaaS ID를 나타내는 데 필요한 사용자 지정 속성입니다.따라서 Cognito는 이를 기반으로 발전할 것입니다.
그리고 테넌트 때와 같은 시기에 사용자를 생성합니다.
사용자는 온보딩되어야 합니다.그리고 그 위에 엔트리인 앱 클라이언트를 하나 이상 만들 예정입니다.
ID 작업을 위해 사용자 풀에 연결하도록 테넌트 사용자를 가리킵니다.
예: 인증.또한 고유한 Cognito 도메인도 있습니다.
사용자 풀에 제공할 수 있는 URL입니다. 이 URL은 호스팅된 UI와 oauth2 엔드포인트를 가져오는 데 도움이 됩니다.
생활 속에서도 마찬가지죠.그 외에도 정말 많은 것들이 있습니다.
SaaS 공급자를 위해 제공되는 구성은 해당 구성을 위한 사용자 풀 내에 있습니다.
SaaS 사용 사례를 기반으로 합니다.보시다시피 이 표준 SaaS ID 모델에서는 SaaS 공급자가 SaaS 애플리케이션 내의 사용자와 ID를 중앙에서 관리하고 있습니다.따라서 ID 작업을 제공하고 다운스트림 통신에 토큰 기반 자동화를 제공할 수 있어 제어가 더 쉬워졌습니다.하지만 만약 테넌트가 진짜라면 어떨까요?
SaaS 공급자가 ID를 관리하는 것을 원하지 않습니다.
직원들 중에 어떤가요?예를 들어, 일부 임차인은 자신의 집을 권하지 않을 수 있습니다.
직원들은 나가서 세 번째 아파트에 등록할 것을 권유합니다.
프로필을 생성하고 사용자 이름과 암호를 제공하는 타사 SaaS 애플리케이션. 주로 다음과 같은 이유
보안상의 이유, 취약점 및
회사 정책도 마찬가지입니다.이제는 그 대신 조직 내 기업 ID를 활용하여 단일 ID를 제공할 것입니다.
모든 기업 애플리케이션에 대한 로그온 기능.자, 이것이 일종의 훌륭한 관리 방법입니다.
조직 내 직원들의 정체성.예를 들어, 직원 중 한 명인 John이 퇴사하면 IT 팀이 해야 할 일은 바로 다음 작업을 수행하는 것뿐입니다.
IdP에서 해당 직원을 무효화하면 John은 패배하게 됩니다.
애플리케이션에 대한 모든 기업 액세스 권한, 맞죠?하지만 만약 John이 SaaS에 가입했더라면
별도로 신청하면 정말 많을 거예요.
이러한 액세스 권한을 제거하기 위해 IT 팀이 해야 했던 차별화되지 않은 조치였죠.그래서 보안이 최선이라고 할 수는 없습니다.
가장 좋은 방법이기도 하고, 모범 사례이기도 하죠.이런 세입자들의 주요 요청 중 하나는
또는 SaaS 제공업체에 대한 조직에서 다음과 같은 사항은 다루지 말자고 했습니다.
표준 ID 흐름이지만 회사 IdP를 SaaS 애플리케이션과 통합하여 직원들이
직접 싱글 사인온한 다음 그에 따라 SaaS 앱을 사용하세요.이것이 우리가 추가를 생각하게 된 가장 큰 동기입니다.
SaaS 애플리케이션에 대한 페더레이션 ID 지원.이제 페더레이션을 통해 SaaS 애플리케이션이 생겼고 컨트롤 플레인이 생겼습니다. 테넌트 1과 2와 같은 테넌트가 함께 제공됩니다.
그들의 기업 신분증을 등록해야 합니다.그래도 여기서 직원들을 위한 원활한 온보딩 서비스를 제공해야 해요.하지만 온보딩 이후의 차이점은
SaaS 애플리케이션에서 사용자를 생성하지 않거나
SaaS IdP는 이전과 같습니다.그 대신 그들은 자신들의 제품을 소비할 것입니다.
기업 IdP를 인증한 다음 SaaS를 사용합니다.
그에 따라 신청하세요.하지만 페더레이션 세부 정보와 페더레이션 워크플로를 관리하려면 여전히 SaaS IdP (이 경우에는 Cognito) 가 필요합니다.이제 문제는 페더레이션을 통해 성공적인 SaaS 비즈니스를 구축할 수 있느냐는 것입니다.그렇지 않을 가능성이 큽니다. 페더레이션이 없는 테넌트도 있을 수 있기 때문이죠...테넌트가 없는 테넌트도 있을 수 있습니다.
이 단계의 기업 IDP로서 필요하지 않은 기업 IDP
싱글 사인온 기능.따라서 이러한 테넌트는 계속 운영해야 합니다.
표준 IdP 워크플로.또한 이 페더레이션을 보유한 SaaS 공급자가 페더레이션을 고려할 것이라는 사실도 알 수 있습니다.
SaaS 애플리케이션의 프리미엄 기능이며, 해당 기능만 사용할 수 있습니다.
고주문 테넌트용.따라서 기본, 무료 또는 프리미엄 테넌트와 같은 하위 테넌트는 여전히 통과해야 합니다.
기본 아이덴티티 워크플로.따라서 페더레이션과 표준 ID가 모두 있어야 합니다.
워크플로가 가장 가능성이 높습니다.이제 페더레이션의 작동 방식, 싱글 사인온의 작동 방식에 대해 좀 더 알아보도록 하겠습니다.
SaaS 애플리케이션을 예로 들어 보겠습니다.Amazon Cognito를 SaaS IdP로 사용하는 SaaS 애플리케이션이 있습니다.테넌트가 하나 있는데
그들만의 기업 IdP테넌트 1명을 온보딩했습니다.
페더레이션 지원과 함께 말이죠.이제 테넌트 원 사용자가 시도하면
SaaS 애플리케이션에 액세스하고 유효하지 않은 경우
이 단계에서 사용 가능한 세션이 있으면 Cognito는 인증을 시도한 후 이러한 사용자가 Cognito에서 생성되지 않았으므로 인증할 수 없다는 것을 알게 됩니다.그 대신 다음과 같은 몇 가지 방법이 있습니다.
페더레이션해야 한다는 컨피그레이션이 나오는데 모든 구성이 있습니다.
Cognito에서 이 작업을 수행할 수 있습니다.따라서 클라이언트 측도 있을 것입니다.
이러한 요청을 기업 IdP로 다시 리디렉션합니다.이제 사용자는 갑자기 다음을 보게 될 것입니다.
그가 매일 보게 될 수도 있는 회사 IdP의 일반적인 로그인 페이지입니다.그러면 그는 로그인 또는 도메인을 추가할 수 있게 됩니다.
사용자 이름 및 암호.인증에 성공하면 기업 IdP는 다음을 반환합니다.
Cognito에 다시 요청하세요.다시 말씀드리지만, 저희는 클라이언트 측 리디렉션입니다.Cognito는 이를 검증할 수 있습니다.인증이 정상이고 권한 부여도 정상이면 사용자는 다음을 수행할 수 있습니다.
SaaS 애플리케이션에 액세스하세요.이제 보시다시피 연결을 시도하고 있습니다.
매우 비동기적인 방식으로 이뤄진 신뢰 주체의 두 세계, 즉 SaaS IdP와 기업 IdP입니다.이것은 단지 높은 수준의 워크플로우일 뿐이며, Toby가 이에 대한 구현 세부 사항과 계측 방법을 안내해 줄 것입니다.
이 문제를 해결하려면 SaaS 컨트롤 플레인이 필요합니다.이제 Cognito 내부에서 어떤 일이 벌어지고 있는지 알아보는 것도 흥미롭습니다. 그러면 이전 표준과 빠르게 비교할 수 있습니다.
SaaS 아이덴티티 워크플로도 마찬가지입니다.이제 두 가지 주요 사항이 있습니다.
페더레이션을 적용했을 때의 Cognito에는 차이가 있습니다.앞서 언급했듯이 페더레이션 테넌트는 그렇지 않습니다.
SaaS IdP에서 사용자를 생성하면 활용할 수 있기 때문에 그럴 필요가 없습니다.
인증을 위한 자체 IdP.하지만, 의 일환으로
페더레이션 워크플로에서 이러한 사용자는 어쨌든 Cognito 또는 SaaS IdP에서 자동으로 생성되며, 우리는 이들을 프록시 사용자라고 부르며 이들은 다음과 같은 기능만 가지고 있습니다.
이들에 대한 사용자 세부 정보 및 해당 사용자 세부 정보는 전적으로 다음 기관에 의해 관리됩니다.
각 기업 IdP.즉, SaaS 제공업체는 이러한 사용자 세부 정보와 아무 관련이 없습니다. 왜냐하면 이러한 사용자 세부 정보는 다음과 같기 때문입니다.
자동으로 생성되고 있습니다.두 번째 차이점은 엔티티가 필요하다는 것입니다.
사용자 풀 내에서 해당 페더레이션 세부 정보를 관리할 수 있습니다.사용자 풀은 페더레이션된 ID 공급자라는 기능을 제공합니다. 이 기능을 통해 저는 거의 모든 프로토콜을 사용할 수 있습니다.
특정 구성.모든 테넌트에 대해
페더레이션이 필요한 경우 사용자 풀 내에 다음을 포함하는 전용 페더레이션 IdP를 만들겠습니다.
페더레이션 관련 구성은 다음을 수행하는 데 도움이 될 것입니다.
페더레이션 워크플로도 마찬가지입니다.자, 이제 이 단계에서는
SaaS 제공업체의 경우 관리해야 하는 어려움이 있다는 것을 알고 있습니다.
이 비동기 워크플로는 페더레이션을 용이하게 하기 위한 것입니다.이와 마찬가지로 팀원들이 생각해야 할 과제도 몇 가지 더 있습니다.그 중 하나는
앞서 말씀드렸듯이 대부분의 경우 연맹과
표준 ID 워크플로, 둘 다 공존해야 합니다.
SaaS 애플리케이션에서그리고 SaaS IdP는
둘 다 이상적으로 지원하면 생활이 훨씬 쉬워집니다.또한 여러 가지가 있다는 것도 알 수 있을 것입니다.
다양한 아이덴티티 프로토콜도 있습니다.그리고 SaaS 공급자인 여러분도
테넌트가 어떤 프로토콜을 사용할지 전혀 통제할 수 없겠죠?사실 이는 도메인 중심의 결정이라고 할 수 있습니다.그래서 여러분이 할 수 있는 일은 일종의 도구를 사용하는 것뿐입니다.
컨트롤 플레인이 테넌트의 ID 프로토콜을 기반으로 테넌트가 들어오는 대로 온보딩할 수 있게 하는 거죠.SaaS에 대해 말씀드렸습니다.
아이덴티티 개념은 앞서.그리고 나서 말씀드렸듯이
직접 만들거나 SaaS IdP에 있는 모든 사용자는 SaaS ID를 가져야 자동화할 수 있습니다.
워크플로 다운스트림 맞죠?하지만 페더레이션 사용자는
사용자 ID만 있어야 합니다.따라서 테넌트 ID를 주입할 방법을 찾아야 하고
테넌트 컨텍스트를 통해 테넌트가 작업하고 싶을 때 비슷한 자동화 기능을 사용할 수 있습니다.
SaaS 애플리케이션.이것이 당면 과제 중 하나입니다.SaaS 애플리케이션에 페더레이션을 구현하려는 경우, 특히 SaaS 앱이 여러 개로 확장되는 경우 규정 준수와 규정에 대해 논의하는 것이 좋습니다.
국가 또는 지역.그래서...그리고 데이터 레지던시 또는 데이터가 있으면
주권 규정이 마련되어 있는 경우, 예를 들어 Cognito를 국내로 가져와야 할 수도 있습니다.
해당 국가를 예로 들 수 있습니다.그러니까 아직 너한테 있는 게
중앙 집중식 SaaS 제어 팬이지만 이러한 사용자는 경계를 넘지 않고 페더레이션할 수 있도록 자체 Cognito 인스턴스로 리디렉션됩니다.따라서 페더레이션 전에 이러한 종류의 설계 논의를 거쳐야 약간의 구현에 도움이 될 수 있습니다.
SaaS 애플리케이션의 페더레이션에 대해.비용 및 할당량은
재미있을 것 같기도 하고요.보통 모든 IdP의 번호가 다릅니다.
할당량 및 ID 작업과 비교한 비용에 대해마지막으로, 어떻게 생각하시나요?
이 전체 프로세스를 자동화하여 테넌트와 해당 사용자가 페더레이션을 원활하게 구현할 수 있도록 하세요.
SaaS 애플리케이션에서도 문제 중 하나가 될 것입니다.이제 여러 가지가 있다고 말씀드렸습니다.
페더레이션 프로토콜은 이미 나와 있습니다.그리고 오늘은 다이빙을 해볼까 합니다
그 중 몇 가지에 대해 자세히 알아보겠습니다.OpenID Connect에 대해서는 앞서 대충 언급한 바 있습니다.아이덴티티 레이어입니다.
oauth2 외에도 Cognito가 그 예 중 하나입니다.그리고 정말 많은 것들이 있습니다.
OIDC를 지원하는 Okta와 같은 파트너 솔루션.그리고 꽤 오랫동안 사용되어 온 SAML 2.0도 있습니다.이렇게 하면 간소화하는 데 도움이 됩니다.
XML 어설션을 사용한 사용자 인증과 액티브 디렉터리를 예로 들 수 있습니다.자, 이제 보시면
Cognito 관리 콘솔을 보면 다음과 같은 기능도 사용할 수 있습니다.
소셜 제공자를 만드세요.소셜 제공자는...일종의 추상화 계층입니다.
Cognito를 사용하면 소셜 아이덴티티를 쉽게 만들 수 있습니다. 즉, 테넌트가
소셜 ID를 지원하므로 이제 이를 페더레이션 ID로 통합할 수 있습니다.
소셜 공급자를 사용하여 SaaS 애플리케이션에서.좋아요.자, 이제 논의해봤어요
페더레이션과 과제에 대해 말씀드리고, 고도의 비동기 워크플로우도 당면 과제로 다루었습니다. 이제 알아보도록 하겠습니다.
구현 부분.이제 구현과 관련하여 논의해야 할 두 가지 주요 영역이 있습니다.테넌트 온보딩은 어떻게 처리하나요?
페더레이션과 헤어지나요?그리고 추가적으로 어떤 것들이 있나요?
싱글 버전을 지원하는 데 필요한 계측기
사용자 로그온?온보딩부터 시작해 보겠습니다.예를 들자면, 저는
Cognito를 SaaS IdP로 사용하는 SaaS 애플리케이션이 있습니다.그리고 테넌트와 통합할 자체 IdP를 가진 테넌트가 있습니다.
SaaS 앱과의 페더레이션.가장 먼저 해야 할 일 중 하나는 여러분이 만든 것을 만드는 것입니다.
테넌트의 통합 앱을 IdP로 호출하세요.이제 이 통합 앱은 사용자를 포워딩하기 위한 Cognito의 진입점에 불과합니다.
페더레이션용 테넌트 1에서 제공됩니다.자, 우리가 성공하기 위해서는
통합 앱을 생성하려면 콜백이 필요합니다.
프로토콜 기반 URL 또는 SSO URL
테넌트의 IdP 1개이제 Cognito는 오직 하나만 가능합니다.
테넌트 하나의 URL 뒤에 이 두 URL을 제공하십시오.
SaaS 애플리케이션에 제대로 온보딩되었습니다.그 이유는 테넌트의 특성에 따른 것입니다 (예: 테넌트의 경우).
하나는 프리미엄 등급 테넌트이므로 결국 생성하게 될 수도 있습니다.
이들을 위한 새로운 사용자 풀을 만들면 다른 것을 갖게 될 것입니다.
콜백 SSO URL.그래서 기본적으로는 할 수 없어요.
복잡하기 때문에 이 URL을 미리 제공하십시오.따라서 첫 번째 단계로 테넌트 1을 SaaS 애플리케이션에 온보딩했어야 했지만 성공적으로 진행하려면
Cognito는 테넌트를 온보딩할 것을 요구할 것입니다.
통합 앱 구성이제 보시다시피
여기에는 순환 종속성이 있습니다.이것이 바로 SaaS 공급자로서 이러한 종속성을 관리하고 온보딩하는 테넌트에게 이러한 원활한 경험을 제공할 수 있는 방법을 모색하는 데 있어 당면한 과제입니다.
페더레이션과 함께 말이죠.이제 몇 가지 예를 살펴보겠습니다.
다양한 워크플로가 있습니다.그렇다고 말하는 게 아니에요.
이것들이 우리가 이 문제를 해결할 수 있는 유일한 방법이에요. 단지 관점을 좀 얻어보자면
테넌트 온보딩을 위한 원활한 경험
페더레이션과 함께이제 첫 번째 워크플로우에서는 OIDC IdP가 포함된 테넌트 1이 생겼습니다.이 흐름은 SAML에서도 완벽하게 작동합니다. OIDC를 예로 들어 보겠습니다.그리고 SaaS 관점에서 보면 제가 예상할 수 있는 계층화 전략이 포함된 표준 공개 랜딩 페이지가 생겼습니다.
페더레이션에 속한 테넌트를 포함한 모든 테넌트를 온보딩하기 위해서죠.이제 이 예제의 흐름에서는 테넌트 온보딩이 이루어지기 전에 이 테넌트가 통합 맵을 만들지 않았을 것이라고 가정하겠습니다.따라서 페더레이션 구성을 나중에 수행할 수 있다는 가정하에 일반 테넌트, 일반 테넌트로 온보딩하려고 할 것입니다.따라서 SaaS 입장에서는 등록을 해야 할 것 같습니다.
마이크로서비스는 이 요청을 수락할 계획을 가지고 있습니다.그런 다음 세부 정보를 보면 관리자 세부 정보를 얻을 수 있습니다.
그리고 일반적인 테넌트 온보딩 요청과 같은 회사 세부 정보도.먼저 다음 사항을 작성해 보겠습니다.
새 테넌트의 테넌트 ID를 입력하면
다음과 같은 작업을 수행하는 사용자 관리 마이크로서비스그러면 Amazon Cognito와 함께 작동하고 다음과 같은 비트를 생성할 수 있습니다.
새 테넌트가 필요해요.그럼 세입자가 이렇게 가정해 봅시다.
하나는 프리미엄 등급이에요. 바로 진행할게요
새 사용자 풀을 만든 다음 다음과 같이 구성하십시오.
테넌트 1에서 사용할 수 있도록 준비하세요.그리고 나서 제가 만들게요
테넌트 한 명의 관리자 또는 테넌트에 온보딩한 사용자, 저는 그 사용자를 다음과 같이 만들 것입니다.
SaaS 애플리케이션에 있는 특정 테넌트의 관리자도 마찬가지입니다.현재까지는 페더레이션이 관여하지 않았습니다.이는 100% 페더레이션되지 않은 일반적인 테넌트 온보딩 워크플로우입니다.아시다시피 이 단계에서는 Cognito 도메인에 전달할 수 있는 콜백 URL을 도출할 수 있습니다.
테넌트 1은 테넌트 관리자 URL과 함께 알림으로 사용됩니다.따라서 이 테넌트 관리자 URL은 일반적인 URL을 참조합니다.
SaaS 애플리케이션에 있는 테넌트 관리자 패널에서는 테넌트 관리자가 모든 관리 작업을 수행할 수 있습니다.따라서 이 단계에서 테넌트 원은 이제 OpenID Connect 통합 앱을 만들 수 있습니다. 왜냐하면 테넌트는 다음을 갖추고 있기 때문입니다.
콜백 URL을 전달했습니다.그리고 그들은 그 편을 끝냅니다.
구성을 추출한 다음 구성을 추출합니다.
Cognito가 페더레이션 설정을 완료해야 한다는 것.앱 클라이언트 ID, 클라이언트 암호, 발급자 URL입니다.그러면 테넌트 한 명의 관리자가 실제로는 관리자입니다.
그녀가 로그인할 수 있도록 하는 특정 테넌트
테넌트 관리자 패널에서 해당 URL을 입력합니다.그러면 전체 워크플로를 완료하여 Cognito에서 OpenID Connect 공급자를 만드는 데 도움이 될 것입니다.보시다시피 여기서는 두 단계로 구성된 프로세스입니다.
테넌트 온보딩에서 말이죠.약간 비동기식이지만 테넌트 또는 SaaS 공급자가 테넌트의 온보딩 흐름을 어느 정도 자동화하여 온보딩할 수 있는 원활한 환경을 제공합니다.
페더레이션 지원 포함이제 이 단계에서 테넌트 원 사용자가 SaaS 애플리케이션에 액세스하려고 하면 Cognito는 이를 알게 됩니다.
OpenID Connect 제공자 때문에 페더레이션해야 합니다.그리고 이들을 안내해 줄 것입니다.
테넌트에게 OpenID 연결 프로토콜을 통한 IdP 1개를 제공합니다.그리고 그 이후로는
페더레이션이 일어날 수 있습니다.자, OpenID를 보시면
여기 있는 연결 공급자에는 세부 정보나 구성 외에는 아무것도 없습니다.
테넌트 원 관리자가 제공합니다.다음은 Cognito가 페더레이션을 처리하기 위해 알아야 하는 모든 세부 정보입니다.
테넌트 1명의 사용자자, 이것이 첫 번째 흐름입니다.따라서 플로우 번호 2의 경우 테넌트 2가 있고 SAML을 다음과 같이 사용했습니다.
이 플로우의 예시입니다.차이점은 테넌트 2가 SAML 통합 앱을 미리 만들었을 것이라는 점입니다.물론 구성에 대한 몇 가지 자리 표시자 값을 포함하면
현 단계에서는 알 수 없습니다.그리고 그 일원으로서
온보딩 요청은 Cognito가 페더레이션 플로우를 완전히 생성하는 데 필요한 세부 정보 또는 구성을 전송합니다.따라서 Cognito에 필요한 것은 SAML 통합에서 제공된 메타데이터 URL뿐입니다.
테넌트 2의 앱 맞죠?그래서 제가 그 요청을 받았는데...마이크로서비스 연구.그리고 보통은...평소처럼 그냥 진행할게요
그리고 테넌트 ID를 만드세요.그런 다음 사용자 안에서
관리 마이크로서비스라면 사용자 풀을 만들고 구성하죠.생성할 필요가 없습니다.
지금 바로 관리자 사용자입니다. SAML을 알고 있기 때문에 바로 SAML 공급자를 만들 수 있으니까요.
이 단계의 메타데이터 URL은 이 테넌트가 IdP를 가리키고 있습니다.그게 전부입니다. 이게 모든 구성입니다.
SaaS 애플리케이션 관점.그러면 다음을 도출할 수 있습니다.
SSO URL과 SP 개체 ID입니다.이는 테넌트 2가 SAML 통합을 완료하는 데 필요한 두 가지 구성입니다.
해당 사이트의 앱 구성.따라서 테넌트 2 구성을 완료할 수 있도록 알림으로 전달하겠습니다.보시다시피, 이 두 워크플로는 예시일 뿐이므로 어느 정도 원활한 워크플로를 제공하는 것을 고려해 볼 수 있습니다.
회람을 다루며 온보딩 경험을 해보세요.
우리가 가지고 있는 의존성.그래서 그 권고는 그냥
이 두 워크플로 중 하나를 선택하세요.
아니면 핵심을 손상시키지 않으면서 그 이상의 무언가를 할 수도 있습니다.
원활하고 원활한 서비스를 제공하는 데 도움이 되는 SaaS의 가치 제안
페더레이션을 통한 온보딩 경험 제공이제 이 단계에서는 다음을 갖추는 것이 중요합니다.
이 Cognito를 살펴보고 Cognito 구현의 다양한 멀티 테넌트 측면이 무엇인지 살펴보세요.
페더레이션 설정과 함께이에 대해 이야기하고 더 자세히 살펴보도록 하겠습니다.
세션의 남은 시간에는 토비 스테이지를 초대할게요. - 고마워요 Dhammika.좋아요.담미카가 말했듯이, 모든 연맹이 어떻게 운영되는지에 대해 설명하기 전에, 잠깐 시간을 내어 이에 대해 조금 얘기하고 싶었어요.
단지 아키텍처와 관련된 Cognito의 디자인일 뿐입니다.들어보신 적이 있으시다면
Satisfactor에서 콘텐츠를 읽으셨다면 아마 들어보셨을 겁니다.
“통합” 및 “사일로화”라는 용어우리가 자주 사용하는 용어입니다.
테넌트 리소스에 대한 설명공동 작업의 경우 리소스를 공유하고 있습니다.
모든 테넌트에 걸쳐 말이죠.그리고 사일로화된 사례에서는 리소스를 전담하고 있습니다.
그 테넌트들한테.그런 세력들은...그게 너한테 어떤 영향을 미칠지
어떤 일을 해야 할지 정말 주로 비즈니스 중심적인지 알아내세요.사일로화된 케이스에서는 고립감이 더 심해질 수 있지만 운영상 어려울 수 있다고 주장할 수도 있습니다.하지만 통합형 케이스에서는 좀 더 간단할 수도 있습니다.
하지만 그렇게 고립되어 있지는 않을 수도 있습니다.여기에도 같은 규칙이 적용됩니다.마치 여러분이 가지고 계실 수도 있는 것처럼
테넌트별로 DynamoDB를 분리하거나 테넌트를 혼합할 수 있습니다.
DynamoDB 내에서동일한 규칙이 있다는 점을 지적하고 싶었습니다.
격리되고 풀링된 리소스가 Cognito에 적용됩니다.그냥 지적하고 싶었어요.
이번 강연에서는 제가 주로 초점을 맞출 거라는 점을 말씀드리겠습니다.
통합 모델에 대해서요.여기서 보게 될 많은 것들은 통합에 초점을 맞출 것입니다.그렇긴 하지만, 살펴보도록 하죠.
순식간에 사일로화됐어요. 크게 다르지 않아요.따라서 디자인 관점에서 보면 사용자 풀이 생깁니다. 분명히 하나의 사용자 풀이 있겠죠.
모든 테넌트를 위한 거죠.이 앱 클라이언트부터 시작하겠습니다.자, 앱 클라이언트는, 전에도 몇 번 본 적이 있는데, 제가 말씀드리고 싶은 것은 바로 이것입니다.
저희는 액세스를 차단하고 있습니다.이게 바로
우리가 지키고 있잖아요, 그렇죠?우리의 경우에는 SaaS 애플리케이션입니다.이제 oauth 또는 OIDC를 사용할 때 웹 앱을 작성한 적이 있다면 클라이언트 ID를 눈치채셨을 것입니다.그 ID가 맞죠?그게 바로 우리가 보호하고 있는 거예요.자, 이 경우에는
단 하나의 SaaS 앱이죠.그리고 우리는 일반적으로 옹호합니다.
그건 좋은 생각이에요. 갖고 싶지 않은 거죠.
테넌트당 여러 번 배포할 수 있어요. 좀 다루기 힘들 수 있으니까요.따라서 단일 SaaS 앱만 있으면 모든 테넌트가 이곳으로 들어올 수 있습니다.그럼 이제 한 번 살펴보죠.
어떻게 생겼는지.담미카가 말했듯이, 부분적으로는
온보딩 프로세스를 진행하려면
페더레이션된 IdP를 만드세요.이 경우에는 OIDC를 만들고 있습니다.저 작은 파란색 상자의 설정을 보면 알 수 있겠지만
조금 작을 수도 있지만 Okta는 성공하고 있습니다.따라서 해당 테넌트가 사용자 한 명일 때
Cognito는 이 페더레이션을 통해 해당 페더레이션을 생성할 것입니다.
우리를 위해 그룹에 속한 사용자들.우리가 신청할 수 있는 그 그룹
원하는 경우 테넌트 전용 정책을 적용할 수 있습니다.그거 좋네요.전체 사용자 풀이나 해당 사용자 풀의 단순 사용자 목록이 아니죠?우리를 위해 그룹화하는 거니까 좋네요.두 번째 사례와 마찬가지로, 두 명의 세입자가 이를 사용하고 있습니다. 소셜 서비스 제공자인 Facebook이죠.
놈들이 들어오고 있어요.다시 말씀드리지만, 페이스북이 생겼습니다.
해당 IdP에 저장한 특정 구성.이제 곧 완성되고 있습니다.
같은 앱 클라이언트.다시 말씀드리지만, 또 다른 그룹이 있습니다.
그 유저들을 저장하는 거죠.자, 좋은 점은
여기서 흥미로운 점은 구성의 관점에서 클라이언트 ID를 기억해 두어야 한다는 것입니다.
그리고 아마도 발급자 URL과 권한 등등
웹 앱 내부는 이 앱 클라이언트를 가리키고 있지만 두 가지 다른 것이 있습니다.
테넌트가 이 문제를 해결하고 있습니다.그래서 이것은 하나의 선물을 제공합니다.
흥미로운 도전과제는, 어떻게 하면 가능할까요?
페더레이션된 IdP가 로그인하면 해결되죠?그리고 저는 그냥 포즈를 취할게요.
일단은 그 질문이요답은 안 할게요. 하지만 그냥 알려줄게요
잠시만 기다려 주세요. 다시 얘기할게요.하지만 이게 공동 모델이죠, 그렇죠?그러니까 모든 사용자가 단일 사용자 풀에 있는 거죠.다시 말씀드리지만, 다음을 사용할 수 있습니다.
베이직 티어 같은 경우에 말이죠.만약 우리가 뭔가를 하고 싶었다면
테넌트를 위한 사용자 풀이 있는 좀 더 이국적인데, 아마도 당신의 테넌트들은 같은 사용자로 살고 싶어하지 않을 수도 있습니다.
풀은 다른 테넌트들처럼 말이죠, 그렇죠?그건 완전히 유효해요.아니면 다른 MFA 또는 복구 요구 사항이 필요할 수도 있습니다.
그 구성이 무엇이든 간에, 해당 구성 집합은
앱 풀 수준에서든 사용자 풀 수준에서든, 이런 경우에는 다른 사용자 풀이 필요합니다.Cognito 관점에서 보면
모든 것이 동일하게 유지됩니다.제가 말씀드리고 싶은 것은 이제 두 개가 생겼다는 것입니다.
서로 다른 앱 클라이언트.따라서 서로 다른 두 앱 클라이언트는 두 가지 다른 구성을 의미합니다.따라서 예전에 설명했거나 이전 슬라이드에서처럼 단일 웹 앱을 사용하는 경우 런타임에 해당 구성 항목을 어느 정도 해결해야 합니다. 그렇죠?이제 테넌트 하나가 인증이라는 것을 알아내셔야 합니다.클라이언트 ID가 뭐죠?사용자 풀은 무엇인가요?그런 것들이죠.확실히 가능해요. 참고할 만한 자료가 있어요.
시중에 나와 있는 아키텍처들은...그게 가능하죠.그러니 관심이 있으시다면 나중에 연락해 주세요.
그 얘기 좀 할 수 있겠어요.자, 이것이 바로 사일로 모델인데요, 이것만 짚고 넘어가자면
두 가지 타당하고 유효한 경우가 있습니다.자, 이제 그 흐름이 어떤 모습인지 얘기해 보죠.OIDC 흐름은 다음과 같습니다.이 슬라이드를 본 적이 있습니다.담미카가 보여준 게 있어요
우리가 하고 있었다는 점만 빼면 이와 매우 비슷합니다.
사용자 풀 인증.이 경우에는 테넌트 사용자가 있습니다.다시 말씀드리지만, 세션이 없습니다.쿠키도 없고, 쿠키도 없어요.
인증 정보가 필요함을 알 수 있도록
이 사람을 인증하세요.Cognito에 도달했습니다.우리가 맞닥뜨리고 있는 걸 눈치채셨나요?
oauth2/Authorize 엔드포인트입니다.해당 API를 볼 수 있을 것입니다.
몇 번이고 반복해서 말씀드리자면, 이것이 Cognito의 핵심입니다.Cognito는 클라이언트 ID를 보고 이렇게 말합니다. 아, 이거 보여요.
한 마리만 먹여야겠네요.정보가 없어요
이 사람을 인증하려면 연기해야 해요그래서 저는 이 제3자인 이 OIDC IdP를 찾아갈 거예요.이 시점에서 John Doe가 보고 있는 것은
그의 IdP의 로그인 화면.그가 로그인하면 기본적으로 전화가 옵니다.
우리가 OIDC를 하고 있기 때문에 또 다른 인증된 엔드포인트가 있잖아요, 기억나요?그리고 우리가 통과했다고 가정하면
인증, 당면 과제, 그러면 OIDC는
이 IdP 응답으로 다시 Cognito로 리디렉션해 주세요.아마 아까 담미카의 강연이나 담미카의 강연에서 보셨을 겁니다.그래서 oauth2 응답을 받았습니다.그리고 이 시점에서 Cognito는 “네, 인증을 받았어요. 우리가 a라고 부르는 것을 만들어 봅시다.
프록시 사용자, 섀도우 사용자, 일종의 기본적으로는
실제 사용자의 메아리죠.진실의 근원은 여전히
타사 IdP로 넘어가세요.하지만 Cognito는 다음을 만들고 있습니다.
사용자 풀에 있는 해당 사용자의 일종의 버전입니다.일단 그런 일이 생기면, 우리는
일반적인 302 리디렉션을 수행한 다음 교환을 진행합니다.
토큰을 위한 코드 말이에요.그리고 토큰을 얻게 되고, 이제 막 페더레이션된 상태로 돌아가게 되죠.SAML의 관점에서 보면
거의 똑같습니다.제가 지적하고 싶은 것은 우리가 여전히 oauth2/authorize 엔드포인트를 사용하고 있다는 것입니다. 그렇죠?그래서 코그니토에서...우리 앱의 관점에서는 알아두기만 하면 됩니다.
oauth2/authorize에 대해서는 알 필요가 없습니다.
SAML이나 다른 것들이죠.이제 Cognito는 이를 확인하고 클라이언트 ID를 조회한 후 SAML 인증을 수행하려면 여기로 이동해야 한다는 것을 알게 됩니다.그렇게 하긴 하지만 지금은
조금 달라졌어요.같은 OIDC가 아니에요.
엔드포인트 권한 부여라던가, 이제 SAML 작업을 하고 있잖아요, 그렇죠?그리고 이 모든 것은 XML에 기반하고 인증서와
전체 아홉 야드.좋은 소식은 여러분의 앱입니다.
걱정하지 않으셔도 됩니다. Cognito가 대신 처리해 드립니다.그래서 인증을 받게 되죠.John이 사이트에 로그인했습니다. 인증 챌린지를 통과했습니다.SAML 어설션을 받고 사용자 및 사용자 풀을 만든 다음 바로 돌아옵니다.
예전처럼 토큰에 대해서요.제 생각에 여기서 얻을 수 있는 교훈은 바로 이것입니다.
아마 한 해 동안 몰랐던 것 같아요.
Cognito에서 1년 동안 일했는데, 그 코그니토가 정말 그런가요?
페더레이션 허브입니다. 그게 명확하지 않다면...어쩌면 당연한 일이었을지도 몰라요
모두들, 하지만 저는 아니에요. 여러분의 앱이 처리해야 할 문제라는 점에서요.
OIDC와 oauth, 그렇죠?그런 관점에서 말이죠.이상한 일은 절대 다룰 필요가 없죠.
프로토콜은 좋은데, 나도 몰라서
대부분의 웹 앱에 SAML 라이브러리가 있다면 말이죠.있을 수도 있지만 OIDC와 oauth는
분명히 웹 앱 공간에서 정말 잘 지원되고 잘 이해되고 있습니다.따라서 앱 개발자 관점에서는 훌륭합니다.정말 빠르게 살펴보죠.
그 그룹들이 어떻게 생겼는지.말씀드렸듯이, 일단 우리가
프록시 사용자를 생성하세요. 스크린샷은 다음과 같습니다.
콘솔에서 바로 사용할 수 있습니다.콘솔이 실제로 업데이트되었습니다.따라서 이것은 현실을 반영하지 않을 수도 있지만, 이것은 현실에서 일주일 정도를 뺀 수치입니다.여기 맨 위에 보시면 밥과 샐리가 지나가고 있는 것을 보실 수 있습니다.
이 공급자는 Okta OIDC입니다.한 가지 말씀드리자면
제가 Okta OIDC라는 이름을 제대로 선택하지 못했다는 것을요.마법같은 건 없어요. 사실 제가 고른 것은 Okta OIDC라는 문자열이에요.
그거랑 아무 상관이 없어요...여기에는 비밀이 없어요.하지만 밥과 샐리가 지나가는 게 보여요.Cognito는 페더레이션을 통해 들어오는 해당 사용자의 이름을 실제로 지정하는데, Okta OIDC는 문자열에 밑줄을 긋습니다.또한 입금 기능도 있습니다.
이러한 사용자들은 일종의 상관관계가 있는 그룹에 속하게 됩니다.
사용자 풀 ID 및 페더레이션에도 적용됩니다.보시다시피,
아래에 있는 또 다른 그룹은 Okta SAML이라는 그룹인데, 제가 선택한 그룹은 SAML 페더레이션 사용자를 위한 그룹입니다.좋아요.그래서 한 가지 과제가 있습니다.
Dhammika가 지적한 것은 우리 임차인이나 고객이 관리하기를 원한다는 것이었습니다.
사용자의 라이프사이클.페더레이션이 어떻게 페더레이션되는지 살펴봤습니다.
그렇게 할 수 있어요. 훌륭하죠. 하지만 제가 지금 제시하고 싶은 과제는
외부 페더레이션이면서 사용자를 위한 진실의 근원이죠. 하지만 그걸 진실의 근원에 어떻게 매핑할 수 있을까요?다시 말해, Okta에 살고 있는 사용자가 있다면 그 사람은 밥 스미스일 수도 있겠지만 이름과 성을 말하자면 성이 있겠죠?차이점을 어떻게 조화시킬 수 있을까요?음, 우리는 매핑을 통해 이 작업을 수행합니다.그래서 실제로 이런 일이 일어납니다.
나가는 쪽 양쪽에서, Okta 쪽에서도 마찬가지입니다.그래서 우리가 통합 앱을 만들면 대부분의 IdP는
어떤 버전이든 사용할 수 있습니다.
현실은 그들의 편이고 그것을 어떤 기준에 맞출 수 있죠.
이 경우에는 OIDC입니다.그리고 수신 측에서도 마찬가지죠. Okta 측에서도 말이죠. 아, 미안해요. Cognito 쪽에서도 말이죠.이러한 표준 OIDC 속성을 가져와서 사용자 속성에 매핑해 보겠습니다.따라서 우리는 다음을 수행할 수 있습니다.
원하신다면 그들의 버전을 저희 버전으로 정규화하는 거죠.다시 말씀드리지만, 이것들이 진실의 근원입니다.SAML도 마찬가지입니다.이제 XML 기반이고 스키마가 많이 있습니다.
관련된 것이든 뭐든 상관없지만 여전히 똑같아요, 그렇죠?하지만 또 다른 문제는
담미카가 암시한 것은 우리에겐 여전히 필요하다는 것입니다.
테넌트 ID 맞죠?그리고 우리 세입자가 밖에 있으면 뭐가 뭔지도 모를 거예요
세입자 ID가 맞죠?우린 그게 뭔지 알지만 그들은 몰라요.그럼 이 문제를 어떻게 해결할 수 있을까요?글쎄요, 그렇듯이
대부분의 경우, 코드가 필요하다면
맙소사, Lambda를 부르잖아요, 그렇죠?Cognito에는 Lambda 트리거에 대한 이 버전 또는 개념이 있습니다. Lambda 트리거는 기본적으로 Cognito 워크플로 내의 라이프사이클 이벤트입니다.이것은 웹페이지 바로 옆에 있는 문서의 스크린샷입니다.QR 코드를 입력하면 해당 페이지로 이동할 수 있습니다.게시물 확인을 사용하는 것이 좋습니다.
람다 트리거는...그 이유는 사용자가 생성될 때만 호출되기 때문입니다.다른 하나는, 고객들이 우리에게 사전 토큰을 왜 안 쓰냐고 물어봤다는 겁니다.
제너레이션이랄까요?뭐, 만약 당신이 하고 있는 일이 있다면
페더레이션을 통해 들어올 때 기본적으로 사용자에게 연결하기 위한 테넌트 ID를 찾는 것인데 꼭 필요한 것은 아닙니다.
매번 그렇게 해야겠죠?테넌트 ID는 자주 바뀌지 않아야 합니다.그럼 그냥...한 번 불러볼게요.좀 더 이국적인 게 있거나 더 자주 불러야 할 게 있다면 기절하세요.그 모든 유발 요인을 보세요.각 항목을 클릭하면 알 수 있습니다.
언제 사용해야 하며 왜 사용해야 하는지.꽤나 풍부한 물건들인데
사용자 정의를 보면 워크플로 측면에서 이런 일이 일어날 수 있습니다.
인증 흐름.사실 방금 살펴봤습니다.
이 강연 직전에 Cognito 콘솔을 살펴봤어요.그리고 이 중 많은 부분이 이미 내장되어 있습니다. 그들은 이 기능을 더 최상급으로 만들고 있습니다.하지만 암호가 필요 없는 키, 암호 키 등 모든 종류의 작업은 다음과 같이 처리할 수 있습니다.
코그니토 트리거와 코그니토.그러니 꼭 확인해 보세요.어떻게 생겼는지 한 번 살펴보죠.간단한 예를 하나 더 들어보죠. 우리는 이걸 백만 번 봤어요.우리는 연합해야 한다는 것을 알고 있습니다. 우리는 이제 곧 창조할 준비가 되었습니다.
사용자, 우리도 그렇지만 이제 트리거가 생겼습니다.
사용자 풀에 연결됐어요.해당 트리거가 호출됩니다.
강력한 형식의 이벤트와 함께 말이죠.다음 샘플을 살펴보겠습니다.
그 코드는 잠시 후에 보여드릴게요.그리고 이 경우에는, 저는
예를 들어볼게요, 그렇죠?들어오는 데이터를 가져와서 DynamoDB에서 찾고 있는데 테넌트 ID를 찾아서 SDK를 호출하고 해당 ID로 테넌트를 업데이트한 다음 다시 토큰을 발행할 거예요.그리고 토큰과 같이
이 ID는 사용자 지정 클레임입니다.이제 제가 지적하고 싶은 것은 담미카가 처음에 제작에 대해 이야기하고 있었다는 것입니다.
사용자 스키마, 우리가 스키마라고 부르는 것을 확실히 하세요.
이 내용도 들어 있죠?원하신다면
이러한 속성을 추적하세요. 직접 만들 때 이 작업을 완료했는지 확인하세요.
사용자 풀의 사용자, 왜냐하면 그렇지 않으면
아직 해보지 않았다면 실패할 것입니다.데이터를 넣을 슬롯이 없다면
안으로, 안 되겠네요.그 버전을 하나 보여드릴게요.분명히 프로덕션 코드는 아니지만, 이건 브릿지 역할을 합니다.
해당 트리거의 버전입니다.아까 말씀드렸듯이
타이핑이 강하기 때문에 포스팅이 있습니다.
확인 트리거 이벤트는 타입스크립트입니다.그 트리거 이벤트는 운 좋게도
우리가 해야 할 일은 전부...우리가 해야 할 거의 모든 것
앞서 언급한 SDK 호출을 수행하세요. 단, 테넌트 ID는 예외입니다.그럼 이걸 어떻게 얻을 수 있을까요?여기 보니까 제가 가짜를 가지고 있는 걸 볼 수 있잖아요.
화면 밖의 어딘가에서 이메일 주소를 가져와 도메인을 해킹하고 테넌트를 찾는 방법들이 있을 수 있습니다.
도메인 기반 ID.마지막으로 입력값을 취합하고 관리자 업데이트를 호출합니다.
SDK로 사용자 속성 명령을 실행하면 바로 실행할 수 있습니다.이제 제가 제시한 문제에 대해 이야기해 보죠.
맨 처음에 말이죠.앱 클라이언트가 하나 있고 여기에 여러 IdP가 연결되어 있습니다.어떻게 생겼는지 런타임에 어떻게 해결할 수 있을까요?아무 것도 하지 않으면 이렇게 보일 거예요.그리고 그건 좋지 않아요, 그렇죠?꼭 그러고 싶지는 않잖아요...사용자들이 그걸 보는 걸 원치 않으실 겁니다.다시 말씀드리지만, 이게 전류입니다.
앱 클라이언트 측면에서 어떻게 보이는지에 대한 1주간의 스크린샷을 빼면
그리고 Cognito 콘솔도 포함해서요.이 경우 앱 클라이언트가 Cognito 사용자 풀 인증을 연결한 것을 볼 수 있습니다.
바로 이 사람입니다.그리고 SAML 페더레이션과 OIDC 페더레이션도 연결했습니다.따라서 이상적이지는 않습니다.꼭 원하지는 않을 거예요. 특히 만약 우리가 가지고 있다면 말이죠.
백 페더레이션 아이덴티티, 이게 어떻게 되는지도 모르겠어요
이 경우 화면이 렌더링되겠지만 아마 예쁘지 않을 것입니다.하지만 어찌 됐든 우리는 아마도
가능하면 우회하고 싶어요.좋은 소식은 우리가 할 수 있다는 거예요. 그럼 어떤 모습일까요?그래서 우리는 다시 여기서 왔어요...화면을 다시 봤어요. 페더레이션이 필요해요.하지만 이번에는 인증 통화에 또 다른 작은 속성을 추가하려고 합니다.IdP는 식별자를 밑줄로 표시한 다음 토큰을 전달하고 있습니다. 그 내용은 잠시 후에 살펴보도록 하겠습니다.하지만 이렇게 하면 Cognito가 공급자를 찾을 수 있겠죠?이 조회는 다음을 기반으로 합니다.
우리가 전달한 이 토큰이죠.이 경우 Azure AD라는 것을 알 수 있습니다. 아마도 SAML을 할 것입니다.따라서 해당 공급자를 동적으로 선택한 다음 해당 공급자의 프로토콜을 기반으로 동적으로 인증합니다.이제 다시 살펴보겠습니다.
토큰이 있으면 행복해요.그럼 뭐가...이 QR 코드는 oauth2/authorize를 전달할 수 있는 다른 매개 변수에 대해 설명하는 문서로 연결해 줄 것입니다.IdP 식별자, 이미 말씀드렸어요.다시 말씀드리지만, 상단은 사용자 풀 내에 페더레이션된 ID 공급자를 생성할 때의 스크린샷입니다.이 경우에는
해당 제공자에 있는 필드를 식별자라고 합니다.문자열을 전달하고 해당 문자열을 제공하면
authorize 호출 시 다음과 같은 메시지가 나타납니다.그러면 Cognito가 그걸 선택할 거예요.
너한테는 좋은 일이야.아니면, 패스할 수도 있고요
제공자 이름.그 제공업체 중 한 곳의 이름으로 Okta OIDC를 사용했던 것을 기억하세요. 저는 Okta SAML을 사용했고, 여기 SaaS 회사 SAML이 있습니다.이름을 다음과 같이 전달하면 됩니다.
아이덴티티 언더스코어 제공자를 선택하면 Cognito가 이를 선택합니다.
하나는 여러분을 위한 것이기도 합니다.둘 중 하나를 통과할 수도 있고, 둘 다 통과할 필요는 없습니다.그리고 보너스 콘텐츠도 있습니다. 로그인, 힌트를 전달하면 또 다른 매개변수가 생깁니다.
이메일 주소를 주세요.사용자 풀 인증의 경우 실제로 해당 정보를 제공합니다.
사용자는 사용자 풀 또는 해당 로그인 이름으로 이동합니다.OIDC나 Google의 경우에도 동일한 작업을 수행할 수 있습니다.따라서 만약 여러분이 사용하고 있다면
Google 제공업체 또는 OIDC에서도 해당 정보를 얻을 수 있습니다.SAML이나 다른 제공업체, 다른 소셜 서비스 제공업체를 이용하는 경우에도 할 수 있습니다.
문서를 확인해야 합니다.이건 좀 더 복잡해요. 이거만큼 간단하진 않아요.좋아요, 그럼 뭐죠?
이 연맹에서 고려해야 할 몇 가지 사항이 있나요?첫째, 우리는 이 문제를 좀 더 들여다보고 좀 더 생각해 보는 중이에요.
Cognito 트리거에 대해, 그리고 어떤 것들이 있나요?
SaaS 제공업체는 이 문제를 겪으면서 직면할 수 있습니다.우리에게 떠오른 일 중 하나는 IdP, 즉 SaaS IdP가 있다면 그 안에 백만 명의 사용자가 있다고 가정해 보죠.그리고 그 사용자들은 찾아오려고 합니다.
연맹을 통해서라면 그들을 막을 수 있는 건 아무것도 없겠죠?코그니토는 기꺼이 새로워질 거예요
사용자 풀의 모든 사용자가 그럴 것입니다.
어쨌든 그렇죠?멈출 수 없어요.하지만 SaaS 제공업체라면 자격 또는 등급 등을 통해 이를 처리하고 싶을 수도 있습니다.그래서 우리가 꿈꿨던 작은 일인데 트리거로 처리할 수도 있겠죠.다시 말씀드리지만, 우리는 이 문서, 이 슬라이드를 많이 보았습니다.우리는 연합합니다.이제 사용자를 만드는 대신 이렇게 부릅니다.
사전 인증 트리거.그리고 이것이 우리에게 줄 수 있는 것은 일종의 일종의 성과입니다.
우리가 원하면 나가버리죠.그래서 우리가 확인해 볼 수도 있겠네요.
이 테넌트의 자격사용자 수가 100명 미만이거나 사용자 수가 약간 부족하다고 말할 수 있습니다.
한계점이나 뭐 그런가요?무슨 사업이든 통과했다고 가정해 봅시다.
Lambda의 로직은 성공적으로 수행한 후 토큰을 발행하고 작업을 종료하는 것입니다.하지만 이를 통해 “아니, 미안해, 했잖아”라고 말할 수 있는 능력도 얻게 됩니다.
자격을 초과했거나 지원이라고 부르겠습니다.
어떤 경우이든 상관없죠.따라서 여기서 중요한 것은 자격 처리가 중요하다는 것이 아니라요점은 다음과 같습니다.
Cognito와 이러한 트리거, 시나리오는 없습니다.
당신이 다루어질 수 없다는 걸 꿈꿀 수도 있겠네요, 그렇죠?그러니까 정말 부자인 셈이죠.
원하신다면 한 걸음 더 가까이 다가가세요.
SaaS 제공업체로서 직면할 수 있는 이러한 일회성 상황.따라서 몇 가지 고려 사항이 있습니다.
시크릿 페더레이션과 함께 말이죠.적어도 저한테는 그럴 수도 있겠네요.
좀 이기적인 점은 제가 이해했을 때...Cognito를 oauth2와 OIDC 관점에서 살펴보았을 때 모든 것이 명확해졌습니다.물론 우리 문서는 훌륭하지 않습니다.만약 여러분도 같은 문제에 직면하고 있다면, 한 번 생각해 보세요.
oauth2와 OIDC 관점에서 보면 좀 더 명확해질 것 같아요.할당량, 리소스 할당량 및
한도가 적용됩니다.따라서 다음과 같은 계획을 세워야 합니다.
여러분의 아키텍처에 있는 것들이죠.거기 있는 문서들이 링크될 거예요
할당량 바로 알겠네요지역당 특정 수의 사용자 풀, 특정 수의 앱
사용자 풀당 클라이언트 수, 이런 식이죠.페더레이션 가격은 약간 올라갑니다.그래서 제가 마지막으로, 또 다시 말씀드리지만
이 모든 것은 변경될 수 있으니 제 말을 인용하지 마세요. 하지만 제 생각에는 월간 실사용자 한 명당 반 페니 정도였던 것 같아요.
페더레이션이 아닌 사용자들한테는 한 푼이라도
페더레이션 사용자당 절반다시 말씀드리지만, 아직 주문 중입니다.
달러가 아니라 페니로 만들었지만 여전히 훌륭한 가치입니다.Cognito는 우리가 볼 수 있는 많은 제품들보다 싸다는 뜻이에요.마지막으로, 사용자 풀은 정말
이 경험의 중심이죠.여기에는 자격 증명 풀이 전혀 없습니다.뭐가 뭔지 헷갈린다면
차이점이 있다는 건 이해해요.(웃음) 사용자 풀은 정말
사용자 등록 및 확인에 대해
라이프사이클 및 추적.아이덴티티 풀은 더 많습니다.
웹 사이트 구축과 같이 수명이 짧은 자격 증명에 대해
앱이나 모바일 앱에 쓰리 액세스 권한이 있는 것 같은데요?그래서 여기서는 전혀 효과가 없네요.그게 다야, 우린
이제 끝입니다.그러니까 페더레이션이죠.
움직이는 부분이 몇 가지 더 있습니다.지금까지 이런 상황을 피했다면 다시 한 번 살펴보는 것이 좋습니다.그렇게 어려운 건 아니에요.
Cognito를 사용하면 아주 쉽습니다.그리고 모두 자동화가 가능합니다.
담미카에서 보신 것처럼 말이죠.코그니토는 페더레이션 허브예요. 저는 이미 그 드럼을 이겼어요.커스터마이징을 위한 트리거인데, 어떤 건지 잘 모르겠네요.
유용하고 편리합니다.정말 많은 것들이 있어요.
Lambda에서는 이 두 가지를 조합하여 작업할 수 있습니다.진실의 원천인 사용자 간의 차이를 어떻게 조정할 수 있는지 살펴보았습니다.
우리의 진실 출처를 사용해서 말이죠.그러기 위해 매핑을 사용했죠.그리고 우리는 자동적으로 할 수 있었습니다.
페더레이션된 IdP를 선택해서 굳이 그럴 필요가 없죠.
크고 못생긴 화면을 보세요. 멋지네요.그리고 마지막으로, 우린
현재 어떤 모드에 있든, 페더레이션이든 아니든, 항상 이 모드를 플레이하는 것이 좋습니다.이는 페더레이션 ID라기보다는 SaaS의 일종인 셈입니다.다음 사항만 꼭 확인하세요.
온보딩 프로세스는 최대한 순조롭게 진행됩니다. 그렇죠?이렇게 하면 사용자들이 최대한 빨리 여러분의 가치를 인정받게 될 거예요.그게 전부예요.그냥 부탁할게, 제발, 제발
설문조사를 해 주세요.좋아요를 누르고 구독하세요
버튼, 그 모든 것들이요이게 우리의 진짜 모습이에요
내년의 강연을 구체화해 보세요.그래서 만약 뭔가가 있다면
좋아하거나 싫어했거나 보고 싶은 것이 있다면 설문조사에 남겨주세요.우리는 그걸 보고 계획을 세웁니다.
내년 세션에서는 그걸로 끝이에요. 정말, 정말, 정말
우리에게 유용한 정보죠.